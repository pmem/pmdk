.\" Automatically generated by Pandoc 2.1.3
.\"
.TH "PMEMOBJ_MEMCPY_PERSIST" "3" "2018-05-07" "PMDK - pmemobj API version 2.3" "PMDK Programmer's Manual"
.hy
.\" Copyright 2014-2018, Intel Corporation
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"
.\"     * Redistributions of source code must retain the above copyright
.\"       notice, this list of conditions and the following disclaimer.
.\"
.\"     * Redistributions in binary form must reproduce the above copyright
.\"       notice, this list of conditions and the following disclaimer in
.\"       the documentation and/or other materials provided with the
.\"       distribution.
.\"
.\"     * Neither the name of the copyright holder nor the names of its
.\"       contributors may be used to endorse or promote products derived
.\"       from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
.\" "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
.\" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
.\" A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
.\" OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
.\" SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
.\" LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
.\" OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.SH NAME
.PP
\f[B]pmemobj_persist\f[](), \f[B]pmemobj_xpersist\f[](),
\f[B]pmemobj_flush\f[](), \f[B]pmemobj_xflush\f[](),
\f[B]pmemobj_drain\f[](), \f[B]pmemobj_memcpy\f[](),
\f[B]pmemobj_memmove\f[](), \f[B]pmemobj_memset\f[](),
\f[B]pmemobj_memcpy_persist\f[](), \f[B]pmemobj_memset_persist\f[]()
\[en] low\-level memory manipulation functions
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <libpmemobj.h>

void\ pmemobj_persist(PMEMobjpool\ *pop,\ const\ void\ *addr,
\ \ \ \ size_t\ len);
void\ pmemobj_flush(PMEMobjpool\ *pop,\ const\ void\ *addr,
\ \ \ \ size_t\ len);
void\ pmemobj_drain(PMEMobjpool\ *pop);

int\ pmemobj_xpersist(PMEMobjpool\ *pop,\ const\ void\ *addr,
\ \ \ \ size_t\ len,\ unsigned\ flags);
int\ pmemobj_xflush(PMEMobjpool\ *pop,\ const\ void\ *addr,
\ \ \ \ size_t\ len,\ unsigned\ flags);

void\ *pmemobj_memcpy(PMEMobjpool\ *pop,\ void\ *dest,
\ \ \ \ const\ void\ *src,\ size_t\ len,\ unsigned\ flags);
void\ *pmemobj_memmove(PMEMobjpool\ *pop,\ void\ *dest,
\ \ \ \ const\ void\ *src,\ size_t\ len,\ unsigned\ flags);
void\ *pmemobj_memset(PMEMobjpool\ *pop,\ void\ *dest,
\ \ \ \ int\ c,\ size_t\ len,\ unsigned\ flags);

void\ *pmemobj_memcpy_persist(PMEMobjpool\ *pop,\ void\ *dest,
\ \ \ \ const\ void\ *src,\ size_t\ len);
void\ *pmemobj_memset_persist(PMEMobjpool\ *pop,\ void\ *dest,
\ \ \ \ int\ c,\ size_t\ len);
\f[]
.fi
.SH DESCRIPTION
.PP
The \f[B]libpmemobj\f[]\-specific low\-level memory manipulation
functions described here leverage the knowledge of the additional
configuration options available for \f[B]libpmemobj\f[](7) pools, such
as replication.
They also take advantage of the type of storage behind the pool and use
appropriate flush/drain functions.
It is advised to use these functions in conjunction with
\f[B]libpmemobj\f[](7) objects rather than using low\-level memory
manipulation functions from \f[B]libpmem\f[].
.PP
\f[B]pmemobj_persist\f[]() forces any changes in the range
[\f[I]addr\f[], \f[I]addr\f[]+\f[I]len\f[]) to be stored durably in
persistent memory.
Internally this may call either \f[B]pmem_msync\f[](3) or
\f[B]pmem_persist\f[](3).
There are no alignment restrictions on the range described by
\f[I]addr\f[] and \f[I]len\f[], but \f[B]pmemobj_persist\f[]() may
expand the range as necessary to meet platform alignment requirements.
.RS
.PP
WARNING: Like \f[B]msync\f[](2), there is nothing atomic or
transactional about this call.
Any unwritten stores in the given range will be written, but some stores
may have already been written by virtue of normal cache
eviction/replacement policies.
Correctly written code must not depend on stores waiting until
\f[B]pmemobj_persist\f[]() is called to become persistent \- they can
become persistent at any time before \f[B]pmemobj_persist\f[]() is
called.
.RE
.PP
The \f[B]pmemobj_flush\f[]() and \f[B]pmemobj_drain\f[]() functions
provide partial versions of the \f[B]pmemobj_persist\f[]() function
described above.
These functions allow advanced programs to create their own variations
of \f[B]pmemobj_persist\f[]().
For example, a program that needs to flush several discontiguous ranges
can call \f[B]pmemobj_flush\f[]() for each range and then follow up by
calling \f[B]pmemobj_drain\f[]() once.
For more information on partial flushing operations, see
\f[B]pmem_flush\f[](3).
.PP
\f[B]pmemobj_xpersist\f[]() is a version of \f[B]pmemobj_persist\f[]()
function with additional \f[I]flags\f[] argument.
It supports only the \f[B]PMEM_F_RELAXED\f[] flag (see
\f[B]pmem_memcpy\f[](3)).
.PP
\f[B]pmemobj_xflush\f[]() is a version of \f[B]pmemobj_flush\f[]()
function with additional \f[I]flags\f[] argument.
It supports only the \f[B]PMEM_F_RELAXED\f[] flag (see
\f[B]pmem_memcpy\f[](3)).
.PP
The \f[B]pmemobj_memmove\f[](), \f[B]pmemobj_memcpy\f[]() and
\f[B]pmemobj_memset\f[]() functions provide the same memory copying as
their namesakes \f[B]memmove\f[](3), \f[B]memcpy\f[](3), and
\f[B]memset\f[](3), and ensure that the result has been flushed to
persistence before returning (unless \f[B]PMEM_MEM_NOFLUSH\f[] flag was
used).
Flags have the same meaning as in \f[B]pmem_memmove\f[](3),
\f[B]pmem_memcpy\f[](3) and \f[B]pmem_memset\f[](3).
.PP
\f[B]pmemobj_memcpy_persist\f[]() is an alias for
\f[B]pmemobj_memcpy\f[]() with flags equal to 0.
.PP
\f[B]pmemobj_memset_persist\f[]() is an alias for
\f[B]pmemobj_memset\f[]() with flags equal to 0.
.SH RETURN VALUE
.PP
\f[B]pmemobj_memmove\f[](), \f[B]pmemobj_memcpy\f[](),
\f[B]pmemobj_memset\f[](), \f[B]pmemobj_memcpy_persist\f[]() and
\f[B]pmemobj_memset_persist\f[]() return destination buffer.
.PP
\f[B]pmemobj_persist\f[](), \f[B]pmemobj_flush\f[]() and
\f[B]pmemobj_drain\f[]()
.PP
\f[B]pmemobj_xpersist\f[]() and \f[B]pmemobj_xflush\f[]() returns
non\-zero value and sets errno to EINVAL only if not supported flags has
been provided.
.PP
do not return any value.
.SH EXAMPLES
.PP
The following code is functionally equivalent to
\f[B]pmemobj_memcpy_persist\f[]():
.IP
.nf
\f[C]
void\ *
pmemobj_memcpy_persist(PMEMobjpool\ *pop,\ void\ *dest,
\ \ \ \ const\ void\ *src,\ size_t\ len)
{
\ \ \ \ void\ *retval\ =\ memcpy(dest,\ src,\ len);

\ \ \ \ pmemobj_persist(pop,\ dest,\ len);

\ \ \ \ return\ retval;
}
\f[]
.fi
.PP
\f[B]pmemobj_persist\f[]() can be thought of as this:
.IP
.nf
\f[C]
void
pmemobj_persist(PMEMobjpool\ *pop,\ const\ void\ *addr,\ size_t\ len)
{
\ \ \ \ /*\ flush\ the\ processor\ caches\ */
\ \ \ \ pmemobj_flush(pop,\ addr,\ len);

\ \ \ \ /*\ wait\ for\ any\ pmem\ stores\ to\ drain\ from\ HW\ buffers\ */
\ \ \ \ pmemobj_drain(pop);
}
\f[]
.fi
.SH SEE ALSO
.PP
\f[B]memcpy\f[](3), \f[B]memset\f[](3), \f[B]pmem_msync\f[](3),
\f[B]pmem_persist\f[](3), \f[B]libpmem\f[](7) \f[B]libpmemobj\f[](7) and
\f[B]<http://pmem.io>\f[]
