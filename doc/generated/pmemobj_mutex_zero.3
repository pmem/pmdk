.\" Automatically generated by Pandoc 2.0.6
.\"
.TH "PMEMOBJ_MUTEX_ZERO" "3" "2020-01-16" "PMDK - pmemobj API version 2.3" "PMDK Programmer's Manual"
.hy
.\" Copyright 2014-2020, Intel Corporation
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"
.\"     * Redistributions of source code must retain the above copyright
.\"       notice, this list of conditions and the following disclaimer.
.\"
.\"     * Redistributions in binary form must reproduce the above copyright
.\"       notice, this list of conditions and the following disclaimer in
.\"       the documentation and/or other materials provided with the
.\"       distribution.
.\"
.\"     * Neither the name of the copyright holder nor the names of its
.\"       contributors may be used to endorse or promote products derived
.\"       from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
.\" "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
.\" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
.\" A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
.\" OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
.\" SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
.\" LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
.\" OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.SH NAME
.PP
\f[B]pmemobj_mutex_zero\f[](), \f[B]pmemobj_mutex_lock\f[](),
\f[B]pmemobj_mutex_timedlock\f[](), \f[B]pmemobj_mutex_trylock\f[](),
\f[B]pmemobj_mutex_unlock\f[](),
.PP
\f[B]pmemobj_rwlock_zero\f[](), \f[B]pmemobj_rwlock_rdlock\f[](),
\f[B]pmemobj_rwlock_wrlock\f[](), \f[B]pmemobj_rwlock_timedrdlock\f[](),
\f[B]pmemobj_rwlock_timedwrlock\f[](),
\f[B]pmemobj_rwlock_tryrdlock\f[](),
\f[B]pmemobj_rwlock_trywrlock\f[](), \f[B]pmemobj_rwlock_unlock\f[](),
.PP
\f[B]pmemobj_cond_zero\f[](), \f[B]pmemobj_cond_broadcast\f[](),
\f[B]pmemobj_cond_signal\f[](), \f[B]pmemobj_cond_timedwait\f[](),
\f[B]pmemobj_cond_wait\f[]() \- pmemobj synchronization primitives
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <libpmemobj.h>

void\ pmemobj_mutex_zero(PMEMobjpool\ *pop,\ PMEMmutex\ *mutexp);
int\ pmemobj_mutex_lock(PMEMobjpool\ *pop,\ PMEMmutex\ *mutexp);
int\ pmemobj_mutex_timedlock(PMEMobjpool\ *pop,\ PMEMmutex\ *restrict\ mutexp,
\ \ \ \ const\ struct\ timespec\ *restrict\ abs_timeout);
int\ pmemobj_mutex_trylock(PMEMobjpool\ *pop,\ PMEMmutex\ *mutexp);
int\ pmemobj_mutex_unlock(PMEMobjpool\ *pop,\ PMEMmutex\ *mutexp);

void\ pmemobj_rwlock_zero(PMEMobjpool\ *pop,\ PMEMrwlock\ *rwlockp);
int\ pmemobj_rwlock_rdlock(PMEMobjpool\ *pop,\ PMEMrwlock\ *rwlockp);
int\ pmemobj_rwlock_wrlock(PMEMobjpool\ *pop,\ PMEMrwlock\ *rwlockp);
int\ pmemobj_rwlock_timedrdlock(PMEMobjpool\ *pop,\ PMEMrwlock\ *restrict\ rwlockp,
\ \ \ \ const\ struct\ timespec\ *restrict\ abs_timeout);
int\ pmemobj_rwlock_timedwrlock(PMEMobjpool\ *pop,\ PMEMrwlock\ *restrict\ rwlockp,
\ \ \ \ const\ struct\ timespec\ *restrict\ abs_timeout);
int\ pmemobj_rwlock_tryrdlock(PMEMobjpool\ *pop,\ PMEMrwlock\ *rwlockp);
int\ pmemobj_rwlock_trywrlock(PMEMobjpool\ *pop,\ PMEMrwlock\ *rwlockp);
int\ pmemobj_rwlock_unlock(PMEMobjpool\ *pop,\ PMEMrwlock\ *rwlockp);

void\ pmemobj_cond_zero(PMEMobjpool\ *pop,\ PMEMcond\ *condp);
int\ pmemobj_cond_broadcast(PMEMobjpool\ *pop,\ PMEMcond\ *condp);
int\ pmemobj_cond_signal(PMEMobjpool\ *pop,\ PMEMcond\ *condp);
int\ pmemobj_cond_timedwait(PMEMobjpool\ *pop,\ PMEMcond\ *restrict\ condp,
\ \ \ \ PMEMmutex\ *restrict\ mutexp,\ const\ struct\ timespec\ *restrict\ abs_timeout);
int\ pmemobj_cond_wait(PMEMobjpool\ *pop,\ PMEMcond\ *restrict\ condp,
\ \ \ \ PMEMmutex\ *restrict\ mutexp);
\f[]
.fi
.SH DESCRIPTION
.PP
\f[B]libpmemobj\f[](7) provides several types of synchronization
primitives designed to be used with persistent memory.
The pmem\-aware lock implementation is based on the standard POSIX
Threads Library, as described in \f[B]pthread_mutex_init\f[](3),
\f[B]pthread_rwlock_init\f[](3) and \f[B]pthread_cond_init\f[](3).
Pmem\-aware locks provide semantics similar to standard \f[B]pthread\f[]
locks, except that they are embedded in pmem\-resident objects and are
considered initialized by zeroing them.
Therefore, locks allocated with \f[B]pmemobj_zalloc\f[](3) or
\f[B]pmemobj_tx_zalloc\f[](3) do not require another initialization
step.
For performance reasons, they are also padded up to 64 bytes (cache line
size).
.PP
On FreeBSD, since all \f[B]pthread\f[] locks are dynamically allocated,
while the lock object is still padded up to 64 bytes for consistency
with Linux, only the pointer to the lock is embedded in the
pmem\-resident object.
\f[B]libpmemobj\f[](7) transparently manages freeing of the locks when
the pool is closed.
.PP
The fundamental property of pmem\-aware locks is their automatic
reinitialization every time the persistent object store pool is opened.
Thus, all the pmem\-aware locks may be considered initialized (unlocked)
immediately after the pool is opened, regardless of their state at the
time the pool was closed for the last time.
.PP
Pmem\-aware mutexes, read/write locks and condition variables must be
declared with the \f[I]PMEMmutex\f[], \f[I]PMEMrwlock\f[], or
\f[I]PMEMcond\f[] type, respectively.
.PP
The \f[B]pmemobj_mutex_zero\f[]() function explicitly initializes the
pmem\-aware mutex \f[I]mutexp\f[] by zeroing it.
Initialization is not necessary if the object containing the mutex has
been allocated using \f[B]pmemobj_zalloc\f[](3) or
\f[B]pmemobj_tx_zalloc\f[](3).
.PP
The \f[B]pmemobj_mutex_lock\f[]() function locks the pmem\-aware mutex
\f[I]mutexp\f[].
If the mutex is already locked, the calling thread will block until the
mutex becomes available.
If this is the first use of the mutex since the opening of the pool
\f[I]pop\f[], the mutex is automatically reinitialized and then locked.
.PP
\f[B]pmemobj_mutex_timedlock\f[]() performs the same action as
\f[B]pmemobj_mutex_lock\f[](), but will not wait beyond
\f[I]abs_timeout\f[] to obtain the lock before returning.
.PP
The \f[B]pmemobj_mutex_trylock\f[]() function locks pmem\-aware mutex
\f[I]mutexp\f[].
If the mutex is already locked, \f[B]pthread_mutex_trylock\f[]() will
not block waiting for the mutex, but will return an error.
If this is the first use of the mutex since the opening of the pool
\f[I]pop\f[], the mutex is automatically reinitialized and then locked.
.PP
The \f[B]pmemobj_mutex_unlock\f[]() function unlocks the pmem\-aware
mutex \f[I]mutexp\f[].
Undefined behavior follows if a thread tries to unlock a mutex that has
not been locked by it, or if a thread tries to release a mutex that is
already unlocked or has not been initialized.
.PP
The \f[B]pmemobj_rwlock_zero\f[]() function is used to explicitly
initialize the pmem\-aware read/write lock \f[I]rwlockp\f[] by zeroing
it.
Initialization is not necessary if the object containing the lock has
been allocated using \f[B]pmemobj_zalloc\f[](3) or
\f[B]pmemobj_tx_zalloc\f[](3).
.PP
The \f[B]pmemobj_rwlock_rdlock\f[]() function acquires a read lock on
\f[I]rwlockp\f[], provided that the lock is not presently held for
writing and no writer threads are presently blocked on the lock.
If the read lock cannot be acquired immediately, the calling thread
blocks until it can acquire the lock.
If this is the first use of the lock since the opening of the pool
\f[I]pop\f[], the lock is automatically reinitialized and then acquired.
.PP
\f[B]pmemobj_rwlock_timedrdlock\f[]() performs the same action as
\f[B]pmemobj_rwlock_rdlock\f[](), but will not wait beyond
\f[I]abs_timeout\f[] to obtain the lock before returning.
A thread may hold multiple concurrent read locks.
If so, \f[B]pmemobj_rwlock_unlock\f[]() must be called once for each
lock obtained.
The results of acquiring a read lock while the calling thread holds a
write lock are undefined.
.PP
The \f[B]pmemobj_rwlock_wrlock\f[]() function blocks until a write lock
can be acquired against read/write lock \f[I]rwlockp\f[].
If this is the first use of the lock since the opening of the pool
\f[I]pop\f[], the lock is automatically reinitialized and then acquired.
.PP
\f[B]pmemobj_rwlock_timedwrlock\f[]() performs the same action, but will
not wait beyond \f[I]abs_timeout\f[] to obtain the lock before
returning.
.PP
The \f[B]pmemobj_rwlock_tryrdlock\f[]() function performs the same
action as \f[B]pmemobj_rwlock_rdlock\f[](), but does not block if the
lock cannot be immediately obtained.
The results are undefined if the calling thread already holds the lock
at the time the call is made.
.PP
The \f[B]pmemobj_rwlock_trywrlock\f[]() function performs the same
action as \f[B]pmemobj_rwlock_wrlock\f[](), but does not block if the
lock cannot be immediately obtained.
The results are undefined if the calling thread already holds the lock
at the time the call is made.
.PP
The \f[B]pmemobj_rwlock_unlock\f[]() function is used to release the
read/write lock previously obtained by \f[B]pmemobj_rwlock_rdlock\f[](),
\f[B]pmemobj_rwlock_wrlock\f[](), \f[B]pthread_rwlock_tryrdlock\f[](),
or \f[B]pmemobj_rwlock_trywrlock\f[]().
.PP
The \f[B]pmemobj_cond_zero\f[]() function explicitly initializes the
pmem\-aware condition variable \f[I]condp\f[] by zeroing it.
Initialization is not necessary if the object containing the condition
variable has been allocated using \f[B]pmemobj_zalloc\f[](3) or
\f[B]pmemobj_tx_zalloc\f[](3).
.PP
The difference between \f[B]pmemobj_cond_broadcast\f[]() and
\f[B]pmemobj_cond_signal\f[]() is that the former unblocks all threads
waiting for the condition variable, whereas the latter blocks only one
waiting thread.
If no threads are waiting on \f[I]condp\f[], neither function has any
effect.
If more than one thread is blocked on a condition variable, the used
scheduling policy determines the order in which threads are unblocked.
The same mutex used for waiting must be held while calling either
function.
Although neither function strictly enforces this requirement, undefined
behavior may follow if the mutex is not held.
.PP
The \f[B]pmemobj_cond_timedwait\f[]() and \f[B]pmemobj_cond_wait\f[]()
functions block on a condition variable.
They must be called with mutex \f[I]mutexp\f[] locked by the calling
thread, or undefined behavior results.
These functions atomically release mutex \f[I]mutexp\f[] and cause the
calling thread to block on the condition variable \f[I]condp\f[];
atomically here means \[lq]atomically with respect to access by another
thread to the mutex and then the condition variable\[rq].
That is, if another thread is able to acquire the mutex after the
about\-to\-block thread has released it, then a subsequent call to
\f[B]pmemobj_cond_broadcast\f[]() or \f[B]pmemobj_cond_signal\f[]() in
that thread will behave as if it were issued after the about\-to\-block
thread has blocked.
Upon successful return, the mutex will be locked and owned by the
calling thread.
.SH RETURN VALUE
.PP
The \f[B]pmemobj_mutex_zero\f[](), \f[B]pmemobj_rwlock_zero\f[]() and
\f[B]pmemobj_cond_zero\f[]() functions return no value.
.PP
Other locking functions return 0 on success.
Otherwise, an error number will be returned to indicate the error.
.SH SEE ALSO
.PP
\f[B]pmemobj_tx_zalloc\f[](3), \f[B]pmemobj_zalloc\f[](3),
\f[B]pthread_cond_init\f[](3), \f[B]pthread_mutex_init\f[](3),
\f[B]pthread_rwlock_init\f[](3), \f[B]libpmem\f[](7),
\f[B]libpmemobj\f[](7) and \f[B]<http://pmem.io>\f[]
