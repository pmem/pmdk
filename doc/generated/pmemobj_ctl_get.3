.\" Automatically generated by Pandoc 1.16.0.2
.\"
.TH "PMEMOBJ_CTL_GET" "3" "2017-11-09" "NVM Library - pmemobj API version 2.2" "NVML Programmer's Manual"
.hy
.\" Copyright 2014-2017, Intel Corporation
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"
.\"     * Redistributions of source code must retain the above copyright
.\"       notice, this list of conditions and the following disclaimer.
.\"
.\"     * Redistributions in binary form must reproduce the above copyright
.\"       notice, this list of conditions and the following disclaimer in
.\"       the documentation and/or other materials provided with the
.\"       distribution.
.\"
.\"     * Neither the name of the copyright holder nor the names of its
.\"       contributors may be used to endorse or promote products derived
.\"       from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
.\" "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
.\" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
.\" A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
.\" OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
.\" SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
.\" LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
.\" OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.SH NAME
.PP
\f[B]pmemobj_ctl_get\f[](), \f[B]pmemobj_ctl_set\f[]() \-\- allows to
control the internal behavior of libpmemobj
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <libpmemobj.h>

int\ pmemobj_ctl_get(PMEMobjpool\ *pop,\ const\ char\ *name,\ void\ *arg);\ (EXPERIMENTAL)
int\ pmemobj_ctl_set(PMEMobjpool\ *pop,\ const\ char\ *name,\ void\ *arg);\ (EXPERIMENTAL)
\f[]
.fi
.SH DESCRIPTION
.PP
The library provides a uniform interface that allows to impact its
behavior as well as reason about its internals.
.PP
The \f[I]name\f[] argument specifies an entry point as defined in the
CTL namespace specification.
The entry point description specifies whether the extra \f[I]arg\f[] is
required.
Those two parameters together create a CTL query.
The \f[I]pop\f[] argument is optional if the entry point resides in a
global namespace (i.e.
shared for all the pools).
The functions themselves are thread\-safe and most of the entry points
are too.
If there are special conditions in which an entry point has to be
called, they are explicitly stated in its description.
The functions propagate the return value of the entry point.
If either the name or the provided arguments are invalid, \-1 is
returned.
.PP
Entry points are leafs of a tree\-like structure.
Each one can read from the internal state, write to the internal state
or do both.
.PP
The CTL namespace is organized in a tree structure.
Starting from the root, each node can be either internal, containing
other elements, or a leaf.
Internal nodes themselves can only contain other nodes and cannot be
entry points.
There are two types of those nodes: named and indexed.
Named nodes have string identifiers.
Indexed nodes represent an abstract array index and have an associated
string identifier.
The index itself is user provided.
A collection of indexes present on the path of an entry point is
provided to the handler functions as name and index pairs.
.PP
The entry points are listed in the following format:
.PP
name | r(ead)w(rite) | global/\- | read argument type | write argument
type | config argument type
.PP
description...
.SH CTL NAMESPACE
.PP
prefault.at_create | rw | global | int | int | boolean
.PP
If set, every single page of the pool will be touched and written to, in
order to trigger page allocation.
This can be used to minimize performance impact of pagefaults.
Affects only the \f[B]pmemobj_create\f[]() function.
.PP
Always returns 0.
.PP
prefault.at_open | rw | global | int | int | boolean
.PP
As above, but affects \f[B]pmemobj_open\f[]() function.
.PP
tx.debug.skip_expensive_checks | rw | \- | int | int | boolean
.PP
Turns off some expensive checks performed by transaction module in
"debug" builds.
Ignored in "release" builds.
.PP
tx.cache.size | rw | \- | long long | long long | integer
.PP
Size in bytes of the transaction snapshot cache size.
The bigger it is the frequency of persistent allocations is lower, but
at the cost of higher fixed cost.
.PP
This should be set to roughly the sum of sizes of the snapshotted
regions in an average transaction in the pool.
.PP
This value must be a in a range between 0 and
\f[B]PMEMOBJ_MAX_ALLOC_SIZE\f[].
If the current threshold is larger than the new cache size, the
threshold will be made equal to the new size.
.PP
This entry point is not thread safe and should not be modified if there
are any transactions currently running.
.PP
Returns 0 if successful, \-1 otherwise.
.PP
tx.cache.threshold | rw | \- | long long | long long | integer
.PP
Threshold in bytes to which the snapshots will use the cache.
All bigger snapshots will trigger a persistent allocation.
.PP
This value must be a in a range between 0 and \f[B]tx.cache.size\f[].
.PP
This entry point is not thread safe and should not be modified if there
are any transactions currently running.
.PP
Returns 0 if successful, \-1 otherwise.
.PP
tx.post_commit.queue_depth | rw | \- | int | int | integer
.PP
Controls the depth of the post\-commit tasks queue.
A post\-commit task is the collection of work items that need to be
performed on the persistent state after a successfully completed
transaction.
This includes freeing no longer needed objects and cleaning up various
caches.
By default, this queue does not exist and the post\-commit task is
executed synchronously in the same thread that ran the transaction.
By changing this parameter, one can offload this task to a separate
worker.
If the queue is full, the algorithm, instead of waiting, performs the
post\-commit in the current thread.
.PP
The task is performed on a finite resource (lanes, of which there are
1024), and if the worker threads that process this queue don\[aq]t keep
up with the demand, regular threads might start to block waiting for
that resource.
This will happen if the queue depth value is too large.
.PP
As a general rule, this value should be set to around: 1024 minus the
average number of threads in the application (not counting the
post\-commit workers).
But this may vary from workload to workload.
.PP
The queue depth value must also be a power of two.
.PP
This entry point is not thread\-safe and must be called when no
transactions are currently being executed.
.PP
Returns 0 if successful, \-1 otherwise.
.PP
tx.post_commit.worker | r\- | \- | void * | \- | \-
.PP
The worker function that one needs to launch in a thread to perform
asynchronous processing of post\-commit tasks.
It returns only after a stop entry point is called.
There might be many worker threads at a time.
If there\[aq]s no work to be done, this function sleeps instead of
polling.
.PP
Always returns 0.
.PP
tx.post_commit.stop | r\- | \- | void * | \- | \-
.PP
This function forces all the post\-commit worker functions to exit and
return control back to the calling thread.
This should be called before the application terminates and the post
commit worker threads needs to be shutdown.
.PP
After the invocation of this entry point, the post\-commit task queue
can no longer be used.
If there\[aq]s a need to restart the worker threads after a stop, the
tx.post_commit.queue_depth needs to be set again.
.PP
This entry point must be called when no transactions are currently being
executed.
.PP
Always returns 0.
.PP
heap.alloc_class.[class_id].desc | rw | \- |
\f[C]struct\ pobj_alloc_class_desc\f[] |
\f[C]struct\ pobj_alloc_class_desc\f[] | integer, integer, string
.PP
A description of an allocation class.
Allows one to create or view the internal data structures of the
allocator.
.PP
Creating custom allocation classes can be beneficial for both raw
allocation throughput, scalability and, most importantly, fragmentation.
By carefully constructing allocation classes that match the application
workload, one can entirely eliminate external and internal
fragmentation.
For example, it is possible to easily construct a slab\-like allocation
mechanism for any data structure.
.PP
The \f[C][class_id]\f[] is an index field.
Only values between 0\-254 are valid.
If setting an allocation class, but the \f[C]class_id\f[] is already
taken, the function will return \-1.
The values between 0\-127 are reserved for the default allocation
classes of the library and can be used only for reading.
.PP
If one wants to retrieve information about all allocation classes, the
recommended method is to simply call this entry point for all class ids
between 0 and 254 and discard those results for which the function
returned an error.
.PP
This entry point takes a complex argument.
.IP
.nf
\f[C]
struct\ pobj_alloc_class_desc\ {
\ \ \ \ size_t\ unit_size;
\ \ \ \ unsigned\ units_per_block;
\ \ \ \ enum\ pobj_header_type\ header_type;
\ \ \ \ unsigned\ class_id;
};
\f[]
.fi
.PP
The first field \f[C]unit_size\f[], is an 8\-byte unsigned integer that
defines the allocation class size.
While theoretically limited only by \f[B]PMEMOBJ_MAX_ALLOC_SIZE\f[],
this value should be between 8 bytes and a couple of megabytes for most
of the workloads.
.PP
The field \f[C]units_per_block\f[] defines how many units does a single
block of memory contains.
This value will be rounded up to match internal size of the block (256
kilobytes or a multiple thereof).
For example, given a class with \f[C]unit_size\f[] of 512 bytes and
\f[C]units_per_block\f[] equal 1000, a single block of memory for that
class will have 512 kilobytes.
This is relevant because the bigger the block size, the blocks need to
be fetched less frequently which leads to a lower contention on global
state of the heap.
Keep in mind that the information whether an object is allocated or not
is stored in a bitmap with limited number of entries, this makes it
inefficient to create allocation classes smaller than 128 bytes.
.PP
The field \f[C]header_type\f[] defines the header of objects from the
allocation class.
There are three types:
.IP \[bu] 2
\f[B]POBJ_HEADER_LEGACY\f[], string value: \f[C]legacy\f[].
Used for allocation classes prior to 1.3 version of the library.
Not recommended for use.
Incurs 64 byte metadata overhead for every object.
Fully supports all features.
.IP \[bu] 2
\f[B]POBJ_HEADER_COMPACT\f[], string value: \f[C]compact\f[].
Used as default for all predefined allocation classes.
Incurs 16 bytes metadata overhead for every object.
Fully supports all features.
.IP \[bu] 2
\f[B]POBJ_HEADER_NONE\f[], string value: \f[C]none\f[].
Header type that doesn\[aq]t incur any metadata overhead beyond a single
bitmap entry.
Can be used for very small allocation classes or when objects must be
adjacent to each other.
This header type does not support type numbers (it\[aq]s always 0) and
allocations that span more than one unit.
.PP
The field \f[C]class_id\f[] is optional, runtime only (can\[aq]t be set
from config file), variable that allows the user to retrieve the
identifier of the class.
This will be equivalent to the provided \f[C][class_id]\f[].
.PP
The allocation classes are a runtime state of the library and must be
created after every open.
It\[aq]s highly recommended to use the configuration file to store the
classes.
.PP
This structure is declared in the \f[C]libpmemobj/ctl.h\f[] header file,
please read it for an in\-depth explanation of the allocation classes
and relevant algorithms.
.PP
Allocation classes constructed in this way can be leveraged by
explicitly specifying the class using \f[B]POBJ_CLASS_ID(id)\f[] flag in
\f[B]pmemobj_tx_xalloc\f[]()/\f[B]pmemobj_xalloc\f[]() functions.
.PP
Example of a valid alloc class query string:
.IP
.nf
\f[C]
heap.alloc_class.128.desc=500,1000,compact
\f[]
.fi
.PP
This query, if executed, will create an allocation class with an id of
128 that has a unit size of 500 bytes, has at least 1000 units per block
and uses a compact header.
.PP
For reading, function returns 0 if successful, if the allocation class
does not exist it sets the errno to \f[B]ENOENT\f[] and returns \-1;
.PP
For writing, function returns 0 if the allocation class has been
successfully created, \-1 otherwise.
.PP
heap.alloc_class.new.desc | wo | \- | \- |
\f[C]struct\ pobj_alloc_class_desc\f[] | integer, integer, string
.PP
Same as \f[C]heap.alloc_class.[class_id].desc\f[], but instead of
requiring the user to provide the class_id, it automatically creates the
allocation class with the first available identifier.
.PP
This should be used when it\[aq]s impossible to guarantee unique
allocation class naming in the application (e.g.
when writing a library that uses libpmemobj).
.PP
The required class identifier will be stored in the \f[C]class_id\f[]
field of the \f[C]struct\ pobj_alloc_class_desc\f[].
.PP
This function returns 0 if the allocation class has been successfully
created, \-1 otherwise.
.SH CTL EXTERNAL CONFIGURATION
.PP
In addition to direct function call, each write entry point can also be
set using two alternative methods.
.PP
The first one is to load configuration directly from a
\f[B]PMEMOBJ_CONF\f[] environment variable.
Properly formatted ctl config string is a single\-line sequence of
queries separated by \[aq];\[aq]:
.IP
.nf
\f[C]
query0;query1;...;queryN
\f[]
.fi
.PP
A single query is constructed from the name of the ctl write entry point
and the argument, separated by \[aq]=\[aq]:
.IP
.nf
\f[C]
entry_point=entry_point_argument
\f[]
.fi
.PP
The entry point argument type is defined by the entry point itself, but
there are few predefined primitives:
.IP
.nf
\f[C]
*)\ integer:\ represented\ by\ a\ sequence\ of\ [0\-9]\ characters\ that\ form
\ \ \ \ a\ single\ number.
*)\ boolean:\ represented\ by\ a\ single\ character:\ y/n/Y/N/0/1,\ each
\ \ \ \ corresponds\ to\ true\ or\ false.\ If\ the\ argument\ contains\ any
\ \ \ \ trailing\ characters,\ they\ are\ ignored.
*)\ string:\ a\ simple\ sequence\ of\ characters.
\f[]
.fi
.PP
There are also complex argument types that are formed from the
primitives separated by a \[aq],\[aq]:
.IP
.nf
\f[C]
first_arg,second_arg
\f[]
.fi
.PP
In summary, a full configuration sequence looks like this:
.IP
.nf
\f[C]
(first_entry_point)=(arguments,\ ...);...;(last_entry_point)=(arguments,\ ...);
\f[]
.fi
.PP
As an example, to set both prefault at_open and at_create variables:
.IP
.nf
\f[C]

PMEMOBJ_CONF="prefault.at_open=1;prefault.at_create=1"
\f[]
.fi
.PP
The second method of loading an external configuration is to set the
\f[B]PMEMOBJ_CONF_FILE\f[] environment variable to point to a file that
contains a sequence of ctl queries.
The parsing rules are all the same, but the file can also contain
white\-spaces and comments.
.PP
To create a comment, simply use \[aq]#\[aq] anywhere in a line and
everything afterwards, until a new line \[aq]\[aq], will be ignored.
.PP
An example configuration file:
.IP
.nf
\f[C]
#########################
#\ My\ pmemobj\ configuration
#########################
#
#\ Global\ settings:
prefault.\ #\ modify\ the\ behavior\ of\ pre\-faulting
\ \ \ \ at_open\ =\ 1;\ #\ prefault\ when\ the\ pool\ is\ opened

prefault.
\ \ \ \ at_create\ =\ 0;\ #\ but\ don\[aq]t\ prefault\ when\ it\[aq]s\ created

#\ Per\-pool\ settings:
#\ ...
\f[]
.fi
.SH SEE ALSO
.PP
\f[B]libpmemobj\f[](7) and \f[B]<http://pmem.io>\f[]
