.\" Automatically generated by Pandoc 1.16.0.2
.\"
.TH "PMEMOBJ_ALLOC" "3" "2017-10-16" "NVM Library - pmemobj API version 2.2" "NVML Programmer's Manual"
.hy
.\" Copyright 2014-2017, Intel Corporation
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"
.\"     * Redistributions of source code must retain the above copyright
.\"       notice, this list of conditions and the following disclaimer.
.\"
.\"     * Redistributions in binary form must reproduce the above copyright
.\"       notice, this list of conditions and the following disclaimer in
.\"       the documentation and/or other materials provided with the
.\"       distribution.
.\"
.\"     * Neither the name of the copyright holder nor the names of its
.\"       contributors may be used to endorse or promote products derived
.\"       from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
.\" "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
.\" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
.\" A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
.\" OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
.\" SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
.\" LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
.\" OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.SH NAME
.PP
\f[B]pmemobj_alloc\f[]() ,\f[B]pmemobj_zalloc\f[](),
\f[B]pmemobj_xalloc\f[](), \f[B]pmemobj_realloc\f[](),
\f[B]pmemobj_zrealloc\f[](), \f[B]pmemobj_strdup\f[](),
\f[B]pmemobj_wcsdup\f[](), \f[B]pmemobj_alloc_usable_size\f[](),
\f[B]POBJ_NEW\f[](), \f[B]POBJ_ALLOC\f[](), \f[B]POBJ_ZNEW\f[](),
\f[B]POBJ_ZALLOC\f[](), \f[B]POBJ_REALLOC\f[](),
\f[B]POBJ_ZREALLOC\f[](), \f[B]POBJ_FREE\f[]() \-\- non\-transactional
atomic allocations
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <libpmemobj.h>

typedef\ int\ (*pmemobj_constr)(**PMEMobjpool\ *pop,\ void\ *ptr,\ void\ *arg);
int\ pmemobj_alloc(PMEMobjpool\ *pop,\ PMEMoid\ *oidp,
\ \ \ \ size_t\ size,\ uint64_t\ type_num,
\ \ \ \ pmemobj_constr\ constructor\ ,\ void\ *arg);
int\ pmemobj_zalloc(PMEMobjpool\ *pop,\ PMEMoid\ *oidp,\ size_t\ size,\ uint64_t\ type_num);
int\ pmemobj_xalloc(PMEMobjpool\ *pop,\ PMEMoid\ *oidp,\ size_t\ size,
\ \ \ \ uint64_t\ type_num,\ uint64_t\ flags,\ pmemobj_constr\ constructor\ ,\ void\ *arg);
void\ pmemobj_free(PMEMoid\ *oidp);
int\ pmemobj_realloc(PMEMobjpool\ *pop,\ PMEMoid\ *oidp,\ size_t\ size,\ uint64_t\ type_num);
int\ pmemobj_zrealloc(PMEMobjpool\ *pop,\ PMEMoid\ *oidp,\ size_t\ size,\ uint64_t\ type_num);
int\ pmemobj_strdup(PMEMobjpool\ *pop,\ PMEMoid\ *oidp,\ const\ char\ *s,\ uint64_t\ type_num);
int\ pmemobj_wcsdup(PMEMobjpool\ *pop,\ PMEMoid\ *oidp,\ const\ wchar_t\ *s,\ uint64_t\ type_num);
size_t\ pmemobj_alloc_usable_size(PMEMoid\ oid);

POBJ_NEW(PMEMobjpool\ *pop,\ TOID\ *oidp,\ TYPE,\ pmemobj_constr\ constructor,\ void\ *arg)
POBJ_ALLOC(PMEMobjpool\ *pop,\ TOID\ *oidp,\ TYPE,\ size_t\ size,
\ \ \ \ pmemobj_constr\ constructor\ ,\ void\ *arg)
POBJ_ZNEW(PMEMobjpool\ *pop,\ TOID\ *oidp,\ TYPE)
POBJ_ZALLOC(PMEMobjpool\ *pop,\ TOID\ *oidp,\ TYPE,\ size_t\ size)
POBJ_REALLOC(PMEMobjpool\ *pop,\ TOID\ *oidp,\ TYPE,\ size_t\ size)
POBJ_ZREALLOC(PMEMobjpool\ *pop,\ TOID\ *oidp,\ TYPE,\ size_t\ size)
POBJ_FREE(TOID\ *oidp)
\f[]
.fi
.SH DESCRIPTION
.PP
Functions described in this section provide the mechanism to allocate,
resize and free objects from the persistent memory pool in a
thread\-safe and fail\-safe manner.
All the routines are atomic with respect to other threads and any
power\-fail interruptions.
If any of those operations is torn by program failure or system crash;
on recovery they are guaranteed to be entirely completed or discarded,
leaving the persistent memory heap and internal object containers in a
consistent state.
.PP
All these functions can be used outside transactions.
Note that operations performed using non\-transactional API are
considered durable after completion, even if executed within the open
transaction.
Such non\-transactional changes will not be rolled\-back if the
transaction is aborted or interrupted.
.PP
The allocations are always aligned to the cache\-line boundary.
.PP
The \f[I]pmemobj_constr\f[] type represents a constructor for atomic
allocation from persistent memory heap associated with memory pool
\f[I]pop\f[].
The \f[I]ptr\f[] is a pointer to allocating memory area and the
\f[I]arg\f[] is an user\-defined argument passed to an appropriate
function.
.PP
The \f[B]pmemobj_alloc\f[]() function allocates a new object from the
persistent memory heap associated with memory pool \f[I]pop\f[].
The \f[I]PMEMoid\f[] of allocated object is stored in \f[I]oidp\f[].
If NULL is passed as \f[I]oidp\f[], then the newly allocated object may
be accessed only by iterating objects in the object container associated
with given \f[I]type_num\f[], as described in \f[B]POBJ_FOREACH\f[](3)
man page.
If the \f[I]oidp\f[] points to memory location from the \f[B]pmemobj\f[]
heap the \f[I]oidp\f[] is modified atomically.
Before returning, it calls the \f[I]constructor\f[] function passing the
pool handle \f[I]pop\f[], the pointer to the newly allocated object in
\f[I]ptr\f[] along with the \f[I]arg\f[] argument.
It is guaranteed that allocated object is either properly initialized,
or if the allocation is interrupted before the constructor completes,
the memory space reserved for the object is reclaimed.
The \f[I]size\f[] can be any non\-zero value, however due to internal
padding and object metadata, the actual size of the allocation will
differ from the requested one by at least 64 bytes.
For this reason, making the allocations of a size less than 64 bytes is
extremely inefficient and discouraged.
.PP
The \f[B]pmemobj_zalloc\f[]() function allocates a new zeroed object
from the persistent memory heap associated with memory pool
\f[I]pop\f[].
The \f[I]PMEMoid\f[] of allocated object is stored in \f[I]oidp\f[].
If NULL is passed as \f[I]oidp\f[], then the newly allocated object may
be accessed only by iterating objects in the object container associated
with given \f[I]type_num\f[], as described in \f[B]POBJ_FOREACH\f[](3)
man page.
If the \f[I]oidp\f[] points to memory location from the \f[B]pmemobj\f[]
heap the \f[I]oidp\f[] is modified atomically.
The \f[I]size\f[] can be any non\-zero value, however due to internal
padding and object metadata, the actual size of the allocation will
differ from the requested one by at least 64 bytes.
For this reason, making the allocations of a size less than 64 bytes is
extremely inefficient and discouraged.
.PP
The \f[B]pmemobj_xalloc\f[]() function allocates a new object from the
persistent memory heap associated with memory pool \f[I]pop\f[].
Equivalent to \f[B]pmemobj_alloc\f[]() but with the addition of
allocation modifiers.
The \f[I]flags\f[] argument is a bitmask of the following values:
.IP \[bu] 2
\f[B]POBJ_XALLOC_ZERO\f[] \- zero the object (equivalent of
\f[B]pmemobj_zalloc\f[]())
.IP \[bu] 2
\f[B]POBJ_CLASS_ID(class_id)\f[] \- allocate the object from the
allocation class with id equal to \f[I]class_id\f[]
.PP
The \f[B]pmemobj_free\f[]() function provides the same semantics as
\f[B]free\f[](3), but instead of the process heap supplied by the
system, it operates on the persistent memory heap.
It frees the memory space represented by \f[I]oidp\f[], which must have
been returned by a previous call to \f[B]pmemobj_alloc\f[](),
\f[B]pmemobj_zalloc\f[](), \f[B]pmemobj_realloc\f[](), or
\f[B]pmemobj_zrealloc\f[]().
If \f[I]oidp\f[] is NULL or if it points to the root object\[aq]s
\f[I]OID\f[], behavior of the function is undefined.
If it points to \f[B]OID_NULL\f[], no operation is performed.
It sets the \f[I]oidp\f[] to \f[B]OID_NULL\f[] value after freeing the
memory.
If the \f[I]oidp\f[] points to memory location from the \f[B]pmemobj\f[]
heap the \f[I]oidp\f[] is changed atomically.
.PP
The \f[B]pmemobj_realloc\f[]() function provide similar semantics to
\f[B]realloc\f[](3), but operates on the persistent memory heap
associated with memory pool \f[I]pop\f[].
It changes the size of the object represented by \f[I]oidp\f[], to
\f[I]size\f[] bytes.
The resized object is also added or moved to the internal container
associated with given \f[I]type_num\f[].
The contents will be unchanged in the range from the start of the region
up to the minimum of the old and new sizes.
If the new size is larger than the old size, the added memory will
\f[I]not\f[] be initialized.
If \f[I]oidp\f[] is NULL or if it points to the root object\[aq]s
\f[I]OID\f[], behavior of the function is undefined.
If it points to \f[I]OID_NULL\f[], then the call is equivalent to
\f[I]pmemobj_alloc(pop, size, type_num)\f[].
If \f[I]size\f[] is equal to zero, and \f[I]oidp\f[] is not
\f[B]OID_NULL\f[], then the call is equivalent to
\f[I]pmemobj_free(oid)\f[].
Unless \f[I]oidp\f[] is \f[B]OID_NULL\f[], it must have been returned by
an earlier call to \f[B]pmemobj_alloc\f[](), \f[B]pmemobj_zalloc\f[](),
\f[B]pmemobj_realloc\f[](), or \f[B]pmemobj_zrealloc\f[]().
Note that the object handle value may change in result of reallocation.
If the object was moved, a memory space represented by \f[I]oid\f[] is
reclaimed.
If \f[I]oidp\f[] points to memory location from the \f[B]pmemobj\f[]
heap the \f[I]oidp\f[] is changed atomically.
If \f[B]pmemobj_realloc\f[]() is unable to satisfy the allocation
request, a non\-zero value is returned and \f[I]errno\f[] is set
appropriately.
.PP
The \f[B]pmemobj_zrealloc\f[]() function provide similar semantics to
\f[B]realloc\f[](3), but operates on the persistent memory heap
associated with memory pool \f[I]pop\f[].
It changes the size of the object represented by \f[I]oid\f[], to
\f[I]size\f[] bytes.
The resized object is also added or moved to the internal container
associated with given \f[I]type_num\f[].
The contents will be unchanged in the range from the start of the region
up to the minimum of the old and new sizes.
If the new size is larger than the old size, the added memory will be
zeroed.
If \f[I]oidp\f[] is NULL or if it points to the root object\[aq]s
\f[I]OID\f[], behavior of the function is undefined.
If it points to \f[B]OID_NULL\f[], then the call is equivalent to
\f[I]pmemobj_zalloc(pop, size, type_num)\f[].
If \f[I]size\f[] is equal to zero, and \f[I]oidp\f[] doesn\[aq]t point
to \f[B]OID_NULL\f[], then the call is equivalent to
\f[I]pmemobj_free(pop, oid)\f[].
Unless \f[I]oidp\f[] points to \f[B]OID_NULL\f[], it must have been
returned by an earlier call to \f[B]pmemobj_alloc\f[](),
\f[B]pmemobj_zalloc\f[](), \f[B]pmemobj_realloc\f[](), or
\f[B]pmemobj_zrealloc\f[]().
Note that the object handle valu may change in result of reallocation.
If the object was moved, a memory space represented by \f[I]oidp\f[] is
reclaimed.
If \f[I]oidp\f[] points to memory location from the \f[B]pmemobj\f[]
heap the \f[I]oidp\f[] is changed atomically.
.PP
The \f[B]pmemobj_strdup\f[]() function provides the same semantics as
\f[B]strdup\f[](3), but operates on the persistent memory heap
associated with memory pool \f[I]pop\f[].
It stores a handle to a new object in \f[I]oidp\f[] which is a duplicate
of the string \f[I]s\f[].
If NULL is passed as \f[I]oidp\f[], then the newly allocated object may
be accessed only by iterating objects in the object container associated
with given \f[I]type_num\f[], as described in \f[B]OBJECT CONTAINERS\f[]
section.
If the \f[I]oidp\f[] points to memory location from the \f[B]pmemobj\f[]
heap the \f[I]oidp\f[] is changed atomically.
The allocated string object is also added to the internal container
associated with given \f[I]type_num\f[].
Memory for the new string is obtained with \f[B]pmemobj_alloc\f[](), on
the given memory pool, and can be freed with \f[B]pmemobj_free\f[]() on
the same memory pool.
.PP
The \f[B]pmemobj_wcsdup\f[]() function provides the same semantics as
\f[B]wcsdup\f[](3), but operates on the persistent memory heap
associated with memory pool \f[I]pop\f[].
It stores a handle to a new object in \f[I]oidp\f[] which is a duplicate
of the wide character string \f[I]s\f[].
If NULL is passed as \f[I]oidp\f[], then the newly allocated object may
be accessed only by iterating objects in the object container associated
with given \f[I]type_num\f[], as described in \f[B]OBJECT CONTAINERS\f[]
section.
If the \f[I]oidp\f[] points to memory location from the \f[B]pmemobj\f[]
heap the \f[I]oidp\f[] is changed atomically.
The allocated wide character string object is also added to the internal
container associated with given \f[I]type_num\f[].
Memory for the new wide character string is obtained with
\f[B]pmemobj_alloc\f[](), on the given memory pool, and can be freed
with \f[B]pmemobj_free\f[]() on the same memory pool.
If \f[B]pmemobj_wcsdup\f[]() is unable to satisfy the allocation
request, a non\-zero value is returned and \f[I]errno\f[] is set
appropriately.
.PP
The \f[B]pmemobj_alloc_usable_size\f[]() function provides the same
semantics as \f[B]malloc_usable_size\f[](3), but instead of the process
heap supplied by the system, it operates on the persistent memory heap.
.PP
The \f[B]POBJ_NEW\f[]() macro is a wrapper around the
\f[B]pmemobj_alloc\f[]() function which takes the type name
\f[I]TYPE\f[] and passes the size and type number to the
\f[B]pmemobj_alloc\f[]() function from the typed \f[I]OID\f[].
Instead of taking a pointer to \f[I]PMEMoid\f[] it takes a pointer to
typed \f[I]OID\f[] of \f[I]TYPE\f[].
.PP
The \f[B]POBJ_ALLOC\f[]() macro is a wrapper around the
\f[B]pmemobj_alloc\f[]() function which takes the type name
\f[I]TYPE\f[] the size of allocation \f[I]size\f[] and passes the type
number to the \f[B]pmemobj_alloc\f[]() function from the typed
\f[I]OID\f[].
Instead of taking a pointer to \f[I]PMEMoid\f[] it takes a pointer to
typed \f[I]OID\f[] of \f[I]TYPE\f[].
.PP
The \f[B]POBJ_ZNEW\f[]() macro is a wrapper around the
\f[B]pmemobj_zalloc\f[]() function which takes the type name
\f[I]TYPE\f[] and passes the size and type number to the
\f[B]pmemobj_zalloc\f[]() function from the typed \f[I]OID\f[].
Instead of taking a pointer to \f[I]PMEMoid\f[] it takes a pointer to
typed \f[I]OID\f[] of \f[I]TYPE\f[].
.PP
The \f[B]POBJ_ZALLOC\f[]() macro is a wrapper around the
\f[B]pmemobj_zalloc\f[]() function which takes the type name
\f[I]TYPE\f[], the size of allocation \f[I]size\f[] and passes the type
number to the \f[B]pmemobj_zalloc\f[]() function from the typed
\f[I]OID\f[].
Instead of taking a pointer to \f[I]PMEMoid\f[] it takes a pointer to
typed \f[I]OID\f[] of \f[I]TYPE\f[].
.PP
The \f[B]POBJ_REALLOC\f[]() macro is a wrapper around the
\f[B]pmemobj_realloc\f[]() function which takes the type name
\f[I]TYPE\f[] and passes the type number to the
\f[B]pmemobj_realloc\f[]() function from the typed \f[I]OID\f[].
Instead of taking a pointer to \f[I]PMEMoid\f[] it takes a pointer to
typed \f[I]OID\f[] of \f[I]TYPE\f[].
.PP
The \f[B]POBJ_ZREALLOC\f[]() macro is a wrapper around the
\f[B]pmemobj_zrealloc\f[]() function which takes the type name
\f[I]TYPE\f[] and passes the type number to the
\f[B]pmemobj_zrealloc\f[]() function from the typed \f[I]OID\f[].
Instead of taking a pointer to \f[I]PMEMoid\f[] it takes a pointer to
typed \f[I]OID\f[] of \f[I]TYPE\f[].
.PP
The \f[B]POBJ_FREE\f[]() macro is a wrapper around the
\f[B]pmemobj_free\f[]() function which takes pointer to typed
\f[I]OID\f[] as \f[I]oidp\f[] argument instead of \f[I]PMEMoid\f[].
.SH RETURN VALUE
.PP
In the \f[B]pmemobj_alloc\f[]() function, if the constructor returns
non\-zero value the allocation is canceled, the \-1 value is returned
from the caller and \f[I]errno\f[] is set to \f[B]ECANCELED\f[].
If \f[I]size\f[] equals 0, then \f[B]pmemobj_alloc\f[]() returns
non\-zero value, sets the \f[I]errno\f[] and leaves the \f[I]oidp\f[]
untouched.
The allocated object is added to the internal container associated with
given \f[I]type_num\f[].
.PP
The \f[B]pmemobj_zalloc\f[]() and \f[B]pmemobj_xalloc\f[]() function
returns non\-zero value if \f[I]size\f[] equals 0 and sets the
\f[I]errno\f[] and leaves the \f[I]oidp\f[] untouched.
The allocated object is added to the internal container associated with
given \f[I]type_num\f[].
.PP
The \f[B]pmemobj_free\f[]() function returns no value.
.PP
The \f[B]pmemobj_realloc\f[]() function on success returns 0, otherwise
returns \-1.
.PP
The \f[B]pmemobj_zrealloc\f[](), \f[B]pmemobj_strdup\f[]() and
\f[B]pmemobj_wcsdup\f[]() on success returns 0.
If function is unable to satisfy the allocation request, a non\-zero
value is returned and \f[I]errno\f[] is set appropriately.
.PP
The \f[B]pmemobj_alloc_usable_size\f[]() function returns the number of
usable bytes in the object represented by \f[I]oid\f[], a handle to an
object allocated by \f[B]pmemobj_alloc\f[]() or a related function.
If \f[I]oid\f[] is \f[B]OID_NULL\f[], 0 is returned.
.SH SEE ALSO
.PP
\f[B]free\f[](3), \f[B]POBJ_FOREACH\f[](3), \f[B]realloc\f[](3),
\f[B]strdup\f[](3), \f[B]wcsdup\f[](3), \f[B]libpmemobj\f[](7) and
\f[B]<http://pmem.io>\f[]
