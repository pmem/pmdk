.\" Automatically generated by Pandoc 1.16.0.2
.\"
.TH "PMEMOBJ_LIST_INSERT" "3" "2017-11-09" "NVM Library - pmemobj API version 2.2" "NVML Programmer's Manual"
.hy
.\" Copyright 2014-2017, Intel Corporation
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"
.\"     * Redistributions of source code must retain the above copyright
.\"       notice, this list of conditions and the following disclaimer.
.\"
.\"     * Redistributions in binary form must reproduce the above copyright
.\"       notice, this list of conditions and the following disclaimer in
.\"       the documentation and/or other materials provided with the
.\"       distribution.
.\"
.\"     * Neither the name of the copyright holder nor the names of its
.\"       contributors may be used to endorse or promote products derived
.\"       from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
.\" "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
.\" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
.\" A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
.\" OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
.\" SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
.\" LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
.\" OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.SH NAME
.PP
\f[B]pmemobj_list_insert\f[](), \f[B]pmemobj_list_insert_new\f[](),
\f[B]pmemobj_list_remove\f[](), \f[B]pmemobj_list_move\f[]() \-\-
non\-transactional persistent atomic lists functions
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <libpmemobj.h>

int\ pmemobj_list_insert(PMEMobjpool\ *pop,\ size_t\ pe_offset,\ void\ *head,
\ \ \ \ PMEMoid\ dest,\ int\ before,\ PMEMoid\ oid);

PMEMoid\ pmemobj_list_insert_new(PMEMobjpool\ *pop,\ size_t\ pe_offset,
\ \ \ \ void\ *head,\ PMEMoid\ dest,\ int\ before,\ size_t\ size,
\ \ \ \ uint64_t\ type_num,\ pmemobj_constr\ constructor,\ void\ arg);

int\ pmemobj_list_remove(PMEMobjpool\ *pop,\ size_t\ pe_offset,
\ \ \ \ void\ *head,\ PMEMoid\ oid,\ int\ free);

int\ pmemobj_list_move(PMEMobjpool\ *pop,
\ \ \ \ size_t\ pe_old_offset,\ void\ *head_old,
\ \ \ \ size_t\ pe_new_offset,\ void\ *head_new,
\ \ \ \ PMEMoid\ dest,\ int\ before,\ PMEMoid\ oid);
\f[]
.fi
.SH DESCRIPTION
.PP
Besides the internal objects collections mentioned at
\f[B]libpmemobj\f[](7) in section \f[B]OBJECT CONTAINERS\f[] the
\f[B]libpmemobj\f[](7) provides a mechanism to organize persistent
objects in the user\-defined persistent atomic circular doubly linked
lists.
All the routines and macros operating on the persistent lists provide
atomicity with respect to any power\-fail interruptions.
If any of those operations is torn by program failure or system crash;
on recovery they are guaranteed to be entirely completed or discarded,
leaving the lists, persistent memory heap and internal object containers
in a consistent state.
.PP
The persistent atomic circular doubly linked lists support the following
functionality:
.IP \[bu] 2
Insertion of an object at the head of the list, or at the end of the
list.
.IP \[bu] 2
Insertion of an object before or after any element in the list.
.IP \[bu] 2
Atomic allocation and insertion of a new object at the head of the list,
or at the end of the list.
.IP \[bu] 2
Atomic allocation and insertion of a new object before or after any
element in the list.
.IP \[bu] 2
Atomic moving of an element from one list to the specific location on
another list.
.IP \[bu] 2
Removal of any object in the list.
.IP \[bu] 2
Atomic removal and freeing of any object in the list.
.IP \[bu] 2
Forward or backward traversal through the list.
.PP
A list is headed by a \f[I]list_head\f[] structure containing a single
object handle of the first element on the list.
The elements are doubly linked so that an arbitrary element can be
removed without a need to traverse the list.
New elements can be added to the list before or after an existing
element, at the head of the list, or at the end of the list.
A list may be traversed in either direction.
.PP
The user\-defined structure of each element must contain a field of type
\f[I]list_entry\f[] holding the object handles to the previous and next
element on the list.
Both the \f[I]list_head\f[] and the \f[I]list_entry\f[] structures are
declared in \f[B]<libpmemobj.h>\f[].
.PP
The functions below are intended to be used outside transactions \-
transactional variants are described in manpages to functions mentioned
at \f[B]TRANSACTIONAL OBJECT MANIPULATION\f[] in \f[B]libpmemobj\f[](7).
Note that operations performed using this non\-transactional API are
independent from their transactional counterparts.
If any non\-transactional allocations or list manipulations are
performed within an open transaction, the changes will not be
rolled\-back if such a transaction is aborted or interrupted.
.PP
The \f[B]pmemobj_list_insert\f[]() function inserts an element
represented by object handle \f[I]oid\f[] into the list referenced by
\f[I]head\f[].
Depending on the value of flag \f[I]before\f[], the object is added
before or after the element \f[I]dest\f[].
If \f[I]dest\f[] value is \f[B]OID_NULL\f[], the object is inserted at
the head or at the end of the list, depending on the \f[I]before\f[]
flag value.
If value is non\-zero the object is inserted at the head, if value is
zero the object is inserted at the end of the list.
The relevant values are available through \f[B]POBJ_LIST_DEST_HEAD\f[]
and \f[B]POBJ_LIST_DEST_TAIL\f[] defines respectively.
The argument \f[I]pe_offset\f[] declares an offset of the structure that
connects the elements in the list.
All the handles \f[I]head\f[], \f[I]dest\f[] and \f[I]oid\f[] must point
to the objects allocated from the same memory pool \f[I]pop\f[].
The \f[I]head\f[] and \f[I]oid\f[] cannot be \f[B]OID_NULL\f[].
.PP
The \f[B]pmemobj_list_insert_new\f[]() function atomically allocates a
new object of given \f[I]size\f[] and type \f[I]type_num\f[] and inserts
it into the list referenced by \f[I]head\f[].
Depending on the value of \f[I]before\f[] flag, the newly allocated
object is added before or after the element \f[I]dest\f[].
If \f[I]dest\f[] value is \f[B]OID_NULL\f[], the object is inserted at
the head or at the end of the list, depending on the \f[I]before\f[]
flag value.
If value is non\-zero the object is inserted at the head, if value is
zero the object is inserted at the end of the list.
The relevant values are available through \f[B]POBJ_LIST_DEST_HEAD\f[]
and \f[B]POBJ_LIST_DEST_TAIL\f[] defines respectively.
The argument \f[I]pe_offset\f[] declares an offset of the structure that
connects the elements in the list.
All the handles \f[I]head\f[], \f[I]dest\f[] must point to the objects
allocated from the same memory pool \f[I]pop\f[].
Before returning, it calls the \f[I]constructor\f[] function passing the
pool handle \f[I]pop\f[], the pointer to the newly allocated object in
\f[I]ptr\f[] along with the \f[I]arg\f[] argument.
It is guaranteed that allocated object is either properly initialized
or, if the allocation is interrupted before the constructor completes,
the memory space reserved for the object is reclaimed.
The \f[I]head\f[] cannot be \f[B]OID_NULL\f[].
The allocated object is also added to the internal container associated
with given \f[I]type_num\f[].
as described in manpage \f[B]POBJ_FOREACH\f[](3).
.PP
The \f[B]pmemobj_list_remove\f[]() function removes the object
referenced by \f[I]oid\f[] from the list pointed by \f[I]head\f[].
If \f[I]free\f[] flag is set, it also removes the object from the
internal object container and frees the associated memory space.
The argument \f[I]pe_offset\f[] declares an offset of the structure that
connects the elements in the list.
Both \f[I]head\f[] and \f[I]oid\f[] must point to the objects allocated
from the same memory pool \f[I]pop\f[] and cannot be \f[B]OID_NULL\f[].
.PP
The \f[B]pmemobj_list_move\f[]() function moves the object represented
by \f[I]oid\f[] from the list pointed by \f[I]head_old\f[] to the list
pointed by \f[I]head_new\f[].
Depending on the value of flag \f[I]before\f[], the newly allocated
object is added before or after the element \f[I]dest\f[].
If \f[I]dest\f[] value is \f[B]OID_NULL\f[], the object is inserted at
the head or at the end of the second list, depending on the
\f[I]before\f[] flag value.
If value is non\-zero the object is inserted at the head, if value is
zero the object is inserted at the end of the list.
The relevant values are available through \f[B]POBJ_LIST_DEST_HEAD\f[]
and \f[B]POBJ_LIST_DEST_TAIL\f[] defines respectively.
The arguments \f[I]pe_old_offset\f[] and \f[I]pe_new_offset\f[] declare
the offsets of the structures that connects the elements in the old and
new lists respectively.
All the handles \f[I]head_old\f[], \f[I]head_new\f[], \f[I]dest\f[] and
\f[I]oid\f[] must point to the objects allocated from the same memory
pool \f[I]pop\f[].
\f[I]head_old\f[], \f[I]head_new\f[] and \f[I]oid\f[] cannot be
\f[B]OID_NULL\f[].
.SH RETURN VALUE
.PP
The \f[B]pmemobj_list_insert\f[]() function on success returns zero.
On error, \-1 is returned and \f[I]errno\f[] is set.
.PP
The \f[B]pmemobj_list_insert_new\f[]() function on success returns a
handle to the newly allocated object.
On error, \f[B]OID_NULL\f[] is returned and \f[I]errno\f[] is set.
If the constructor returns non\-zero value the allocation is canceled,
the \-1 value is returned from the caller and \f[I]errno\f[] is set to
\f[B]ECANCELED\f[].
.PP
The \f[B]pmemobj_list_remove\f[]() and \f[B]pmemobj_list_move\f[]()
function on success returns zero.
On error, \-1 is returned and \f[I]errno\f[] is set.
.SH SEE ALSO
.PP
\f[B]POBJ_FOREACH\f[](3), \f[B]libpmemobj\f[](7) and
\f[B]<http://pmem.io>\f[]
