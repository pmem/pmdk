<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Mon Jul 25 10:56:18 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title>libpmemobj</title>
</head>
<body>

<h1 align=center>libpmemobj</h1>
<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#MOST COMMONLY USED FUNCTIONS">MOST COMMONLY USED FUNCTIONS</a><br>
<a href="#LOW-LEVEL MEMORY MANIPULATION">LOW-LEVEL MEMORY MANIPULATION</a><br>
<a href="#POOL SETS AND REPLICAS">POOL SETS AND REPLICAS</a><br>
<a href="#LOCKING">LOCKING</a><br>
<a href="#PERSISTENT OBJECTS">PERSISTENT OBJECTS</a><br>
<a href="#TYPE-SAFETY">TYPE-SAFETY</a><br>
<a href="#LAYOUT DECLARATION">LAYOUT DECLARATION</a><br>
<a href="#OBJECT CONTAINERS">OBJECT CONTAINERS</a><br>
<a href="#ROOT OBJECT MANAGEMENT">ROOT OBJECT MANAGEMENT</a><br>
<a href="#NON-TRANSACTIONAL ATOMIC ALLOCATIONS">NON-TRANSACTIONAL ATOMIC ALLOCATIONS</a><br>
<a href="#NON-TRANSACTIONAL PERSISTENT ATOMIC LISTS">NON-TRANSACTIONAL PERSISTENT ATOMIC LISTS</a><br>
<a href="#TYPE-SAFE NON-TRANSACTIONAL PERSISTENT ATOMIC LISTS">TYPE-SAFE NON-TRANSACTIONAL PERSISTENT ATOMIC LISTS</a><br>
<a href="#TRANSACTIONAL OBJECT MANIPULATION">TRANSACTIONAL OBJECT MANIPULATION</a><br>
<a href="#CAVEATS">CAVEATS</a><br>
<a href="#LIBRARY API VERSIONING">LIBRARY API VERSIONING</a><br>
<a href="#MANAGING LIBRARY BEHAVIOR">MANAGING LIBRARY BEHAVIOR</a><br>
<a href="#DEBUGGING AND ERROR HANDLING">DEBUGGING AND ERROR HANDLING</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>
<a name="NAME"></a>
<h2>NAME</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>libpmemobj &minus; persistent memory transactional object
store</p>
</td>
</table>
<a name="SYNOPSIS"></a>
<h2>SYNOPSIS</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<pre><b>#include &lt;libpmemobj.h&gt;

cc -std=gnu99 ... -lpmemobj -lpmem

Most commonly used functions:

PMEMobjpool *pmemobj_open(const char *</b><i>path</i><b>, const char *</b><i>layout</i><b>);
PMEMobjpool *pmemobj_create(const char *</b><i>path</i><b>, const char *</b><i>layout</i><b>,
    size_t</b> <i>poolsize</i><b>, mode_t</b> <i>mode</i><b>);
void pmemobj_close(PMEMobjpool *</b><i>pop</i><b>);

Low-level memory manipulation:

void *pmemobj_memcpy_persist(PMEMobjpool *</b><i>pop</i><b>, void *</b><i>dest</i><b>,
     const void *</b><i>src</i><b>, size_t</b> <i>len</i><b>);
void *pmemobj_memset_persist(PMEMobjpool *</b><i>pop</i><b>, void *</b><i>dest</i><b>,
     int</b> <i>c</i><b>, size_t</b> <i>len</i><b>);
void pmemobj_persist(PMEMobjpool *</b><i>pop</i><b>, const void *</b><i>addr</i><b>, size_t</b> <i>len</i><b>);
void pmemobj_flush(PMEMobjpool *</b><i>pop</i><b>, const void *</b><i>addr</i><b>, size_t</b> <i>len</i><b>);
void pmemobj_drain(PMEMobjpool *</b><i>pop</i><b>);

Locking:

void pmemobj_mutex_zero(PMEMobjpool *</b><i>pop</i><b>, PMEMmutex *</b><i>mutexp</i><b>);
int pmemobj_mutex_lock(PMEMobjpool *</b><i>pop</i><b>, PMEMmutex *</b><i>mutexp</i><b>);
int pmemobj_mutex_timedlock(PMEMobjpool *</b><i>pop</i><b>,
    PMEMmutex *restrict</b> <i>mutexp</i><b>,
    const struct timespec *restrict</b> <i>abs_timeout</i><b>);
int pmemobj_mutex_trylock(PMEMobjpool *</b><i>pop</i><b>, PMEMmutex *</b><i>mutexp</i><b>);
int pmemobj_mutex_unlock(PMEMobjpool *</b><i>pop</i><b>, PMEMmutex *</b><i>mutexp</i><b>);

void pmemobj_rwlock_zero(PMEMobjpool *</b><i>pop</i><b>, PMEMrwlock *</b><i>rwlockp</i><b>);
int pmemobj_rwlock_rdlock(PMEMobjpool *</b><i>pop</i><b>, PMEMrwlock *</b><i>rwlockp</i><b>);
int pmemobj_rwlock_wrlock(PMEMobjpool *</b><i>pop</i><b>, PMEMrwlock *</b><i>rwlockp</i><b>);
int pmemobj_rwlock_timedrdlock(PMEMobjpool *</b><i>pop</i><b>,
    PMEMrwlock *restrict</b> <i>rwlockp</i><b>,
    const struct timespec *restrict</b> <i>abs_timeout</i><b>);
int pmemobj_rwlock_timedwrlock(PMEMobjpool *</b><i>pop</i><b>,
    PMEMrwlock *restrict</b> <i>rwlockp</i><b>,
    const struct timespec *restrict</b> <i>abs_timeout</i><b>);
int pmemobj_rwlock_tryrdlock(PMEMobjpool *</b><i>pop</i><b>, PMEMrwlock *</b><i>rwlockp</i><b>);
int pmemobj_rwlock_trywrlock(PMEMobjpool *</b><i>pop</i><b>, PMEMrwlock *</b><i>rwlockp</i><b>);
int pmemobj_rwlock_unlock(PMEMobjpool *</b><i>pop</i><b>, PMEMrwlock *</b><i>rwlockp</i><b>);

void pmemobj_cond_zero(PMEMobjpool *</b><i>pop</i><b>, PMEMcond *</b><i>condp</i><b>);
int pmemobj_cond_broadcast(PMEMobjpool *</b><i>pop</i><b>, PMEMcond *</b><i>condp</i><b>);
int pmemobj_cond_signal(PMEMobjpool *</b><i>pop</i><b>, PMEMcond *</b><i>condp</i><b>);
int pmemobj_cond_timedwait(PMEMobjpool *</b><i>pop</i><b>, PMEMcond *restrict</b> <i>condp</i><b>,
    PMEMmutex *restrict</b> <i>mutexp</i><b>, const struct timespec *restrict</b> <i>abs_timeout</i><b>);
int pmemobj_cond_wait(PMEMobjpool *</b><i>pop</i><b>, PMEMcond *</b><i>condp</i><b>,
    PMEMmutex *restrict</b> <i>mutexp</i><b>);

Persistent object identifier:

OID_IS_NULL(PMEMoid</b> <i>oid</i><b>)
OID_EQUALS(PMEMoid</b> <i>lhs</i><b>, PMEMoid</b> <i>rhs</i><b>)

Type-safety:

TOID(</b><i>TYPE</i><b>)
TOID_DECLARE(</b><i>TYPE</i><b>, uint64_t</b> <i>type_num</i><b>)
TOID_DECLARE_ROOT(</b><i>ROOT_TYPE</i><b>)

TOID_TYPE_NUM(</b><i>TYPE</i><b>)
TOID_TYPE_NUM_OF(TOID</b> <i>oid</i><b>)
TOID_VALID(TOID</b> <i>oid</i><b>)
OID_INSTANCEOF(PMEMoid</b> <i>oid</i><b>,</b> <i>TYPE</i><b>)

TOID_ASSIGN(TOID</b> <i>oid</i><b>,</b> <i>VALUE</i><b>)

TOID_IS_NULL(TOID</b> <i>oid</i><b>)
TOID_EQUALS(TOID</b> <i>lhs</i><b>, TOID</b> <i>rhs</i><b>)
TOID_TYPEOF(TOID</b> <i>oid</i><b>)
DIRECT_RW(TOID</b> <i>oid</i><b>)
DIRECT_RO(TOID</b> <i>oid</i><b>)
D_RW(TOID</b> <i>oid</i><b>)
D_RO(TOID</b> <i>oid</i><b>)

Layout declaration:

POBJ_LAYOUT_BEGIN(</b><i>layout</i><b>)
POBJ_LAYOUT_TOID(</b><i>layout</i><b>,</b> <i>TYPE</i><b>)
POBJ_LAYOUT_ROOT(</b><i>layout</i><b>,</b> <i>ROOT_TYPE</i><b>)
POBJ_LAYOUT_END(</b><i>layout</i><b>)
POBJ_LAYOUT_NAME(</b><i>layout</i><b>)
POBJ_LAYOUT_TYPES_NUM(</b><i>layout</i><b>)

Non-transactional atomic allocations:

typedef int (*</b><i>pmemobj_constr</i><b>)(PMEMobjpool *</b><i>pop</i><b>,
    void *</b><i>ptr</i><b>, void *</b><i>arg</i><b>);

int pmemobj_alloc(PMEMobjpool *</b><i>pop</i><b>, PMEMoid *</b><i>oidp</i><b>, size_t</b> <i>size</i><b>,
    uint64_t</b> <i>type_num</i><b>, pmemobj_constr</b> <i>constructor</i><b>, void *</b><i>arg</i><b>);
int pmemobj_zalloc(PMEMobjpool *</b><i>pop</i><b>, PMEMoid *</b><i>oidp</i><b>, size_t</b> <i>size</i><b>,
    uint64_t</b> <i>type_num</i><b>);
int pmemobj_realloc(PMEMobjpool *</b><i>pop</i><b>, PMEMoid *</b><i>oidp</i><b>, size_t</b> <i>size</i><b>,
    uint64_t</b> <i>type_num</i><b>);
int pmemobj_zrealloc(PMEMobjpool *</b><i>pop</i><b>, PMEMoid *</b><i>oidp</i><b>, size_t</b> <i>size</i><b>,
    uint64_t</b> <i>type_num</i><b>);
int pmemobj_strdup(PMEMobjpool *</b><i>pop</i><b>, PMEMoid *</b><i>oidp</i><b>, const char *</b><i>s</i><b>,
    uint64_t</b> <i>type_num</i><b>);
void pmemobj_free(PMEMoid *</b><i>oidp</i><b>);
size_t pmemobj_alloc_usable_size(PMEMoid</b> <i>oid</i><b>);
PMEMobjpool *pmemobj_pool_by_oid(PMEMoid</b> <i>oid</i><b>);
PMEMobjpool *pmemobj_pool_by_ptr(const void *</b><i>addr</i><b>);
void *pmemobj_direct(PMEMoid</b> <i>oid</i><b>);
uint64_t pmemobj_type_num(PMEMoid</b> <i>oid</i><b>);

POBJ_NEW(PMEMobjpool *</b><i>pop</i><b>, TOID *</b><i>oidp</i><b>,</b> <i>TYPE</i><b>,
    pmemobj_constr</b> <i>constructor</i><b>, void *</b><i>arg</i><b>)
POBJ_ALLOC(PMEMobjpool *</b><i>pop</i><b>, TOID *</b><i>oidp</i><b>,</b> <i>TYPE</i><b>, size_t</b> <i>size</i><b>,
    pmemobj_constr</b> <i>constructor</i><b>, void *</b><i>arg</i><b>)
POBJ_ZNEW(PMEMobjpool *</b><i>pop</i><b>, TOID *</b><i>oidp</i><b>,</b> <i>TYPE</i><b>)
POBJ_ZALLOC(PMEMobjpool *</b><i>pop</i><b>, TOID *</b><i>oidp</i><b>,</b> <i>TYPE</i><b>, size_t</b> <i>size</i><b>)
POBJ_REALLOC(PMEMobjpool *</b><i>pop</i><b>, TOID *</b><i>oidp</i><b>,</b> <i>TYPE</i><b>, size_t</b> <i>size</i><b>)
POBJ_ZREALLOC(PMEMobjpool *</b><i>pop</i><b>, TOID *</b><i>oidp</i><b>,</b> <i>TYPE</i><b>, size_t</b> <i>size</i><b>)
POBJ_FREE(TOID *</b><i>oidp</i><b>)

Root object management:

PMEMoid pmemobj_root(PMEMobjpool *</b><i>pop</i><b>, size_t</b> <i>size</i><b>);
PMEMoid pmemobj_root_construct(PMEMobjpool *</b><i>pop</i><b>, size_t</b> <i>size</i><b>,
    pmemobj_constr</b> <i>constructor</i><b>, void *</b><i>arg</i><b>);
size_t pmemobj_root_size(PMEMobjpool *</b><i>pop</i><b>);

POBJ_ROOT(PMEMobjpool *</b><i>pop</i><b>,</b> <i>TYPE</i><b>)

Object containers:

PMEMoid pmemobj_first(PMEMobjpool *</b><i>pop</i><b>);
PMEMoid pmemobj_next(PMEMoid</b> <i>oid</i><b>);

POBJ_FIRST_TYPE_NUM(PMEMobjpool *</b><i>pop</i><b>, uint64_t</b> <i>type_num</i><b>)
POBJ_FIRST(PMEMobjpool *</b><i>pop</i><b>,</b> <i>TYPE</i><b>)
POBJ_NEXT_TYPE_NUM(PMEMoid</b> <i>oid</i><b>)
POBJ_NEXT(TOID</b> <i>oid</i><b>)

POBJ_FOREACH(PMEMobjpool *</b><i>pop</i><b>, PMEMoid</b> <i>varoid</i><b>)
POBJ_FOREACH_SAFE(PMEMobjpool *</b><i>pop</i><b>, PMEMoid</b> <i>varoid</i><b>, PMEMoid</b> <i>nvaroid</i><b>)
POBJ_FOREACH_TYPE(PMEMobjpool *</b><i>pop</i><b>, TOID</b> <i>var</i><b>)
POBJ_FOREACH_SAFE_TYPE(PMEMobjpool *</b><i>pop</i><b>, TOID</b> <i>var</i><b>, TOID</b> <i>nvar</i><b>)

Non-transactional persistent atomic circular doubly-linked list:

int pmemobj_list_insert(PMEMobjpool *</b><i>pop</i><b>, size_t</b> <i>pe_offset</i><b>, void *</b><i>head</i><b>,
    PMEMoid</b> <i>dest</i><b>, int</b> <i>before</i><b>, PMEMoid</b> <i>oid</i><b>);
PMEMoid pmemobj_list_insert_new(PMEMobjpool *</b><i>pop</i><b>, size_t</b> <i>pe_offset</i><b>, void *</b><i>head</i><b>,
    PMEMoid</b> <i>dest</i><b>, int</b> <i>before</i><b>, size_t</b> <i>size</i><b>, uint64_t</b> <i>type_num</i><b>,
    pmemobj_constr</b> <i>constructor</i><b>, void *</b><i>arg</i><b>);
int pmemobj_list_remove(PMEMobjpool *</b><i>pop</i><b>, size_t</b> <i>pe_offset</i><b>, void *</b><i>head</i><b>,
    PMEMoid</b> <i>oid</i><b>, int</b> <i>free</i><b>);
int pmemobj_list_move(PMEMobjpool *</b><i>pop</i><b>,
    size_t</b> <i>pe_old_offset</i><b>, void *</b><i>head_old</i><b>,
    size_t</b> <i>pe_new_offset</i><b>, void *</b><i>head_new</i><b>,
    PMEMoid</b> <i>dest</i><b>, int</b> <i>before</i><b>, PMEMoid</b> <i>oid</i><b>);

POBJ_LIST_ENTRY(</b><i>TYPE</i><b>)
POBJ_LIST_HEAD(</b><i>HEADNAME</i><b>,</b> <i>TYPE</i><b>)

POBJ_LIST_FIRST(POBJ_LIST_HEAD *</b><i>head</i><b>)
POBJ_LIST_LAST(POBJ_LIST_HEAD *</b><i>head</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)
POBJ_LIST_EMPTY(POBJ_LIST_HEAD *</b><i>head</i><b>)
POBJ_LIST_NEXT(TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)
POBJ_LIST_PREV(TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)
POBJ_LIST_DEST_HEAD
POBJ_LIST_DEST_TAIL

POBJ_LIST_FOREACH(TOID</b> <i>var</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)
POBJ_LIST_FOREACH_REVERSE(TOID</b> <i>var</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)

POBJ_LIST_INSERT_HEAD(PMEMobjpool *</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,
    TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)
POBJ_LIST_INSERT_TAIL(PMEMobjpool *</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,
    TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)
POBJ_LIST_INSERT_AFTER(PMEMobjpool *</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,
    TOID</b> <i>listelm</i><b>, TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)
POBJ_LIST_INSERT_BEFORE(PMEMobjpool *</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,
    TOID</b> <i>listelm</i><b>, TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)
POBJ_LIST_INSERT_NEW_HEAD(PMEMobjpool *</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,
    POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, size_t</b> <i>size</i><b>,
    pmemobj_constr</b> <i>constructor</i><b>, void *</b><i>arg</i><b>)
POBJ_LIST_INSERT_NEW_TAIL(PMEMobjpool *</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,
    POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, size_t</b> <i>size</i><b>,
    void (*</b><i>constructor</i><b>)(PMEMobjpool *</b><i>pop</i><b>, void *</b><i>ptr</i><b>, void *</b><i>arg</i><b>),
    void *</b><i>arg</i><b>)
POBJ_LIST_INSERT_NEW_AFTER(PMEMobjpool *</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,
    TOID</b> <i>listelm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, size_t</b> <i>size</i><b>,
    pmemobj_constr</b> <i>constructor</i><b>, void *</b><i>arg</i><b>)
POBJ_LIST_INSERT_NEW_BEFORE(PMEMobjpool *</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,
    TOID</b> <i>listelm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, size_t</b> <i>size</i><b>,
    pmemobj_constr</b> <i>constructor</i><b>, void *</b><i>arg</i><b>)
POBJ_LIST_REMOVE(PMEMobjpool *</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,
    TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)
POBJ_LIST_REMOVE_FREE(PMEMobjpool *</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,
    TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)
POBJ_LIST_MOVE_ELEMENT_HEAD(PMEMobjpool *</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,
    POBJ_LIST_HEAD *</b><i>head_new</i><b>, TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>,
    POBJ_LIST_ENTRY</b> <i>field_new</i><b>)
POBJ_LIST_MOVE_ELEMENT_TAIL(PMEMobjpool *</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,
    POBJ_LIST_HEAD *</b><i>head_new</i><b>, TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>,
    POBJ_LIST_ENTRY</b> <i>field_new</i><b>)
POBJ_LIST_MOVE_ELEMENT_AFTER(PMEMobjpool *</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,
    POBJ_LIST_HEAD *</b><i>head_new</i><b>, TOID</b> <i>listelm</i><b>, TOID</b> <i>elm</i><b>,
    POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, POBJ_LIST_ENTRY</b> <i>field_new</i><b>)
POBJ_LIST_MOVE_ELEMENT_BEFORE(PMEMobjpool *</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,
    POBJ_LIST_HEAD *</b><i>head_new</i><b>, TOID</b> <i>listelm</i><b>, TOID</b> <i>elm</i><b>,
    POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, POBJ_LIST_ENTRY</b> <i>field_new</i><b>)

Transactional object manipulation:

enum tx_stage pmemobj_tx_stage(void);

int pmemobj_tx_begin(PMEMobjpool *</b><i>pop</i><b>, jmp_buf *</b><i>env</i><b>, enum</b> <i>tx_lock</i><b>,</b> <i>...</i><b>);
int pmemobj_tx_lock(enum tx_lock</b> <i>lock_type</i><b>, void *</b><i>lockp</i><b>);
void pmemobj_tx_abort(int</b> <i>errnum</i><b>);
void pmemobj_tx_commit(void);
int pmemobj_tx_end(void);
int pmemobj_tx_errno(void);
void pmemobj_tx_process(void);

int pmemobj_tx_add_range(PMEMoid</b> <i>oid</i><b>, uint64_t</b> <i>off</i><b>, size_t</b> <i>size</i><b>);
int pmemobj_tx_add_range_direct(const void *</b><i>ptr</i><b>, size_t</b> <i>size</i><b>);
PMEMoid pmemobj_tx_alloc(size_t</b> <i>size</i><b>, uint64_t</b> <i>type_num</i><b>);
PMEMoid pmemobj_tx_zalloc(size_t</b> <i>size</i><b>, uint64_t</b> <i>type_num</i><b>);
PMEMoid pmemobj_tx_realloc(PMEMoid</b> <i>oid</i><b>, size_t</b> <i>size</i><b>, uint64_t</b> <i>type_num</i><b>);
PMEMoid pmemobj_tx_zrealloc(PMEMoid</b> <i>oid</i><b>, size_t</b> <i>size</i><b>, uint64_t</b> <i>type_num</i><b>);
PMEMoid pmemobj_tx_strdup(const char *</b><i>s</i><b>, uint64_t</b> <i>type_num</i><b>);
int pmemobj_tx_free(PMEMoid</b> <i>oid</i><b>);

TX_BEGIN_LOCK(PMEMobjpool *</b><i>pop</i><b>,</b> <i>...</i><b>)
TX_BEGIN(PMEMobjpool *</b><i>pop</i><b>)
TX_ONABORT
TX_ONCOMMIT
TX_FINALLY
TX_END

TX_ADD(TOID</b> <i>o</i><b>)
TX_ADD_FIELD(TOID</b> <i>o</i><b>,</b> <i>FIELD</i><b>)
TX_ADD_DIRECT(TYPE *</b><i>p</i><b>)
TX_ADD_FIELD_DIRECT(TYPE *</b><i>p</i><b>,</b> <i>FIELD</i><b>)

TX_NEW(</b><i>TYPE</i><b>)
TX_ALLOC(</b><i>TYPE</i><b>, size_t</b> <i>size</i><b>)
TX_ZNEW(</b><i>TYPE</i><b>)
TX_ZALLOC(</b><i>TYPE</i><b>, size_t</b> <i>size</i><b>)
TX_REALLOC(TOID</b> <i>o</i><b>, size_t</b> <i>size</i><b>)
TX_ZREALLOC(TOID</b> <i>o</i><b>, size_t</b> <i>size</i><b>)
TX_STRDUP(const char *</b><i>s</i><b>, uint64_t</b> <i>type_num</i><b>)
TX_FREE(TOID</b> <i>o</i><b>)

TX_SET(TOID</b> <i>o</i><b>,</b> <i>FIELD</i><b>,</b> <i>VALUE</i><b>)
TX_SET_DIRECT(TYPE *</b><i>p</i><b>,</b> <i>FIELD</i><b>,</b> <i>VALUE</i><b>)
TX_MEMCPY(void *</b><i>dest</i><b>, const void *</b><i>src</i><b>, size_t</b> <i>num</i><b>)
TX_MEMSET(void *</b><i>dest</i><b>, int</b> <i>c</i><b>, size_t</b> <i>num</i><b>)

Library API versioning:

const char *pmemobj_check_version(
    unsigned</b> <i>major_required</i><b>,
    unsigned</b> <i>minor_required</i><b>);

Managing library behavior:

void pmemobj_set_funcs(
    void *(*</b><i>malloc_func</i><b>)(size_t</b> <i>size</i><b>),
    void (*</b><i>free_func</i><b>)(void *</b><i>ptr</i><b>),
    void *(*</b><i>realloc_func</i><b>)(void *</b><i>ptr</i><b>, size_t</b> <i>size</i><b>),
    char *(*</b><i>strdup_func</i><b>)(const char *</b><i>s</i><b>));
int pmemobj_check(const char *</b><i>path</i><b>, const char *</b><i>layout</i><b>);

Error handling:

const char *pmemobj_errormsg(void);
</b></pre>
</td>
</table>
<a name="DESCRIPTION"></a>
<h2>DESCRIPTION</h2>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>libpmemobj</b> provides a transactional object store
in <i>persistent memory</i> (pmem). This library is intended
for applications using direct access storage (DAX), which is
storage that supports load/store access without paging
blocks from a block storage device. Some types of
<i>non-volatile memory DIMMs</i> (NVDIMMs) provide this type
of byte addressable access to storage. A <i>persistent
memory aware file system</i> is typically used to expose the
direct access to applications. Memory mapping a file from
this type of file system results in the load/store,
non-paged access to pmem. <b>libpmemobj</b> builds on this
type of memory mapped file.</p>
<!-- INDENTATION -->
<p>This library is for applications that need a transactions
and persistent memory management. The <b>libpmemobj</b>
requires a <b>-std=gnu99</b> compilation flag to build
properly. This library builds on the low-level pmem support
provided by <b>libpmem</b>, handling the transactional
updates, flushing changes to persistence, and recovery for
the application.</p>
<!-- INDENTATION -->
<p><b>libpmemobj</b> is one of a collection of persistent
memory libraries available, the others are:</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p><b>libpmemblk</b>(3), providing pmem-resident arrays of
fixed-sized blocks with atomic updates.</p>
<!-- INDENTATION -->
<p><b>libpmemlog</b>(3), providing a pmem-resident log
file.</p>
<!-- INDENTATION -->
<p><b>libpmem</b>(3), low-level persistent memory
support.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Under normal usage, <b>libpmemobj</b> will never print
messages or intentionally cause the process to exit. The
only exception to this is the debugging information, when
enabled, as described under <b>DEBUGGING AND ERROR
HANDLING</b> below.</p>
</td>
</table>
<a name="MOST COMMONLY USED FUNCTIONS"></a>
<h2>MOST COMMONLY USED FUNCTIONS</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>To use the pmem-resident transactional object store
provided by <b>libpmemobj</b>, a <i>memory pool</i> is first
created. This is done with the <b>pmemobj_create</b>()
function described in this section. The other functions
described in this section then operate on the resulting
memory pool.</p>
<!-- INDENTATION -->
<p>Once created, the memory pool is represented by an opaque
handle, of type <i>PMEMobjpool *</i>, which is passed to
most of the other functions in this section. Internally,
<b>libpmemobj</b> will use either <b>pmem_persist</b>() or
<b>msync</b>(2) when it needs to flush changes, depending on
whether the memory pool appears to be persistent memory or a
regular file (see the <b>pmem_is_pmem</b>() function in
<b>libpmem</b>(3) for more information). There is no need
for applications to flush changes directly when using the
obj memory API provided by <b>libpmemobj</b>.</p>
<!-- INDENTATION -->
<p><b>PMEMobjpool *pmemobj_open(const char
*</b><i>path</i><b>, const char
*</b><i>layout</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_open</b>() function opens an existing
object store memory pool, returning a memory pool handle
used with most of the functions in this section. <i>path</i>
must be an existing file containing a pmemobj memory pool as
created by <b>pmemobj_create</b>(). If <i>layout</i> is
non-NULL, it is compared to the layout name provided to
<b>pmemobj_create</b>() when the pool was first created.
This can be used to verify the layout of the pool matches
what was expected. The application must have permission to
open the file and memory map it with read/write permissions.
If an error prevents the pool from being opened, or if the
given <i>layout</i> does not match the pool&rsquo;s layout,
<b>pmemobj_open</b>() returns NULL and sets errno
appropriately.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>PMEMobjpool *pmemobj_create(const char
*</b><i>path</i><b>, const char *</b><i>layout</i><b>,<br>
size_t</b> <i>poolsize</i><b>, mode_t</b>
<i>mode</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_create</b>() function creates a
transactional object store with the given total
<i>poolsize</i>. <i>path</i> specifies the name of the
memory pool file to be created. <i>layout</i> specifies the
application&rsquo;s layout type in the form of a string. The
layout name is not interpreted by <b>libpmemobj</b>, but may
be used as a check when <b>pmemobj_open</b>() is called. The
layout name, including the null termination, cannot be
longer than <b>PMEMOBJ_MAX_LAYOUT</b> as defined in
<b>&lt;libpmemobj.h&gt;</b>. It is allowed to pass NULL as
<i>layout</i>, which is equivalent for using an empty string
as a layout name. <i>mode</i> specifies the permissions to
use when creating the file as described by <b>creat</b>(2).
The memory pool file is fully allocated to the size
<i>poolsize</i> using <b>posix_fallocate</b>(3). The caller
may choose to take responsibility for creating the memory
pool file by creating it before calling
<b>pmemobj_create</b>() and then specifying <i>poolsize</i>
as zero. In this case <b>pmemobj_create</b>() will take the
pool size from the size of the existing file and will verify
that the file appears to be empty by searching for any
non-zero data in the pool header at the beginning of the
file. The minimum file size allowed by the library for a
transactional object store is defined in
<b>&lt;libpmemobj.h&gt;</b> as <b>PMEMOBJ_MIN_POOL</b>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void pmemobj_close(PMEMobjpool
*</b><i>pop</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_close</b>() function closes the memory
pool indicated by <i>pop</i> and deletes the memory pool
handle. The object store itself lives on in the file that
contains it and may be re-opened at a later time using
<b>pmemobj_open</b>() as described above.</p>
</td>
</table>
<a name="LOW-LEVEL MEMORY MANIPULATION"></a>
<h2>LOW-LEVEL MEMORY MANIPULATION</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The <b>libpmemobj</b> specific low-level memory
manipulation functions leverage the knowledge of the
additional configuration options available for
<b>libpmemobj</b> pools, such as replication. They also take
advantage of the type of storage behind the pool and use
appropriate flush/drain functions. It is advised to use
these functions in conjunction with <b>libpmemobj</b>
objects, instead of using low-level memory manipulations
functions from <b>libpmem</b>.</p>
<!-- INDENTATION -->
<p><b>void pmemobj_persist(PMEMobjpool *</b><i>pop</i><b>,
const void *</b><i>addr</i><b>, size_t</b>
<i>len</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>Forces any changes in the range [<i>addr</i>,
<i>addr</i>+<i>len</i>) to be stored durably in persistent
memory. Internally this may call either <b>pmem_msync</b>()
or <b>pmem_persist</b>(). There are no alignment
restrictions on the range described by <i>addr</i> and
<i>len</i>, but <b>pmemobj_persist</b>() may expand the
range as necessary to meet platform alignment
requirements.</p>
<!-- INDENTATION -->
<p>WARNING: Like <b>msync</b>(2), there is nothing atomic or
transactional about this call. Any unwritten stores in the
given range will be written, but some stores may have
already been written by virtue of normal cache
eviction/replacement policies. Correctly written code must
not depend on stores waiting until <b>pmemobj_persist</b>()
is called to become persistent -- they can become persistent
at any time before <b>pmemobj_persist</b>() is called.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void pmemobj_flush(PMEMobjpool *</b><i>pop</i><b>,
const void *</b><i>addr</i><b>, size_t</b>
<i>len</i><b>);<br>
void pmemobj_drain(PMEMobjpool *</b><i>pop</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>These functions provide partial versions of the
<b>pmemobj_persist</b>() function described above.
<b>pmemobj_persist</b>() can be thought of as this:</p>
<!-- INDENTATION -->
<pre>void
pmemobj_persist(PMEMobjpool *pop, const void *addr, size_t len)
{
    /* flush the processor caches */
    pmemobj_flush(pop, addr, len);

   /* wait for any pmem stores to drain from HW buffers */
    pmemobj_drain(pop);
}
</pre>
<!-- INDENTATION -->
<p>These functions allow advanced programs to create their
own variations of <b>pmemobj_persist</b>(). For example, a
program that needs to flush several discontiguous ranges can
call <b>pmemobj_flush</b>() for each range and then follow
up by calling <b>pmemobj_drain</b>() once. For more
information on partial flushing operations see the
<b>libpmem</b> manpage.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void *pmemobj_memcpy_persist(PMEMobjpool
*</b><i>pop</i><b>, void *</b><i>dest</i><b>,<br>
const void *</b><i>src</i><b>, size_t</b>
<i>len</i><b>);<br>
void *pmemobj_memset_persist(PMEMobjpool *</b><i>pop</i><b>,
void *</b><i>dest</i><b>,<br>
int</b> <i>c</i><b>, size_t</b> <i>len</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_memcpy_persist</b>(), and
<b>pmemobj_memset_persist</b>(), functions provide the same
memory copying as their namesakes <b>memcpy</b>(3), and
<b>memset</b>(3), and ensure that the result has been
flushed to persistence before returning. For example, the
following code is functionally equivalent to
<b>pmemobj_memcpy_persist</b>():</p>
<!-- INDENTATION -->
<pre>void *
pmemobj_memcpy_persist(PMEMobjpool *pop, void *dest,
    const void *src, size_t len)
{
    void *retval = memcpy(pop, dest, src, len);

   pmemobj_persist(pop, dest, len);

   return retval;
}
</pre>
</td>
</table>
<a name="POOL SETS AND REPLICAS"></a>
<h2>POOL SETS AND REPLICAS</h2>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Depending on the configuration of the system, the
available space of non-volatile memory space may be divided
into multiple memory devices. In such case, the maximum size
of the transactional object store could be limited by the
capacity of a single memory device. The <b>libpmemobj</b>
allows building transactional object stores spanning
multiple memory devices by creation of persistent memory
pools consisting of multiple files, where each part of such
a <i>pool set</i> may be stored on different pmem-aware
filesystem.</p>
<!-- INDENTATION -->
<p>To improve reliability and eliminate the single point of
failure, all the changes of the data stored in the
persistent memory pool could be also automatically written
to local pool replicas, thereby providing a backup for a
persistent memory pool by producing a <i>mirrored pool
set</i>. In practice, the pool replicas may be considered
binary copies of the &quot;master&quot; pool set.</p>
<!-- INDENTATION -->
<p>Creation of all the parts of the pool set and the
associated replica sets can be done with the
<b>pmemobj_create</b>() function or by using the
<b>pmempool</b>(1) utility.</p>
<!-- INDENTATION -->
<p>When creating the pool set consisting of multiple files,
or when creating the replicated pool set, the <i>path</i>
argument passed to <b>pmemobj_create</b>() must point to the
special <i>set</i> file that defines the pool layout and the
location of all the parts of the pool set. The
<i>poolsize</i> argument must be 0. The meaning of
<i>layout</i> and <i>mode</i> arguments doesn&rsquo;t
change, except that the same <i>mode</i> is used for
creation of all the parts of the pool set and replicas. If
the error prevents any of the pool set files from being
created, <b>pmemobj_create</b>() returns NULL and sets errno
appropriately.</p>
<!-- INDENTATION -->
<p>When opening the pool set consisting of multiple files,
or when opening the replicated pool set, the <i>path</i>
argument passed to <b>pmemobj_open</b>() must not point to
the pmemobj memory pool file, but to the same <i>set</i>
file that was used for the pool set creation. If an error
prevents any of the pool set files from being opened, or if
the actual size of any file does not match the corresponding
part size defined in <i>set</i> file <b>pmemobj_open</b>()
returns NULL and sets errno appropriately.</p>
<!-- INDENTATION -->
<p>The set file is a plain text file, which must start with
the line containing a <i>PMEMPOOLSET</i> string, followed by
the specification of all the pool parts in the next lines.
For each part, the file size and the absolute path must be
provided. The size has to be compliant with the format
specified in IEC 80000-13, IEEE 1541 or the Metric
Interchange Format. Standards accept SI units with
obligatory B - kB, MB, GB, ... (multiplier by 1000) and IEC
units with optional &quot;iB&quot; - KiB, MiB, GiB, ..., K,
M, G, ... - (multiplier by 1024).</p>
<!-- INDENTATION -->
<p>The minimum file size of each part of the pool set is the
same as the minimum size allowed for a transactional object
store consisting of one file. It is defined in
<b>&lt;libpmemobj.h&gt;</b> as <b>PMEMOBJ_MIN_POOL</b>.
Sections defining the replica sets are optional. There could
be multiple replica sections and each must start with the
line containing a <i>REPLICA</i> string. Lines starting with
&quot;#&quot; character are ignored.</p>
<!-- INDENTATION -->
<p>Here is the example &quot;myobjpool.set&quot; file:</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<pre>PMEMPOOLSET
100G /mountpoint0/myfile.part0
200G /mountpoint1/myfile.part1
400G /mountpoint2/myfile.part2
REPLICA
500G /mountpoint3/mymirror.part0
200G /mountpoint4/mymirror.part1
</pre>
</td>
</table>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The files in the set may be created by running the
following command:</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<pre>pmempool create --layout=&quot;mylayout&quot; obj myobjpool.set
</pre>
</td>
</table>
<a name="LOCKING"></a>
<h2>LOCKING</h2>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>libpmemobj</b> provides several types of
synchronization primitives, designed so as to use them with
persistent memory. The locks are not dynamically allocated,
but embedded in pmem-resident objects. For performance
reasons, they are also padded up to 64 bytes (cache line
size).</p>
<!-- INDENTATION -->
<p>Pmem-aware locks implementation is based on the standard
POSIX Thread Library, as described in
<b>pthread_mutex</b>(3), <b>pthread_rwlock</b>(3) and
<b>pthread_cond</b>(3). They provide semantics similar to
standard <b>pthread</b> locks, except that they are
considered initialized by zeroing them. So allocating the
locks with <b>pmemobj_zalloc</b>() or
<b>pmemobj_tx_zalloc</b>() does not require another
initialization step.</p>
<!-- INDENTATION -->
<p>The fundamental property of pmem-aware locks is their
automatic reinitialization every time the persistent object
store pool is open. This way, all the pmem-aware locks may
be considered initialized (unlocked) right after opening the
pool, regardless of their state at the time the pool was
closed for the last time.</p>
<!-- INDENTATION -->
<p>Pmem-aware mutexes, read/write locks and condition
variables must be declared with one of the <i>PMEMmutex</i>,
<i>PMEMrwlock</i>, or <i>PMEMcond</i> type respectively.</p>
<!-- INDENTATION -->
<p><b>void pmemobj_mutex_zero(PMEMobjpool
*</b><i>pop</i><b>, PMEMmutex
*</b><i>mutexp</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_mutex_zero</b>() function explicitly
initializes pmem-aware mutex pointed by <i>mutexp</i> by
zeroing it. Initialization is not necessary if the object
containing the mutex has been allocated using one of
<b>pmemobj_zalloc</b>() or <b>pmemobj_tx_zalloc</b>()
functions.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_mutex_lock(PMEMobjpool *</b><i>pop</i><b>,
PMEMmutex *</b><i>mutexp</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_mutex_lock</b>() function locks pmem-aware
mutex pointed by <i>mutexp</i>. If the mutex is already
locked, the calling thread will block until the mutex
becomes available. If this is the first use of the mutex
since opening of the pool <i>pop</i>, the mutex is
automatically reinitialized and then locked.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_mutex_timedlock(PMEMobjpool
*</b><i>pop</i><b>,<br>
PMEMmutex *restrict</b> <i>mutexp</i><b>,<br>
const struct timespec *restrict</b>
<i>abs_timeout</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_mutex_timedlock</b>() performs the same
action as <b>pmemobj_mutex_lock</b>(), but will not wait
beyond <i>abs_timeout</i> to obtain the lock before
returning.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_mutex_trylock(PMEMobjpool
*</b><i>pop</i><b>, PMEMmutex
*</b><i>mutexp</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_mutex_trylock</b>() function locks
pmem-aware mutex pointed by <i>mutexp</i>. If the mutex is
already locked, <b>pthread_mutex_trylock</b>() will not
block waiting for the mutex, but will return an error
condition. If this is the first use of the mutex since
opening of the pool <i>pop</i> the mutex is automatically
reinitialized and then locked.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_mutex_unlock(PMEMobjpool
*</b><i>pop</i><b>, PMEMmutex
*</b><i>mutexp</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_mutex_unlock</b>() function unlocks an
acquired pmem-aware mutex pointed by <i>mutexp</i>.
Undefined behavior follows if a thread tries to unlock a
mutex that has not been locked by it, or if a thread tries
to release a mutex that is already unlocked or not
initialized.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void pmemobj_rwlock_zero(PMEMobjpool
*</b><i>pop</i><b>, PMEMrwlock
*</b><i>rwlockp</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_rwlock_zero</b>() function is used to
explicitly initialize pmem-aware read/write lock pointed by
<i>rwlockp</i> by zeroing it. Initialization is not
necessary if the object containing the lock has been
allocated using one of <b>pmemobj_zalloc</b>() or
<b>pmemobj_tx_zalloc</b>() functions.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_rwlock_rdlock(PMEMobjpool
*</b><i>pop</i><b>, PMEMrwlock
*</b><i>rwlockp</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_rwlock_rdlock</b>() function acquires a
read lock on <i>rwlockp</i> provided that lock is not
presently held for writing and no writer threads are
presently blocked on the lock. If the read lock cannot be
immediately acquired, the calling thread blocks until it can
acquire the lock. If this is the first use of the lock since
opening of the pool <i>pop</i>, the lock is automatically
reinitialized and then acquired.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_rwlock_timedrdlock(PMEMobjpool
*</b><i>pop</i><b>,<br>
PMEMrwlock *restrict</b> <i>rwlockp</i><b>,<br>
const struct timespec *restrict</b>
<i>abs_timeout</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_rwlock_timedrdlock</b>() performs the same
action, but will not wait beyond <i>abs_timeout</i> to
obtain the lock before returning.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>A thread may hold multiple concurrent read locks. If so,
<b>pmemobj_rwlock_unlock</b>() must be called once for each
lock obtained.</p>
<!-- INDENTATION -->
<p>The results of acquiring a read lock while the calling
thread holds a write lock are undefined.</p>
<!-- INDENTATION -->
<p><b>int pmemobj_rwlock_wrlock(PMEMobjpool
*</b><i>pop</i><b>, PMEMrwlock
*</b><i>rwlockp</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_rwlock_wrlock</b>() function blocks until
a write lock can be acquired against lock pointed by
<i>rwlockp</i>. If this is the first use of the lock since
opening of the pool <i>pop</i>, the lock is automatically
reinitialized and then acquired.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_rwlock_timedwrlock(PMEMobjpool
*</b><i>pop</i><b>,<br>
PMEMrwlock *restrict</b> <i>rwlockp</i><b>,<br>
const struct timespec *restrict</b>
<i>abs_timeout</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_rwlock_timedwrlock</b>() performs the same
action, but will not wait beyond <i>abs_timeout</i> to
obtain the lock before returning.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_rwlock_tryrdlock(PMEMobjpool
*</b><i>pop</i><b>, PMEMrwlock
*</b><i>rwlockp</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_rwlock_tryrdlock</b>() function performs
the same action as <b>pmemobj_rwlock_rdlock</b>(), but does
not block if the lock cannot be immediately obtained.</p>
<!-- INDENTATION -->
<p>The results are undefined if the calling thread already
holds the lock at the time the call is made.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_rwlock_trywrlock(PMEMobjpool
*</b><i>pop</i><b>, PMEMrwlock
*</b><i>rwlockp</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_rwlock_trywrlock</b>() function performs
the same action as <b>pmemobj_rwlock_wrlock</b>(), but does
not block if the lock cannot be immediately obtained.</p>
<!-- INDENTATION -->
<p>The results are undefined if the calling thread already
holds the lock at the time the call is made.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_rwlock_unlock(PMEMobjpool
*</b><i>pop</i><b>, PMEMrwlock
*</b><i>rwlockp</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_rwlock_unlock</b>() function is used to
release the read/write lock previously obtained by
<b>pmemobj_rwlock_rdlock</b>(),
<b>pmemobj_rwlock_wrlock</b>(),
<b>pthread_rwlock_tryrdlock</b>(), or
<b>pmemobj_rwlock_trywrlock</b>().</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void pmemobj_cond_zero(PMEMobjpool *</b><i>pop</i><b>,
PMEMcond *</b><i>condp</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_cond_zero</b>() function explicitly
initializes pmem-aware condition variable by zeroing it.
Initialization is not necessary if the object containing the
condition variable has been allocated using one of
<b>pmemobj_zalloc</b>() or <b>pmemobj_tx_zalloc</b>()
functions.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_cond_broadcast(PMEMobjpool
*</b><i>pop</i><b>, PMEMcond *</b><i>condp</i><b>);</b></p>
<!-- INDENTATION -->
<p><b>int pmemobj_cond_signal(PMEMobjpool
*</b><i>pop</i><b>, PMEMcond *</b><i>condp</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The difference between <b>pmemobj_cond_broadcast</b>()
and <b>pmemobj_cond_signal</b>() is that the former unblocks
all threads waiting for the condition variable, whereas the
latter blocks only one waiting thread. If no threads are
waiting on <i>cond</i>, neither function has any effect. If
more than one thread is blocked on a condition variable, the
used scheduling policy determines the order in which threads
are unblocked. The same mutex used for waiting must be held
while calling either function. Although neither function
strictly enforces this requirement, undefined behavior may
follow if the mutex is not held.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_cond_timedwait(PMEMobjpool
*</b><i>pop</i><b>, PMEMcond *restrict</b>
<i>condp</i><b>,<br>
PMEMmutex *restrict</b> <i>mutexp</i><b>,<br>
const struct timespec *restrict</b>
<i>abs_timeout</i><b>);</b></p>
<!-- INDENTATION -->
<p><b>int pmemobj_cond_wait(PMEMobjpool *</b><i>pop</i><b>,
PMEMcond *</b><i>condp</i><b>,<br>
PMEMmutex *restrict</b> <i>mutexp</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_cond_timedwait</b>() and
<b>pmemobj_cond_wait</b>() functions shall block on a
condition variable. They shall be called with mutex locked
by the calling thread or undefined behavior results. These
functions atomically release mutex pointed by <i>mutexp</i>
and cause the calling thread to block on the condition
variable <i>cond</i>; atomically here means &quot;atomically
with respect to access by another thread to the mutex and
then the condition variable&quot;. That is, if another
thread is able to acquire the mutex after the about-to-block
thread has released it, then a subsequent call to
<b>pmemobj_cond_broadcast</b>() or
<b>pmemobj_cond_signal</b>() in that thread shall behave as
if it were issued after the about-to-block thread has
blocked. Upon successful return, the mutex shall have been
locked and shall be owned by the calling thread.</p>
</td>
</table>
<a name="PERSISTENT OBJECTS"></a>
<h2>PERSISTENT OBJECTS</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Each object stored in persistent memory pool is
represented by an object handle of type <i>PMEMoid</i>. In
practice, such a handle is a unique Object IDentifier (OID)
of a global scope, which means that two objects from
different pools may not have the same OID. The special
<i>OID_NULL</i> macro defines a NULL-like handle that does
not represent any object. The size of a single object is
limited by a <i>PMEMOBJ_MAX_ALLOC_SIZE</i>. Thus an
allocation with requested size greater than this value will
fail.</p>
<!-- INDENTATION -->
<p>An OID cannot be considered as a direct pointer to an
object. Each time the program attempts to read or write
object data, it must obtain the current memory address of
the object by converting its OID into the pointer.</p>
<!-- INDENTATION -->
<p>In contrast to the memory address, the OID value for
given object does not change during the life of an object
(except for realloc operation), and remains valid after
closing and reopening the pool. For this reason, if an
object contains a reference to another persistent object -
necessary to build some kind of a linked data structure - it
shall never use memory address of an object, but its
OID.</p>
<!-- INDENTATION -->
<p><b>void *pmemobj_direct(PMEMoid</b>
<i>oid</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_direct</b>() function returns a pointer to
an object represented by <i>oid</i>. If OID_NULL is passed
as an argument, function returns NULL.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>uint64_t pmemobj_type_num(PMEMoid</b>
<i>oid</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_type_num</b>() function returns a type
number of the object represented by <i>oid</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>PMEMobjpool *pmemobj_pool_by_oid(PMEMoid</b>
<i>oid</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_pool_by_oid</b>() function returns a
handle to the pool which contains the object represented by
<i>oid</i>. If the pool is not open or OID_NULL is passed as
an argument, function returns NULL.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>PMEMobjpool *pmemobj_pool_by_ptr(const void
*</b><i>addr</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_pool_by_ptr</b>() function returns a
handle to the pool which contains the address. If the
address does not belong to any open pool, function returns
NULL.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>At the time of allocation (or reallocation), each object
may be assigned a number representing its type. Such a
<i>type number</i> may be used to arrange the persistent
objects based on their actual user-defined structure type,
thus facilitating implementation of a simple run-time type
safety mechanism. It also allows to iterate through all the
objects of given type stored in the persistent memory pool.
See <b>OBJECT CONTAINERS</b> section for more details.</p>
<!-- INDENTATION -->
<p>The <b>OID_IS_NULL</b> macro checks if given
<i>PMEMoid</i> represents a NULL object.</p>
<!-- INDENTATION -->
<p>The <b>OID_EQUALS</b> macro compares two <i>PMEMoid</i>
objects.</p>
</td>
</table>
<a name="TYPE-SAFETY"></a>
<h2>TYPE-SAFETY</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Operating on untyped object handles, as well as on direct
untyped object pointers (void *) may be confusing and error
prone. To facilitate implementation of type safety
mechanism, <b>libpmemobj</b> defines a set of macros that
provide a static type enforcement, catching potential errors
at compile time. For example, a compile-time error is
generated when an attempt is made to assign a handle to an
object of one type to the object handle variable of another
type of object.</p>
<!-- INDENTATION -->
<p><b>TOID_DECLARE(</b><i>TYPE</i><b>, uint64_t</b>
<i>type_num)</i></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TOID_DECLARE</b> macro declares a typed OID of
user-defined type specified by argument <i>TYPE</i>, and
with type number specified by argument <i>type_num</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TOID_DECLARE_ROOT(</b><i>ROOT_TYPE</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TOID_DECLARE_ROOT</b> macro declares a typed OID
of user-defined type specified by argument <i>ROOT_TYPE</i>,
and with type number for root object
<b>POBJ_ROOT_TYPE_NUM</b>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TOID(</b><i>TYPE</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TOID</b> macro declares a handle to an object of
type specified by argument <i>TYPE</i>, where <i>TYPE</i> is
the name of a user-defined structure. The typed OID must be
declared first using the <b>TOID_DECLARE</b>,
<b>TOID_DECLARE_ROOT</b>, <b>POBJ_LAYOUT_TOID</b> or
<b>POBJ_LAYOUT_ROOT</b> macros.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TOID_TYPE_NUM(</b><i>TYPE</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TOID_TYPE_NUM</b> macro returns a type number of
the type specified by argument <i>TYPE</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TOID_TYPE_NUM_OF(TOID</b> <i>oid</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TOID_TYPE_NUM_OF</b> macro returns a type number
of the object specified by argument <i>oid</i>. The type
number is read from the typed OID.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TOID_VALID(TOID</b> <i>oid</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TOID_VALID</b> macro validates whether the type
number stored in object&rsquo;s metadata is equal to the
type number read from typed OID.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>OID_INSTANCEOF(PMEMoid</b> <i>oid</i><b>,</b>
<i>TYPE</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>OID_INSTANCEOF</b> macro checks whether the
<i>oid</i> is of the type specified by argument
<i>TYPE</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TOID_ASSIGN(TOID</b> <i>o</i><b>,</b>
<i>VALUE</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TOID_ASSIGN</b> macro assigns an object handle
specified by <i>VALUE</i> to the variable <i>o</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TOID_IS_NULL(TOID</b> <i>o</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TOID_IS_NULL</b> macro evaluates to true if the
object handle represented by argument <i>o</i> has OID_NULL
value.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TOID_EQUALS(TOID</b> <i>lhs</i><b>, TOID</b>
<i>rhs</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TOID_EQUALS</b> macro evaluates to true if both
<i>lhs</i> and <i>rhs</i> object handles are referencing the
same persistent object.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TOID_TYPEOF(TOID</b> <i>o</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TOID_TYPEOF</b> macro returns a type of the object
handle represented by argument <i>o</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>DIRECT_RW(TOID</b> <i>oid</i><b>)</b></p>
<!-- INDENTATION -->
<p><b>D_RW(TOID</b> <i>oid</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>DIRECT_RW</b>() macro and its shortened form
<b>D_RW</b>() return a typed write pointer (TYPE *) to an
object represented by <i>oid</i>. If <i>oid</i> holds
OID_NULL value, the macro evaluates to NULL.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>DIRECT_RO(TOID</b> <i>oid</i><b>)</b></p>
<!-- INDENTATION -->
<p><b>D_RO(TOID</b> <i>oid</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>DIRECT_RO</b>() macro and its shortened form
<b>D_RO</b>() return a typed read-only (const) pointer (TYPE
*) to an object represented by <i>oid</i>. If <i>oid</i>
holds OID_NULL value, the macro evaluates to NULL.</p>
</td>
</table>
<a name="LAYOUT DECLARATION"></a>
<h2>LAYOUT DECLARATION</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The <i>libpmemobj</i> defines a set of macros for
convenient declaration of pool&rsquo;s layout. The
declaration of layout consist of declaration of number of
used types. The declared types will be assigned consecutive
type numbers. Declared types may be used in conjunction with
type safety macros. Once created the layout declaration
shall not be changed unless the new types are added at the
end of the existing layout declaration. Modifying any of
existing declaration may lead to changes in type numbers of
declared types which in consequence may cause data
corruption.</p>
<!-- INDENTATION -->
<p><b>POBJ_LAYOUT_BEGIN(</b><i>LAYOUT</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>POBJ_LAYOUT_BEGIN</b> macro indicates a begin of
declaration of layout. The <i>LAYOUT</i> argument is a name
of layout. This argument must be passed to all macros
related to the declaration of layout.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LAYOUT_TOID(</b><i>LAYOUT</i><b>,</b>
<i>TYPE</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>POBJ_LAYOUT_TOID</b> macro declares a typed OID
for type passed as <i>TYPE</i> argument inside the
declaration of layout. All types declared using this macro
are assigned with consecutive type numbers. This macro must
be used between the <b>POBJ_LAYOUT_BEGIN</b> and
<b>POBJ_LAYOUT_END</b> macros, with the same name passed as
<i>LAYOUT</i> argument.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LAYOUT_ROOT(</b><i>LAYOUT</i><b>,</b>
<i>ROOT_TYPE</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>POBJ_LAYOUT_ROOT</b> macro declares a typed OID
for type passed as <i>ROOT_TYPE</i> argument inside the
declaration of layout. The typed OID will be assigned with
type number for root object <b>POBJ_ROOT_TYPE_NUM</b>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LAYOUT_END(</b><i>LAYOUT</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>POBJ_LAYOUT_END</b> macro ends the declaration of
layout.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LAYOUT_NAME(</b><i>LAYOUT</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>POBJ_LAYOUT_NAME</b> macro returns the name of
layout as a NULL-terminated string.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LAYOUT_TYPES_NUM(</b><i>LAYOUT</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>POBJ_LAYOUT_TYPES_NUM</b> macro returns number of
types declared using the <b>POBJ_LAYOUT_TOID</b> macro
within the layout declaration.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>This is an example of layout declaration:</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<pre>POBJ_LAYOUT_BEGIN(mylayout);
POBJ_LAYOUT_ROOT(mylayout, struct root);
POBJ_LAYOUT_TOID(mylayout, struct node);
POBJ_LAYOUT_TOID(mylayout, struct foo);
POBJ_LAYOUT_END(mylayout);

struct root {
</pre>
</td>
</table>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="7%">

<p>TOID(struct node) node;</p>
</td>
<td width="64%">
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>};</p>
<!-- INDENTATION -->
<p>struct node {</p></td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>TOID(struct node) next;</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>TOID(struct foo) foo;</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>};</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The name of layout and the number of declared types can
be retrieved using the following code:</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<pre>const char *layout_name = POBJ_LAYOUT_NAME(mylayout);
int num_of_types = POBJ_LAYOUT_TYPES_NUM(mylayout);
</pre>
</td>
</table>
<a name="OBJECT CONTAINERS"></a>
<h2>OBJECT CONTAINERS</h2>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>All the objects in the persistent memory pool are
assigned a <i>type number</i> and are accessible by it.</p>
<!-- INDENTATION -->
<p>The <i>libpmemobj</i> provides a mechanism allowing to
iterate through the internal object collection, either
looking for a specific object, or performing a specific
operation on each object of given type. Software should not
make any assumptions about the order of the objects in the
internal object containers.</p>
<!-- INDENTATION -->
<p><b>PMEMoid pmemobj_first(PMEMobjpool
*</b><i>pop</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_first</b>() function returns the first
object from the pool. If the pool is empty, OID_NULL is
returned.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_FIRST(PMEMobjpool *</b><i>pop</i><b>,</b>
<i>TYPE</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>POBJ_FIRST</b> macro returns the first object from
the pool of the type specified by <i>TYPE</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_FIRST_TYPE_NUM(PMEMobjpool *</b><i>pop</i><b>,
uint64_t</b> <i>type_num</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>POBJ_FIRST_TYPE_NUM</b> macro returns the first
object from the pool of the type specified by
<i>type_num</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>PMEMoid pmemobj_next(PMEMoid</b>
<i>oid</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_next</b>() function returns the next
object from the pool. If an object referenced by <i>oid</i>
is the last object in the collection, or if the OID_NULL is
passed as an argument, function returns OID_NULL.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_NEXT(TOID</b> <i>oid</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>POBJ_NEXT</b> macro returns the next object of the
same type as the object referenced by <i>oid</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_NEXT_TYPE_NUM(PMEMoid</b> <i>oid</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>POBJ_NEXT_TYPE_NUM</b> macro returns the next
object of the same type as the object referenced by
<i>oid</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The following four macros provide more convenient way to
iterate through the internal collections, performing a
specific operation on each object.</p>
<!-- INDENTATION -->
<p><b>POBJ_FOREACH(PMEMobjpool *</b><i>pop</i><b>,
PMEMoid</b> <i>varoid</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>POBJ_FOREACH</b>() macro allows to perform a
specific operation on each allocated object stored in the
persistent memory pool pointed by <i>pop</i>. It traverses
the internal collection of all the objects, assigning a
handle to each element in turn to <i>varoid</i>
variable.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_FOREACH_TYPE(PMEMobjpool *</b><i>pop</i><b>,
TOID</b> <i>var</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p><b>POBJ_FOREACH_TYPE</b>() macro allows to perform a
specific operation on each allocated object of the same type
as object passed as <i>var</i> argument, stored in the
persistent memory pool pointed by <i>pop</i>. It traverses
the internal collection of all the objects of the specified
type, assigning a handle to each element in turn to
<i>var</i> variable.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_FOREACH_SAFE(PMEMobjpool *</b><i>pop</i><b>,
PMEMoid</b> <i>varoid</i><b>,<br>
PMEMoid</b> <i>nvaroid</i><b>)</b></p>
<!-- INDENTATION -->
<p><b>POBJ_FOREACH_SAFE_TYPE(PMEMobjpool *</b><i>pop</i><b>,
TOID</b> <i>var</i><b>, TOID</b> <i>nvar</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macros <b>POBJ_FOREACH_SAFE</b>() and
<b>POBJ_FOREACH_SAFE_TYPE</b>() work in a similar fashion as
<b>POBJ_FOREACH</b>() and <b>POBJ_FOREACH_TYPE</b>() except
that prior to performing the operation on the object, they
preserve a handle to the next object in the collection by
assigning it to <i>nvaroid</i> or <i>nvar</i> variable. This
allows safe deletion of selected objects while iterating
through the collection.</p>
</td>
</table>
<a name="ROOT OBJECT MANAGEMENT"></a>
<h2>ROOT OBJECT MANAGEMENT</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The root object of persistent memory pool is an entry
point for all other persistent objects allocated using the
<i>libpmemobj</i> API. In other words, every single object
stored in persistent memory pool should have the root object
at the end of its reference path. It may be assumed that for
each persistent memory pool the root object always exists,
and there is exactly one root object in each pool.</p>
<!-- INDENTATION -->
<p><b>PMEMoid pmemobj_root(PMEMobjpool *</b><i>pop</i><b>,
size_t</b> <i>size</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_root</b>() function returns a handle to
the root object associated with the persistent memory pool
pointed by <i>pop</i>. If this is the first call to
<b>pmemobj_root</b>() and the root object does not exists
yet, it is implicitly allocated in a thread-safe manner, so
if the function is called by more than one thread
simultaneously (with identical <i>size</i> value), the same
root object handle is returned in all the threads.</p>
<!-- INDENTATION -->
<p>The size of the root object is guaranteed to be not less
than the requested <i>size</i>. If the requested size is
larger than the current size, the root object is
automatically resized. In such case, the old data is
preserved and the extra space is zeroed. The
<b>pmemobj_root</b>() function shall not fail, except for
the case if the requested object size is larger than the
maximum allocation size supported for given pool, or if
there is not enough free space in the pool to satisfy the
reallocation of the root object. In such case, OID_NULL is
returned.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>PMEMoid pmemobj_root_construct(PMEMobjpool
*</b><i>pop</i><b>, size_t</b> <i>size</i><b>,<br>
pmemobj_constr</b> <i>constructor</i><b>, void
*</b><i>arg</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_root_construct</b>() performs the same
actions as the <b>pmemobj_root</b>() function, but instead
of zeroing the newly allocated object a <i>constructor</i>
function is called. The constructor is also called on
reallocations. If the constructor returns non-zero value the
allocation is canceled, the <b>OID_NULL</b> value is
returned from the caller and errno is set to <b>ECANCELED
.</b> The <b>pmemobj_root_size</b>() can be used in the
constructor to check whether it&rsquo;s the first call to
the constructor.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_ROOT(PMEMobjpool *</b><i>pop</i><b>,</b>
<i>TYPE</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>POBJ_ROOT</b> macro works the same way as the
<b>pmemobj_root</b>() function except it returns a typed OID
of type <i>TYPE</i> instead of <b>PMEMoid</b>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>size_t pmemobj_root_size(PMEMobjpool
*</b><i>pop</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_root_size</b>() function returns the
current size of the root object associated with the
persistent memory pool pointed by <i>pop</i>. The returned
size is the largest value requested by any of the earlier
<b>pmemobj_root</b>() calls. 0 is returned if the root
object has not been allocated yet.</p>
</td>
</table>
<a name="NON-TRANSACTIONAL ATOMIC ALLOCATIONS"></a>
<h2>NON-TRANSACTIONAL ATOMIC ALLOCATIONS</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Functions described in this section provide the mechanism
to allocate, resize and free objects from the persistent
memory pool in a thread-safe and fail-safe manner. All the
routines are atomic with respect to other threads and any
power-fail interruptions. If any of those operations is torn
by program failure or system crash; on recovery they are
guaranteed to be entirely completed or discarded, leaving
the persistent memory heap and internal object containers in
a consistent state.</p>
<!-- INDENTATION -->
<p>All these functions can be used outside transactions.
Note that operations performed using non-transactional API
are considered durable after completion, even if executed
within the open transaction. Such non-transactional changes
will not be rolled-back if the transaction is aborted or
interrupted.</p>
<!-- INDENTATION -->
<p>The allocations are always aligned to the cache-line
boundary.</p>
<!-- INDENTATION -->
<p><b>typedef int
(*</b><i>pmemobj_constr</i><b>)(PMEMobjpool
*</b><i>pop</i><b>,<br>
void *</b><i>ptr</i><b>, void *</b><i>arg</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_constr</b> type represents a constructor
for atomic allocation from persistent memory heap associated
with memory pool <i>pop</i>. The <i>ptr</i> is a pointer to
allocating memory area and the <i>arg</i> is an user-defined
argument passed to an appropriate function.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_alloc(PMEMobjpool *</b><i>pop</i><b>,
PMEMoid *</b><i>oidp</i><b>, size_t</b> <i>size</i><b>,<br>
uint64_t</b> <i>type_num</i><b>, pmemobj_constr</b>
<i>constructor</i> <b>, void *</b><i>arg</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_alloc</b> function allocates a new object
from the persistent memory heap associated with memory pool
<i>pop</i>. The <b>PMEMoid</b> of allocated object is stored
in <i>oidp</i>. If NULL is passed as <i>oidp</i>, then the
newly allocated object may be accessed only by iterating
objects in the object container associated with given
<i>type_num</i>, as described in <b>OBJECT CONTAINERS</b>
section. If the <i>oidp</i> points to memory location from
the <b>pmemobj</b> heap the <i>oidp</i> is modified
atomically. Before returning, it calls the
<b>constructor</b> function passing the pool handle
<i>pop</i>, the pointer to the newly allocated object in
<i>ptr</i> along with the <i>arg</i> argument. It is
guaranteed that allocated object is either properly
initialized, or if the allocation is interrupted before the
constructor completes, the memory space reserved for the
object is reclaimed. If the constructor returns non-zero
value the allocation is canceled, the -1 value is returned
from the caller and errno is set to <b>ECANCELED .</b> The
<i>size</i> can be any non-zero value, however due to
internal padding and object metadata, the actual size of the
allocation will differ from the requested one by at least 64
bytes. For this reason, making the allocations of a size
less than 64 bytes is extremely inefficient and discouraged.
If <i>size</i> equals 0, then <b>pmemobj_alloc</b>() returns
non-zero value, sets the errno and leaves the <i>oidp</i>
untouched. The allocated object is added to the internal
container associated with given <i>type_num</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_zalloc(PMEMobjpool *</b><i>pop</i><b>,
PMEMoid *</b><i>oidp</i><b>, size_t</b> <i>size</i><b>,<br>
uint64_t</b> <i>type_num</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_zalloc</b>() function allocates a new
zeroed object from the the persistent memory heap associated
with memory pool <i>pop</i>. The <b>PMEMoid</b> of allocated
object is stored in <i>oidp</i>. If NULL is passed as
<i>oidp</i>, then the newly allocated object may be accessed
only by iterating objects in the object container associated
with given <i>type_num</i>, as described in <b>OBJECT
CONTAINERS</b> section. If the <i>oidp</i> points to memory
location from the <b>pmemobj</b> heap the <i>oidp</i> is
modified atomically. The <i>size</i> can be any non-zero
value, however due to internal padding and object metadata,
the actual size of the allocation will differ from the
requested one by at least 64 bytes. For this reason, making
the allocations of a size less than 64 bytes is extremely
inefficient and discouraged. If <i>size</i> equals 0, then
<b>pmemobj_zalloc</b>() returns non-zero value, sets the
errno and leaves the <i>oidp</i> untouched. The allocated
object is added to the internal container associated with
given <i>type_num</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void pmemobj_free(PMEMoid
*</b><i>oidp</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_free</b>() function provides the same
semantics as <b>free</b>(3), but instead of the process heap
supplied by the system, it operates on the persistent memory
heap. It frees the memory space represented by <i>oidp</i>,
which must have been returned by a previous call to
<b>pmemobj_alloc</b>(), <b>pmemobj_zalloc</b>(),
<b>pmemobj_realloc</b>(), or <b>pmemobj_zrealloc</b>(). If
<i>oidp</i> is NULL or if it points to the root
object&rsquo;s OID, behavior of the function is undefined.
If it points to <i>OID_NULL</i>, no operation is performed.
It sets the <i>oidp</i> to <i>OID_NULL</i> value after
freeing the memory. If the <i>oidp</i> points to memory
location from the <b>pmemobj</b> heap the <i>oidp</i> is
changed atomically.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_realloc(PMEMobjpool *</b><i>pop</i><b>,
PMEMoid *</b><i>oidp</i><b>, size_t</b> <i>size</i><b>,<br>
uint64_t</b> <i>type_num</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_realloc</b>() function provide similar
semantics to <b>realloc</b>(3), but operates on the
persistent memory heap associated with memory pool
<i>pop</i>. It changes the size of the object represented by
<i>oidp</i>, to <i>size</i> bytes. The resized object is
also added or moved to the internal container associated
with given <i>type_num</i>. The contents will be unchanged
in the range from the start of the region up to the minimum
of the old and new sizes. If the new size is larger than the
old size, the added memory will <i>not</i> be initialized.
If <i>oidp</i> is NULL or if it points to the root
object&rsquo;s OID, behavior of the function is undefined.
If it points to <i>OID_NULL</i>, then the call is equivalent
to <b>pmemobj_alloc(</b><i>pop</i><b>,</b>
<i>size</i><b>,</b> <i>type_num</i><b>).</b> If <i>size</i>
is equal to zero, and <i>oidp</i> is not <i>OID_NULL</i>,
then the call is equivalent to
<b>pmemobj_free(</b><i>oid</i><b>).</b> Unless <i>oidp</i>
is <i>OID_NULL</i>, it must have been returned by an earlier
call to <b>pmemobj_alloc</b>(), <b>pmemobj_zalloc</b>(),
<b>pmemobj_realloc</b>(), or <b>pmemobj_zrealloc</b>(). Note
that the object handle value may change in result of
reallocation. If the object was moved, a memory space
represented by <i>oid</i> is reclaimed. If <i>oidp</i>
points to memory location from the <b>pmemobj</b> heap the
<i>oidp</i> is changed atomically. If
<b>pmemobj_realloc</b>() is unable to satisfy the allocation
request, a non-zero value is returned and errno is set
appropriately.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_zrealloc(PMEMobjpool *</b><i>pop</i><b>,
PMEMoid *</b><i>oidp</i><b>, size_t</b> <i>size</i><b>,<br>
uint64_t</b> <i>type_num</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_zrealloc</b>() function provide similar
semantics to <b>realloc</b>(3), but operates on the
persistent memory heap associated with memory pool
<i>pop</i>. It changes the size of the object represented by
<i>oid</i>, to <i>size</i> bytes. The resized object is also
added or moved to the internal container associated with
given <i>type_num</i>. The contents will be unchanged in the
range from the start of the region up to the minimum of the
old and new sizes. If the new size is larger than the old
size, the added memory will be zeroed. If <i>oidp</i> is
NULL or if it points to the root object&rsquo;s OID,
behavior of the function is undefined. If it points to
<i>OID_NULL</i>, then the call is equivalent to
<b>pmemobj_zalloc(</b><i>pop</i><b>,</b> <i>size</i><b>,</b>
<i>type_num</i><b>).</b> If <i>size</i> is equal to zero,
and <i>oidp</i> doesn&rsquo;t point to <i>OID_NULL</i>, then
the call is equivalent to
<b>pmemobj_free(</b><i>pop</i><b>,</b> <i>oid</i><b>).</b>
Unless <i>oidp</i> points to <i>OID_NULL</i>, it must have
been returned by an earlier call to <b>pmemobj_alloc</b>(),
<b>pmemobj_zalloc</b>(), <b>pmemobj_realloc</b>(), or
<b>pmemobj_zrealloc</b>(). Note that the object handle value
may change in result of reallocation. If the object was
moved, a memory space represented by <i>oidp</i> is
reclaimed. If <i>oidp</i> points to memory location from the
<b>pmemobj</b> heap the <i>oidp</i> is changed atomically.
If <b>pmemobj_zrealloc</b>() is unable to satisfy the
allocation request, OID_NULL is returned and errno is set
appropriately.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_strdup(PMEMobjpool *</b><i>pop</i><b>,
PMEMoid *</b><i>oidp</i><b>, const char
*</b><i>s</i><b>,<br>
uint64_t</b> <i>type_num</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_strdup</b>() function provides the same
semantics as <b>strdup</b>(3), but operates on the
persistent memory heap associated with memory pool
<i>pop</i>. It stores a handle to a new object in
<i>oidp</i> which is a duplicate of the string <i>s</i>. If
NULL is passed as <i>oidp</i>, then the newly allocated
object may be accessed only by iterating objects in the
object container associated with given <i>type_num</i>, as
described in <b>OBJECT CONTAINERS</b> section. If the
<i>oidp</i> points to memory location from the
<b>pmemobj</b> heap the <i>oidp</i> is changed atomically.
The allocated string object is also added to the internal
container associated with given <i>type_num</i>. Memory for
the new string is obtained with <b>pmemobj_alloc</b>(), on
the given memory pool, and can be freed with
<b>pmemobj_free</b>() on the same memory pool. If
<b>pmemobj_strdup</b>() is unable to satisfy the allocation
request, OID_NULL is returned and errno is set
appropriately.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>size_t pmemobj_alloc_usable_size(PMEMoid</b>
<i>oid</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_alloc_usable_size</b>() function provides
the same semantics as <b>malloc_usable_size</b>(3), but
instead of the process heap supplied by the system, it
operates on the persistent memory heap. It returns the
number of usable bytes in the object represented by
<i>oid</i>, a handle to an object allocated by
<b>pmemobj_alloc</b>() or a related function. If <i>oid</i>
is OID_NULL, 0 is returned.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_NEW(PMEMobjpool *</b><i>pop</i><b>, TOID
*</b><i>oidp</i><b>,</b> <i>TYPE</i><b>,<br>
pmemobj_constr</b> <i>constructor</i> <b>, void
*</b><i>arg</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>POBJ_NEW</b> macro is a wrapper around the
<b>pmemobj_alloc</b>() function which takes the type name
<b>TYPE</b> and passes the size and type number to the
<b>pmemobj_alloc</b>() function from the typed OID. Instead
of taking a pointer to <b>PMEMoid</b> it takes a pointer to
typed OID of <b>TYPE</b>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_ALLOC(PMEMobjpool *</b><i>pop</i><b>, TOID
*</b><i>oidp</i><b>,</b> <i>TYPE</i><b>, size_t</b>
<i>size</i><b>,<br>
pmemobj_constr</b> <i>constructor</i> <b>, void
*</b><i>arg</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>POBJ_ALLOC</b> macro is a wrapper around the
<b>pmemobj_alloc</b>() function which takes the type name
<b>TYPE</b>, the size of allocation <i>size</i> and passes
the type number to the <b>pmemobj_alloc</b>() function from
the typed OID. Instead of taking a pointer to <b>PMEMoid</b>
it takes a pointer to typed OID of <b>TYPE</b>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_ZNEW(PMEMobjpool *</b><i>pop</i><b>, TOID
*</b><i>oidp</i><b>,</b> <i>TYPE</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>POBJ_ZNEW</b> macro is a wrapper around the
<b>pmemobj_zalloc</b>() function which takes the type name
<b>TYPE</b> and passes the size and type number to the
<b>pmemobj_zalloc</b>() function from the typed OID. Instead
of taking a pointer to <b>PMEMoid</b> it takes a pointer to
typed OID of <b>TYPE</b>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_ZALLOC(PMEMobjpool *</b><i>pop</i><b>, TOID
*</b><i>oidp</i><b>,</b> <i>TYPE</i><b>, size_t</b>
<i>size</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>POBJ_ZALLOC</b> macro is a wrapper around the
<b>pmemobj_zalloc</b>() function which takes the type name
<b>TYPE</b>, the size of allocation <i>size</i> and passes
the type number to the <b>pmemobj_zalloc</b>() function from
the typed OID. Instead of taking a pointer to <b>PMEMoid</b>
it takes a pointer to typed OID of <b>TYPE</b>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_REALLOC(PMEMobjpool *</b><i>pop</i><b>, TOID
*</b><i>oidp</i><b>,</b> <i>TYPE</i><b>, size_t</b>
<i>size</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>POBJ_REALLOC</b> macro is a wrapper around the
<b>pmemobj_realloc</b>() function which takes the type name
<b>TYPE</b> and passes the type number to the
<b>pmemobj_realloc</b>() function from the typed OID.
Instead of taking a pointer to <b>PMEMoid</b> it takes a
pointer to typed OID of <b>TYPE</b>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_ZREALLOC(PMEMobjpool *</b><i>pop</i><b>, TOID
*</b><i>oidp</i><b>,</b> <i>TYPE</i><b>, size_t</b>
<i>size</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>POBJ_ZREALLOC</b> macro is a wrapper around the
<b>pmemobj_zrealloc</b>() function which takes the type name
<b>TYPE</b> and passes the type number to the
<b>pmemobj_zrealloc</b>() function from the typed OID.
Instead of taking a pointer to <b>PMEMoid</b> it takes a
pointer to typed OID of <b>TYPE</b>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_FREE(TOID *</b><i>oidp</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>POBJ_FREE</b> macro is a wrapper around the
<b>pmemobj_free</b>() function which takes pointer to typed
OID <i>oidp</i> as an argument instead of
<b>PMEMoid</b>.</p>
</td>
</table>
<a name="NON-TRANSACTIONAL PERSISTENT ATOMIC LISTS"></a>
<h2>NON-TRANSACTIONAL PERSISTENT ATOMIC LISTS</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Besides the internal objects collections described in
section <b>OBJECT CONTAINERS</b> the <b>libpmemobj</b>
provides a mechanism to organize persistent objects in the
user-defined persistent atomic circular doubly linked lists.
All the routines and macros operating on the persistent
lists provide atomicity with respect to any power-fail
interruptions. If any of those operations is torn by program
failure or system crash; on recovery they are guaranteed to
be entirely completed or discarded, leaving the lists,
persistent memory heap and internal object containers in a
consistent state.</p>
<!-- INDENTATION -->
<p>The persistent atomic circular doubly linked lists
support the following functionality:</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">

<p>*</p>
</td>
<td width="4%"></td>
<td width="82%">

<p>Insertion of an object at the head of the list, or at
the end of the list.</p>
</td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">

<p>*</p>
</td>
<td width="4%"></td>
<td width="82%">

<p>Insertion of an object before or after any element in
the list.</p>
</td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">

<p>*</p>
</td>
<td width="4%"></td>
<td width="82%">

<p>Atomic allocation and insertion of a new object at the
head of the list, or at the end of the list.</p>
</td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">

<p>*</p>
</td>
<td width="4%"></td>
<td width="82%">

<p>Atomic allocation and insertion of a new object before
or after any element in the list.</p>
</td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">

<p>*</p>
</td>
<td width="4%"></td>
<td width="82%">

<p>Atomic moving of an element from one list to the
specific location on another list.</p>
</td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">

<p>*</p>
</td>
<td width="4%"></td>
<td width="82%">

<p>Removal of any object in the list.</p>
</td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">

<p>*</p>
</td>
<td width="4%"></td>
<td width="82%">

<p>Atomic removal and freeing of any object in the
list.</p>
</td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">

<p>*</p>
</td>
<td width="4%"></td>
<td width="82%">

<p>Forward or backward traversal through the list.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>A list is headed by a <i>list_head</i> structure
containing a single object handle of the first element on
the list. The elements are doubly linked so that an
arbitrary element can be removed without a need to traverse
the list. New elements can be added to the list before or
after an existing element, at the head of the list, or at
the end of the list. A list may be traversed in either
direction.</p>
<!-- INDENTATION -->
<p>The user-defined structure of each element must contain a
field of type <b>list_entry</b> holding the object handles
to the previous and next element on the list. Both the
<b>list_head</b> and the <b>list_entry</b> structures are
declared in <b>&lt;libpmemobj.h&gt;</b>.</p>
<!-- INDENTATION -->
<p>The functions below are intended to be used outside
transactions - transactional variants are described in
section <b>TRANSACTIONAL OBJECT MANIPULATION</b>. Note that
operations performed using this non-transactional API are
independent from their transactional counterparts. If any
non-transactional allocations or list manipulations are
performed within an open transaction, the changes will not
be rolled-back if such a transaction is aborted or
interrupted.</p>
<!-- INDENTATION -->
<p><b>int pmemobj_list_insert(PMEMobjpool
*</b><i>pop</i><b>, size_t</b> <i>pe_offset</i><b>,<br>
void *</b><i>head</i><b>, PMEMoid</b> <i>dest</i><b>,
int</b> <i>before</i><b>, PMEMoid</b>
<i>oid</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_list_insert</b> function inserts an
element represented by object handle <i>oid</i> into the
list referenced by <i>head</i>. Depending on the value of
flag <i>before</i>, the object is added before or after the
element <i>dest</i>. If <i>dest</i> value is OID_NULL, the
object is inserted at the head or at the end of the list,
depending on the <i>before</i> flag value. If value is
non-zero the object is inserted at the head, if value is
zero the object is inserted at the end of the list. The
relevant values are available through
<b>POBJ_LIST_DEST_HEAD</b> and <b>POBJ_LIST_DEST_TAIL</b>
defines respectively. The argument <i>pe_offset</i> declares
an offset of the structure that connects the elements in the
list. All the handles <i>head</i>, <i>dest</i> and
<i>oid</i> must point to the objects allocated from the same
memory pool <i>pop</i>. The <i>head</i> and <i>oid</i>
cannot be OID_NULL. On success, zero is returned. On error,
-1 is returned and errno is set.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>PMEMoid pmemobj_list_insert_new(PMEMobjpool
*</b><i>pop</i><b>, size_t</b> <i>pe_offset</i><b>,<br>
void *</b><i>head</i><b>, PMEMoid</b> <i>dest</i><b>,
int</b> <i>before</i><b>, size_t</b> <i>size</i><b>,<br>
uint64_t</b> <i>type_num</i><b>, pmemobj_constr</b>
<i>constructor</i><b>, void *</b><i>arg</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_list_insert_new</b> function atomically
allocates a new object of given <i>size</i> and type
<i>type_num</i> and inserts it into the list referenced by
<i>head</i>. Depending on the value of <i>before</i> flag,
the newly allocated object is added before or after the
element <i>dest</i>. If <i>dest</i> value is OID_NULL, the
object is inserted at the head or at the end of the list,
depending on the <i>before</i> flag value. If value is
non-zero the object is inserted at the head, if value is
zero the object is inserted at the end of the list. The
relevant values are available through
<b>POBJ_LIST_DEST_HEAD</b> and <b>POBJ_LIST_DEST_TAIL</b>
defines respectively. The argument <i>pe_offset</i> declares
an offset of the structure that connects the elements in the
list. All the handles <i>head</i>, <i>dest</i> must point to
the objects allocated from the same memory pool <i>pop</i>.
Before returning, it calls the <b>constructor</b> function
passing the pool handle <i>pop</i>, the pointer to the newly
allocated object in <i>ptr</i> along with the <i>arg</i>
argument. It is guaranteed that allocated object is either
properly initialized or, if the allocation is interrupted
before the constructor completes, the memory space reserved
for the object is reclaimed. If the constructor returns
non-zero value the allocation is canceled, the -1 value is
returned from the caller and errno is set to <b>ECANCELED
.</b> The <i>head</i> cannot be OID_NULL. The allocated
object is also added to the internal container associated
with given <i>type_num</i>. as described in section
<b>OBJECT CONTAINERS</b>. On success, it returns a handle to
the newly allocated object. On error, OID_NULL is returned
and errno is set.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_list_remove(PMEMobjpool
*</b><i>pop</i><b>, size_t</b> <i>pe_offset</i><b>,<br>
void *</b><i>head</i><b>, PMEMoid</b> <i>oid</i><b>, int</b>
<i>free</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_list_remove</b> function removes the
object referenced by <i>oid</i> from the list pointed by
<i>head</i>. If <i>free</i> flag is set, it also removes the
object from the internal object container and frees the
associated memory space. The argument <i>pe_offset</i>
declares an offset of the structure that connects the
elements in the list. Both <i>head</i> and <i>oid</i> must
point to the objects allocated from the same memory pool
<i>pop</i> and cannot be OID_NULL. On success, zero is
returned. On error, -1 is returned and errno is set.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_list_move(PMEMobjpool
*</b><i>pop</i><b>,<br>
size_t</b> <i>pe_old_offset</i><b>, void
*</b><i>head_old</i><b>,<br>
size_t</b> <i>pe_new_offset</i><b>, void
*</b><i>head_new</i><b>,<br>
PMEMoid</b> <i>dest</i><b>, int</b> <i>before</i><b>,
PMEMoid</b> <i>oid</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_list_move</b> function moves the object
represented by <i>oid</i> from the list pointed by
<i>head_old</i> to the list pointed by <i>head_new</i>.
Depending on the value of flag <i>before</i>, the newly
allocated object is added before or after the element
<i>dest</i>. If <i>dest</i> value is OID_NULL, the object is
inserted at the head or at the end of the second list,
depending on the <i>before</i> flag value. If value is
non-zero the object is inserted at the head, if value is
zero the object is inserted at the end of the list. The
relevant values are available through
<b>POBJ_LIST_DEST_HEAD</b> and <b>POBJ_LIST_DEST_TAIL</b>
defines respectively. The arguments <i>pe_old_offset</i> and
<i>pe_new_offset</i> declare the offsets of the structures
that connects the elements in the old and new lists
respectively. All the handles <i>head_old</i>,
<i>head_new</i>, <i>dest</i> and <i>oid</i> must point to
the objects allocated from the same memory pool <i>pop</i>.
<i>head_old</i>, <i>head_new</i> and <i>oid</i> cannot be
OID_NULL. On success, zero is returned. On error, -1 is
returned and errno is set.</p>
</td>
</table>
<a name="TYPE-SAFE NON-TRANSACTIONAL PERSISTENT ATOMIC LISTS"></a>
<h2>TYPE-SAFE NON-TRANSACTIONAL PERSISTENT ATOMIC LISTS</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The following macros define and operate on a type-safe
persistent atomic circular doubly linked list data structure
that consist of a set of persistent objects of a well-known
type. Unlike the functions described in the previous
section, these macros provide type enforcement by requiring
declaration of type of the objects stored in given list, and
not allowing mixing objects of different types in a single
list.</p>
<!-- INDENTATION -->
<p>The functionality and semantics of those macros is
similar to circular queues defined in <b>queue</b>(3).</p>
<!-- INDENTATION -->
<p>The majority of the macros must specify the handle to the
memory pool <i>pop</i> and the name of the <i>field</i> in
the user-defined structure, which must be of type
<i>POBJ_LIST_ENTRY</i> and is used to connect the elements
in the list.</p>
<!-- INDENTATION -->
<p>A list is headed by a structure defined by the
<i>POBJ_LIST_HEAD</i> macro. This structure contains an
object handle of the first element on the list. The elements
are doubly linked so that an arbitrary element can be
removed without a need to traverse the list. New elements
can be added to the list before or after an existing
element, at the head of the list, or at the end of the list.
A list may be traversed in either direction. A
<b>POBJ_LIST_HEAD</b> structure is declared as follows:</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<pre>#define POBJ_LIST_HEAD(HEADNAME, TYPE)
struct HEADNAME {
    TOID(TYPE) pe_first;
    PMEMmutex lock;
};
</pre>
</td>
</table>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>In the macro definitions, <i>TYPE</i> is the name of a
user-defined structure, that must contain a field of type
<i>POBJ_LIST_ENTRY</i>. The argument <i>HEADNAME</i> is the
name of a user-defined structure that must be declared using
the macro <i>POBJ_LIST_HEAD</i>. See the examples below for
further explanation of how these macros are used.</p>
<!-- INDENTATION -->
<p>The macro <b>POBJ_LIST_ENTRY</b> declares a structure
that connects the elements in the list.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<pre>#define POBJ_LIST_ENTRY(TYPE)
struct {
    TOID(TYPE) pe_next;
    TOID(TYPE) pe_prev;
};
</pre>
</td>
</table>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LIST_FIRST(POBJ_LIST_HEAD
*</b><i>head</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macro <b>POBJ_LIST_FIRST</b> returns the first
element on the list referenced by <i>head</i>. If the list
is empty OID_NULL is returned.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LIST_LAST(POBJ_LIST_HEAD *</b><i>head</i><b>,
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macro <b>POBJ_LIST_LAST</b> returns the last element
on the list referenced by <i>head</i>. If the list is empty
OID_NULL is returned.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LIST_EMPTY(POBJ_LIST_HEAD
*</b><i>head</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macro <b>POBJ_LIST_EMPTY</b> evaluates to 1 if the
list referenced by <i>head</i> is empty. Otherwise, 0 is
returned.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LIST_NEXT(TOID</b> <i>elm</i><b>,
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macro <b>POBJ_LIST_NEXT</b> returns the element next
to the element <i>elm</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LIST_PREV(TOID</b> <i>elm</i><b>,
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macro <b>POBJ_LIST_PREV</b> returns the element
preceding the element <i>elm</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LIST_FOREACH(TOID</b> <i>var</i><b>,
POBJ_LIST_HEAD *</b><i>head</i><b>,<br>
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macro <b>POBJ_LIST_FOREACH</b> traverses the list
referenced by <i>head</i> assigning a handle to each element
in turn to <i>var</i> variable.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LIST_FOREACH_REVERSE(TOID</b> <i>var</i><b>,
POBJ_LIST_HEAD *</b><i>head</i><b>,<br>
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macro <b>POBJ_LIST_FOREACH_REVERSE</b> traverses the
list referenced by <i>head</i> in reverse order, assigning a
handle to each element in turn to <i>var</i> variable. The
<i>field</i> argument is the name of the field of type
<i>POBJ_LIST_ENTRY</i> in the element structure.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LIST_INSERT_HEAD(PMEMobjpool *</b><i>pop</i><b>,
POBJ_LIST_HEAD *</b><i>head</i><b>,<br>
TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b>
<i>FIELD</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macro <b>POBJ_LIST_INSERT_HEAD</b> inserts the
element <i>elm</i> at the head of the list referenced by
<i>head</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LIST_INSERT_TAIL(PMEMobjpool *</b><i>pop</i><b>,
POBJ_LIST_HEAD *</b><i>head</i><b>,<br>
TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b>
<i>FIELD</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macro <b>POBJ_LIST_INSERT_TAIL</b> inserts the
element <i>elm</i> at the end of the list referenced by
<i>head</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LIST_INSERT_AFTER(PMEMobjpool *</b><i>pop</i><b>,
POBJ_LIST_HEAD *</b><i>head</i><b>,<br>
TOID</b> <i>listelm</i><b>, TOID</b> <i>elm</i><b>,
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macro <b>POBJ_LIST_INSERT_AFTER</b> inserts the
element <i>elm</i> into the list referenced by <i>head</i>
after the element <i>listelm</i>. If <i>listelm</i> value is
TOID_NULL, the object is inserted at the end of the
list.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LIST_INSERT_BEFORE(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,<br>
TOID</b> <i>listelm</i><b>, TOID</b> <i>elm</i><b>,
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macro <b>POBJ_LIST_INSERT_BEFORE</b> inserts the
element <i>elm</i> into the list referenced by <i>head</i>
before the element <i>listelm</i>. If <i>listelm</i> value
is TOID_NULL, the object is inserted at the head of the
list.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LIST_INSERT_NEW_HEAD(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,<br>
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, size_t</b>
<i>size</i><b>,<br>
pmemobj_constr</b> <i>constructor</i> <b>, void
*</b><i>arg</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macro <b>POBJ_LIST_INSERT_NEW_HEAD</b> atomically
allocates a new object of size <i>size</i> and inserts it at
the head of the list referenced by <i>head</i>. The newly
allocated object is also added to the internal object
container associated with a type number which is retrieved
from the typed OID of the first element on list.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LIST_INSERT_NEW_TAIL(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,<br>
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, size_t</b>
<i>size</i><b>,<br>
pmemobj_constr</b> <i>constructor</i> <b>, void
*</b><i>arg</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macro <b>POBJ_LIST_INSERT_NEW_TAIL</b> atomically
allocates a new object of size <i>size</i> and inserts it at
the tail of the list referenced by <i>head</i>. The newly
allocated object is also added to the internal object
container associated with with a type number which is
retrieved from the typed OID of the first element on
list.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LIST_INSERT_NEW_AFTER(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,<br>
TOID</b> <i>listelm</i><b>, POBJ_LIST_ENTRY</b>
<i>FIELD</i><b>, size_t</b> <i>size</i><b>,<br>
pmemobj_constr</b> <i>constructor</i> <b>, void
*</b><i>arg</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macro <b>POBJ_LIST_INSERT_NEW_AFTER</b> atomically
allocates a new object of size <i>size</i> and inserts it
into the list referenced by <i>head</i> after the element
<i>listelm</i>. If <i>listelm</i> value is TOID_NULL, the
object is inserted at the end of the list. The newly
allocated object is also added to the internal object
container associated with with a type number which is
retrieved from the typed OID of the first element on
list.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LIST_INSERT_NEW_BEFORE(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,<br>
TOID</b> <i>listelm</i><b>, POBJ_LIST_ENTRY</b>
<i>FIELD</i><b>, size_t</b> <i>size</i><b>,<br>
pmemobj_constr</b> <i>constructor</i> <b>, void
*</b><i>arg</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macro <b>POBJ_LIST_INSERT_NEW_BEFORE</b> atomically
allocates a new object of size <i>size</i> and inserts it
into the list referenced by <i>head</i> before the element
<i>listelm</i>. If <i>listelm</i> value is TOID_NULL, the
object is inserted at the head of the list. The newly
allocated object is also added to the internal object
container associated with with a type number which is
retrieved from the typed OID of the first element on
list.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LIST_REMOVE(PMEMobjpool *</b><i>pop</i><b>,
POBJ_LIST_HEAD *</b><i>head</i><b>,<br>
TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b>
<i>FIELD</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macro <b>POBJ_LIST_REMOVE</b> removes the element
<i>elm</i> from the list referenced by <i>head</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LIST_REMOVE_FREE(PMEMobjpool *</b><i>pop</i><b>,
POBJ_LIST_HEAD *</b><i>head</i><b>,<br>
TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b>
<i>FIELD</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macro <b>POBJ_LIST_REMOVE_FREE</b> removes the
element <i>elm</i> from the list referenced by <i>head</i>
and frees the memory space represented by this element.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LIST_MOVE_ELEMENT_HEAD(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,<br>
POBJ_LIST_HEAD *</b><i>head_new</i><b>, TOID</b>
<i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>,<br>
POBJ_LIST_ENTRY</b> <i>field_new</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macro <b>POBJ_LIST_MOVE_ELEMENT_HEAD</b> moves the
element <i>elm</i> from the list referenced by <i>head</i>
to the head of the list <i>head_new</i>. The <i>field</i>
and <i>field_new</i> arguments are the names of the fields
of type <i>POBJ_LIST_ENTRY</i> in the element structure that
are used to connect the elements in both lists.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LIST_MOVE_ELEMENT_TAIL(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,<br>
POBJ_LIST_HEAD *</b><i>head_new</i><b>, TOID</b>
<i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>,<br>
POBJ_LIST_ENTRY</b> <i>field_new</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macro <b>POBJ_LIST_MOVE_ELEMENT_TAIL</b> moves the
element <i>elm</i> from the list referenced by <i>head</i>
to the end of the list <i>head_new</i>. The <i>field</i> and
<i>field_new</i> arguments are the names of the fields of
type <i>POBJ_LIST_ENTRY</i> in the element structure that
are used to connect the elements in both lists.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LIST_MOVE_ELEMENT_AFTER(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,<br>
POBJ_LIST_HEAD *</b><i>head_new</i><b>, TOID</b>
<i>listelm</i><b>, TOID</b> <i>elm</i><b>,<br>
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, POBJ_LIST_ENTRY</b>
<i>field_new</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macro <b>POBJ_LIST_MOVE_ELEMENT_AFTER</b> atomically
removes the element <i>elm</i> from the list referenced by
<i>head</i> and inserts it into the list referenced by
<i>head_new</i> after the element <i>listelm</i>. If
<i>listelm</i> value is TOID_NULL, the object is inserted at
the end of the list. The <i>field</i> and <i>field_new</i>
arguments are the names of the fields of type
<i>POBJ_LIST_ENTRY</i> in the element structure that are
used to connect the elements in both lists.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>POBJ_LIST_MOVE_ELEMENT_BEFORE(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,<br>
POBJ_LIST_HEAD *</b><i>head_new</i><b>, TOID</b>
<i>listelm</i><b>, TOID</b> <i>elm</i><b>,<br>
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, POBJ_LIST_ENTRY</b>
<i>field_new</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The macro <b>POBJ_LIST_MOVE_ELEMENT_BEFORE</b> atomically
removes the element <i>elm</i> from the list referenced by
<i>head</i> and inserts it into the list referenced by
<i>head_new</i> before the element <i>listelm</i>. If
<i>listelm</i> value is TOID_NULL, the object is inserted at
the head of the list. The <i>field</i> and <i>field_new</i>
arguments are the names of the fields of type
<i>POBJ_LIST_ENTRY</i> in the element structure that are
used to connect the elements in both lists.</p>
</td>
</table>
<a name="TRANSACTIONAL OBJECT MANIPULATION"></a>
<h2>TRANSACTIONAL OBJECT MANIPULATION</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The functions described in sections <b>NON-TRANSACTIONAL
ATOMIC ALLOCATIONS</b> and <b>NON-TRANSACTIONAL PERSISTENT
ATOMIC LISTS</b> only guarantee the atomicity in scope of a
single operation on an object. In case of more complex
changes, involving multiple operations on an object, or
allocation and modification of multiple objects; data
consistency and fail-safety may be provided only by using
<i>atomic transactions</i>.</p>
<!-- INDENTATION -->
<p>A transaction is defined as series of operations on
persistent memory objects that either all occur, or nothing
occurs. In particular, if the execution of a transaction is
interrupted by a power failure or a system crash, it is
guaranteed that after system restart, all the changes made
as a part of the uncompleted transaction will be
rolled-back, restoring the consistent state of the memory
pool from the moment when the transaction was started.</p>
<!-- INDENTATION -->
<p>Note that transactions do not provide the atomicity with
respect to other threads. All the modifications performed
within the transactions are immediately visible to other
threads, and this is the responsibility of the program to
implement a proper thread synchronization mechanism.</p>
<!-- INDENTATION -->
<p>Each transaction is visible only for the thread that
started it. No other threads can add operations, commit or
abort the transaction initiated by another thread. There may
be multiple open transactions on given memory pool at the
same time, but only one transaction per thread.</p>
<!-- INDENTATION -->
<p>Nested transactions are supported but flattened.
Committing the nested transaction does not commit the outer
transaction, however errors in the nested transaction are
propagated up to the outer-most level, resulting in the
interruption of the entire transaction.</p>
<!-- INDENTATION -->
<p>Please see the <b>CAVEATS</b> section for known
limitations of the transactional API.</p>
<!-- INDENTATION -->
<p><b>enum tx_stage pmemobj_tx_stage(void);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_tx_stage</b>() function returns the stage
of the current transaction stage for a thread. Stages are
changed only by the <i>pmemobj_tx_*</i> functions. The
transaction stages are defined as follows:</p>
<!-- INDENTATION -->
<p><b>TX_STAGE_NONE</b> - no open transaction in this
thread</p>
<!-- INDENTATION -->
<p><b>TX_STAGE_WORK</b> - transaction in progress</p>
<!-- INDENTATION -->
<p><b>TX_STAGE_ONCOMMIT</b> - successfully committed</p>
<!-- INDENTATION -->
<p><b>TX_STAGE_ONABORT</b> - starting the transaction failed
or transaction aborted</p>
<!-- INDENTATION -->
<p><b>TX_STAGE_FINALLY</b> - ready for clean up</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_tx_begin(PMEMobjpool *</b><i>pop</i><b>,
jmp_buf *</b><i>env</i><b>,</b> <i>...</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_tx_begin</b>() function starts a new
transaction in the current thread. If called within an open
transaction, it starts a nested transaction. The caller may
use <i>env</i> argument to provide a pointer to the
information of a calling environment to be restored in case
of transaction abort. This information must be filled by a
caller, using <b>setjmp</b>(3) macro.</p>
<!-- INDENTATION -->
<p>Optionally, a list of pmem-resident locks may be provided
as the last arguments. Each lock is specified by a pair of
lock type ( <i>TX_LOCK_MUTEX</i> or <i>TX_LOCK_RWLOCK</i>)
and the pointer to the lock of type <i>PMEMmutex</i> or
<i>PMEMrwlock</i> respectively. The list must be terminated
with <i>TX_LOCK_NONE</i>. In case of rwlocks, a write lock
is acquired. It is guaranteed that <b>pmemobj_tx_begin</b>()
will grab all the locks prior to successful completion and
they will be held by the current thread until the
transaction is finished. Locks are taken in the order from
left to right. To avoid deadlocks, user must take care about
the proper order of locks.</p>
<!-- INDENTATION -->
<p>New transaction may be started only if the current stage
is <i>TX_STAGE_NONE</i> or <i>TX_STAGE_WORK</i>. If
successful, transaction stage changes to
<i>TX_STAGE_WORK</i> and function returns zero. Otherwise,
stage changes to <i>TX_STAGE_ONABORT</i> and an error number
is returned.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_tx_lock(enum tx_lock</b>
<i>lock_type</i><b>, void *</b><i>lockp</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_tx_lock</b>() function grabs a lock
pointed by <i>lockp</i> and adds it to the current
transaction. The lock type is specified by <i>lock_type</i>
( <i>TX_LOCK_MUTEX</i> or <i>TX_LOCK_RWLOCK</i> ) and the
pointer to the <i>lockp</i> of <i>PMEMmutex</i> or
<i>PMEMrwlock</i> type. If successful, <i>lockp</i> is added
to transaction, locked and function returns zero. Otherwise,
stage changes to <i>TX_STAGE_ONABORT</i> and an error number
is returned. In case of <i>PMEMrwlock lock_type</i> function
acquires a write lock. This function must be called during
<i>TX_STAGE_WORK</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void pmemobj_tx_abort(int</b>
<i>errnum</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_tx_abort</b>() aborts the current
transaction and causes transition to
<i>TX_STAGE_ONABORT</i>. This function must be called during
<i>TX_STAGE_WORK</i>. If the passed <i>errnum</i> is equal
to zero, it shall be set to <i>ECANCELED</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void pmemobj_tx_commit(void);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_tx_commit</b>() function commits the
current open transaction and causes transition to
<i>TX_STAGE_ONCOMMIT</i> stage. If called in context of the
outer-most transaction, all the changes may be considered as
durably written upon successful completion. This function
must be called during <i>TX_STAGE_WORK</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_tx_end(void);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_tx_end</b>() function performs a clean up
of a current transaction. If called in context of the
outer-most transaction, it releases all the locks acquired
by <b>pmemobj_tx_begin</b>() for outer and nested
transactions. Then it causes the transition to
<i>TX_STAGE_NONE</i>. In case of the nested transaction, it
returns to the context of the outer transaction with
<i>TX_STAGE_WORK</i> stage without releasing any locks. Must
always be called for each <b>pmemobj_tx_begin</b>(), even if
starting the transaction failed. This function must
<i>not</i> be called during <i>TX_STAGE_WORK</i>. If
transaction was successful, returns 0. Otherwise returns
error code set by <b>pmemobj_tx_abort</b>(). Note that
<b>pmemobj_tx_abort</b>() can be called internally by the
library.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_tx_errno(void);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_tx_errno</b>() function returns the error
code of the last transaction.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void pmemobj_tx_process(void);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_tx_process</b>() function performs the
actions associated with current stage of the transaction,
and makes the transition to the next stage. It must be
called in transaction. Current stage must always be obtained
by a call to <b>pmemobj_tx_stage</b>().</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_tx_add_range(PMEMoid</b> <i>oid</i><b>,
uint64_t</b> <i>off</i><b>, size_t</b>
<i>size</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_tx_add_range</b>() takes a
&quot;snapshot&quot; of the memory block of given
<i>size</i>, located at given offset <i>off</i> in the
object specified by <i>oid</i> and saves it to the undo log.
The application is then free to directly modify the object
in that memory range. In case of a failure or abort, all the
changes within this range will be rolled-back. The supplied
block of memory has to be within the pool registered in the
transaction. If successful, returns zero. Otherwise, state
changes to <i>TX_STAGE_ONABORT</i> and an error number is
returned. This function must be called during
<i>TX_STAGE_WORK</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_tx_add_range_direct(const void
*</b><i>ptr</i><b>, size_t</b> <i>size</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_tx_add_range_direct</b>() behaves the same
as <b>pmemobj_tx_add_range</b>() with the exception that it
operates on virtual memory addresses and not persistent
memory objects. It takes a &quot;snapshot&quot; of a
persistent memory block of given <i>size</i>, located at the
given address <i>ptr</i> in the virtual memory space and
saves it to the undo log. The application is then free to
directly modify the object in that memory range. In case of
a failure or abort, all the changes within this range will
be rolled-back. The supplied block of memory has to be
within the pool registered in the transaction. If
successful, returns zero. Otherwise, state changes to
<i>TX_STAGE_ONABORT</i> and an error number is returned.
This function must be called during
<i>TX_STAGE_WORK</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>PMEMoid pmemobj_tx_alloc(size_t</b> <i>size</i><b>,
uint64_t</b> <i>type_num</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_tx_alloc</b>() transactionally allocates a
new object of given <i>size</i> and <i>type_num</i>. In
contrast to the non-transactional allocations, the objects
are added to the internal object containers of given
<i>type_num</i> only after the transaction is committed,
making the objects visible to the <b>POBJ_FOREACH_*</b>
macros. If successful, returns a handle to the newly
allocated object. Otherwise, stage changes to
<i>TX_STAGE_ONABORT</i>, OID_NULL is returned, and errno is
set appropriately. If <i>size</i> equals 0, OID_NULL is
returned and errno is set appropriately. This function must
be called during <i>TX_STAGE_WORK</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>PMEMoid pmemobj_tx_zalloc(size_t</b> <i>size</i><b>,
uint64_t</b> <i>type_num</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The pmemobj_tx_zalloc () function transactionally
allocates new zeroed object of given <i>size</i> and
<i>type_num</i>. If successful, returns a handle to the
newly allocated object. Otherwise, stage changes to
<i>TX_STAGE_ONABORT</i>, OID_NULL is returned, and errno is
set appropriately. If <i>size</i> equals 0, OID_NULL is
returned and errno is set appropriately. This function must
be called during <i>TX_STAGE_WORK</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>PMEMoid pmemobj_tx_realloc(PMEMoid</b> <i>oid</i><b>,
size_t</b> <i>size</i><b>,<br>
uint64_t</b> <i>type_num</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_tx_realloc</b>() function transactionally
resizes an existing object to the given <i>size</i> and
changes its type to <i>type_num</i>. If <i>oid</i> is
OID_NULL, then the call is equivalent to
<b>pmemobj_tx_alloc(</b><i>pop</i><b>,</b>
<i>size</i><b>,</b> <i>type_num</i><b>).</b> If <i>size</i>
is equal to zero and <i>oid</i> is not OID_NULL, then the
call is equivalent to
<b>pmemobj_tx_free(</b><i>oid</i><b>).</b> If the new size
is larger than the old size, the added memory will
<i>not</i> be initialized. If successful, returns a handle
to the resized object. Otherwise, stage changes to
<i>TX_STAGE_ONABORT</i>, OID_NULL is returned, and errno is
set appropriately. Note that the object handle value may
change in result of reallocation. This function must be
called during <i>TX_STAGE_WORK</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>PMEMoid pmemobj_tx_zrealloc(PMEMoid</b> <i>oid</i><b>,
size_t</b> <i>size</i><b>,<br>
uint64_t</b> <i>type_num</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_tx_zrealloc</b>() function transactionally
resizes an existing object to the given <i>size</i> and
changes its type to <i>type_num</i>. If the new size is
larger than the old size, the extended new space is zeroed.
If successful, returns a handle to the resized object.
Otherwise, stage changes to <i>TX_STAGE_ONABORT</i>,
OID_NULL is returned, and errno is set appropriately. Note
that the object handle value may change in result of
reallocation. This function must be called during
<i>TX_STAGE_WORK</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>PMEMoid pmemobj_tx_strdup(const char *</b><i>s</i><b>,
uint64_t</b> <i>type_num</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_tx_strdup</b>() function transactionally
allocates a new object containing a duplicate of the string
<i>s</i> and assigns it a type <i>type_num</i>. If
successful, returns a handle to the newly allocated object.
Otherwise, stage changes to <i>TX_STAGE_ONABORT</i>,
OID_NULL is returned, and errno is set appropriately. This
function must be called during <i>TX_STAGE_WORK</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_tx_free(PMEMoid</b>
<i>oid</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_tx_free</b>() function transactionally
frees an existing object referenced by <i>oid</i>. If
successful, returns zero. Otherwise, stage changes to
<i>TX_STAGE_ONABORT</i> and an error number is returned.
This function must be called during
<i>TX_STAGE_WORK</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>In addition to the above API, the <b>libpmemobj</b>
offers a more intuitive method of building transactions
using a set of macros described below. When using macros,
the complete transaction flow looks like this:</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<pre>TX_BEGIN(Pop) {
</pre>
</td>
</table>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>/* the actual transaction code goes here... */</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>} TX_ONCOMMIT {</p></td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>/*</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>* optional - executed only if the above block</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>* successfully completes</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>*/</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>} TX_ONABORT {</p></td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>/*</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>* optional - executed only if starting the transaction
fails,</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>* or if transaction is aborted by an error or a call
to</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>* pmemobj_tx_abort()</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>*/</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>} TX_FINALLY {</p></td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>/*</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>* optional - if exists, it is executed after</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>* TX_ONCOMMIT or TX_ONABORT block</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>*/</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>} TX_END /* mandatory */</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TX_BEGIN_LOCK(PMEMobjpool *</b><i>pop</i><b>,</b>
<i>...</i><b>)</b></p>
<!-- INDENTATION -->
<p><b>TX_BEGIN(PMEMobjpool *</b><i>pop</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TX_BEGIN_LOCK</b>() and <b>TX_BEGIN</b>() macros
start a new transaction in the same way as
<b>pmemobj_tx_begin</b>(), except that instead of the
environment buffer provided by a caller, they set up the
local <i>jmp_buf</i> buffer and use it to catch the
transaction abort. The <b>TX_BEGIN</b>() macro may be used
in case when there is no need to grab any locks prior to
starting a transaction (like for a single-threaded program).
Each of those macros shall be followed by a block of code
with all the operations that are to be performed
atomically.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TX_ONABORT</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TX_ONABORT</b> macro starts a block of code that
will be executed only if starting the transaction fails due
to an error in <b>pmemobj_tx_begin</b>(), or if the
transaction is aborted. This block is optional, but in
practice it should not be omitted. If it&rsquo;s desirable
to crash the application when transaction aborts and
there&rsquo;s no <b>TX_ONABORT</b> section, application can
define <b>POBJ_TX_CRASH_ON_NO_ONABORT</b> macro before
inclusion of <b>&lt;libpmemobj.h&gt;</b>. It provides
default <b>TX_ONABORT</b> section which just calls
<b>abort</b>(3).</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TX_ONCOMMIT</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TX_ONCOMMIT</b> macro starts a block of code that
will be executed only if the transaction is successfully
committed, which means that the execution of code in
<b>TX_BEGIN</b> block has not been interrupted by an error
or by a call to <b>pmemobj_tx_abort</b>(). This block is
optional.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TX_FINALLY</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TX_FINALLY</b> macro starts a block of code that
will be executed regardless of whether the transaction is
committed or aborted. This block is optional.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TX_END</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TX_END</b> macro cleans up and closes the
transaction started by <b>TX_BEGIN</b>() or
<b>TX_BEGIN_LOCK</b>() macro. It is mandatory to terminate
each transaction with this macro. If the transaction was
aborted, errno is set appropriately.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Similarly to the macros controlling the transaction flow,
the <b>libpmemobj</b> defines a set of macros that simplify
the transactional operations on persistent objects. Note
that those macros operate on typed object handles, thus
eliminating the need to specify the size of the object, or
the size and offset of the field in the user-defined
structure that is to be modified.</p>
<!-- INDENTATION -->
<p><b>TX_ADD_FIELD(TOID</b> <i>o</i><b>,</b>
<i>FIELD</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TX_ADD_FIELD</b>() macro saves in the undo log the
current value of given <i>FIELD</i> of the object referenced
by a handle <i>o</i>. The application is then free to
directly modify the specified <i>FIELD</i>. In case of a
failure or abort, the saved value will be restored.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TX_ADD(TOID</b> <i>o</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TX_ADD</b>() macro takes a &quot;snapshot&quot; of
the entire object referenced by object handle <i>o</i> and
saves it in the undo log. The object size is determined from
its <i>TYPE</i>. The application is then free to directly
modify the object. In case of a failure or abort, all the
changes within the object will be rolled-back.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TX_ADD_FIELD_DIRECT(TYPE *</b><i>p</i><b>,</b>
<i>FIELD</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TX_ADD_FIELD_DIRECT</b>() macro saves in the undo
log the current value of given <i>FIELD</i> of the object
referenced by (direct) pointer <i>p</i>. The application is
then free to directly modify the specified <i>FIELD</i>. In
case of a failure or abort, the saved value will be
restored.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TX_ADD_DIRECT(TYPE *</b><i>p</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TX_ADD_DIRECT</b>() macro takes a
&quot;snapshot&quot; of the entire object referenced by
(direct) pointer <i>p</i> and saves it in the undo log. The
object size is determined from its <i>TYPE</i>. The
application is then free to directly modify the object. In
case of a failure or abort, all the changes within the
object will be rolled-back.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TX_SET(TOID</b> <i>o</i><b>,</b> <i>FIELD</i><b>,</b>
<i>VALUE</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TX_SET</b> macro saves in the undo log the current
value of given <i>FIELD</i> of the object referenced by a
handle <i>o</i>, and then set its new <i>VALUE</i>. In case
of a failure or abort, the saved value will be restored.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TX_SET_DIRECT(TYPE *</b><i>p</i><b>,</b>
<i>FIELD</i><b>,</b> <i>VALUE</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TX_SET_DIRECT</b> macro saves in the undo log the
current value of given <i>FIELD</i> of the object referenced
by (direct) pointer <i>p</i>, and then set its new
<i>VALUE</i>. In case of a failure or abort, the saved value
will be restored.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TX_MEMCPY(void *</b><i>dest</i><b>, const void
*</b><i>src</i><b>, size_t</b> <i>num</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TX_MEMCPY</b> macro saves in the undo log the
current content of <i>dest</i> buffer and then overwrites
the first <i>num</i> bytes of its memory area with the data
copied from the buffer pointed by <i>src</i>. In case of a
failure or abort, the saved value will be restored.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TX_MEMSET(void *</b><i>dest</i><b>, int</b>
<i>c</i><b>, size_t</b> <i>num</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TX_MEMSET</b> macro saves in the undo log the
current content of <i>dest</i> buffer and then fills the
first <i>num</i> bytes of its memory area with the constant
byte <i>c</i>. In case of a failure or abort, the saved
value will be restored.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TX_NEW(</b><i>TYPE</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TX_NEW</b>() macro transactionally allocates a new
object of given <i>TYPE</i> and assigns it a type number
read from the typed OID. The allocation size is determined
from the size of the user-defined structure <i>TYPE</i>. If
successful and called during <i>TX_STAGE_WORK</i> it returns
a handle to the newly allocated object. Otherwise, stage
changes to <i>TX_STAGE_ONABORT</i>, OID_NULL is returned,
and errno is set appropriately.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TX_ALLOC(</b><i>TYPE</i><b>, size_t</b>
<i>size</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TX_ALLOC</b>() macro transactionally allocates a
new object of given <i>TYPE</i> and assigns it a type number
read from the typed OID. The allocation size is passed by
<i>size</i> parameter. If successful and called during
<i>TX_STAGE_WORK</i> it returns a handle to the newly
allocated object. Otherwise, stage changes to
<i>TX_STAGE_ONABORT</i>, OID_NULL is returned, and errno is
set appropriately.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TX_ZNEW(</b><i>TYPE</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TX_ZNEW</b>() macro transactionally allocates a
new zeroed object of given <i>TYPE</i> and assigns it a type
number read from the typed OID. The allocation size is
determined from the size of the user-defined structure
<i>TYPE</i>. If successful and called during
<i>TX_STAGE_WORK</i> it returns a handle to the newly
allocated object. Otherwise, stage changes to
<i>TX_STAGE_ONABORT</i>, OID_NULL is returned, and errno is
set appropriately.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TX_ZALLOC(</b><i>TYPE</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TX_ZALLOC</b>() macro transactionally allocates a
new zeroed object of given <i>TYPE</i> and assigns it a type
number read from the typed OID. The allocation size is
passed by <i>size</i> argument. If successful and called
during <i>TX_STAGE_WORK</i> it returns a handle to the newly
allocated object. Otherwise, stage changes to
<i>TX_STAGE_ONABORT</i>, OID_NULL is returned, and errno is
set appropriately.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TX_REALLOC(TOID</b> <i>o</i><b>, size_t</b>
<i>size</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TX_REALLOC</b>() macro transactionally resizes an
existing object referenced by a handle <i>o</i> to the given
<i>size</i>. If successful and called during
<i>TX_STAGE_WORK</i> it returns a handle to the reallocated
object. Otherwise, stage changes to <i>TX_STAGE_ONABORT</i>,
OID_NULL is returned, and errno is set appropriately.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TX_ZREALLOC(TOID</b> <i>o</i><b>, size_t</b>
<i>size</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TX_ZREALLOC</b>() macro transactionally resizes an
existing object referenced by a handle <i>o</i> to the given
<i>size</i>. If the new size is larger than the old size,
the extended new space is zeroed. If successful and called
during <i>TX_STAGE_WORK</i> it returns a handle to the
reallocated object. Otherwise, stage changes to
<i>TX_STAGE_ONABORT</i>, OID_NULL is returned, and errno is
set appropriately.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TX_STRDUP(const char *</b><i>s</i><b>, uint64_t</b>
<i>type_num</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TX_STRDUP</b>() macro transactionally allocates a
new object containing a duplicate of the string <i>s</i> and
assigns it a type <i>type_num</i>. If successful and called
during <i>TX_STAGE_WORK</i> it returns a handle to the newly
allocated object. Otherwise, stage changes to
<i>TX_STAGE_ONABORT</i>, OID_NULL is returned, and errno is
set appropriately.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>TX_FREE(TOID</b> <i>o</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>TX_FREE</b>() transactionally frees the memory
space represented by an object handle <i>o</i>. If <i>o</i>
is OID_NULL, no operation is performed. If successful and
called during <i>TX_STAGE_WORK</i> it returns zero.
Otherwise, stage changes to <i>TX_STAGE_ONABORT</i> and an
error number is returned.</p>
</td>
</table>
<a name="CAVEATS"></a>
<h2>CAVEATS</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The transaction flow control is governed by the
<b>setjmp</b>(3)/<b>longjmp</b>(3) macros and they are used
in both the macro and function flavors of the API. The
transaction will longjmp on transaction abort. This has one
major drawback which is described in the ISO C standard
subsection 7.13.2.1. It says that <b>the values of objects
of automatic storage duration that are local to the function
containing the setjmp invocation that do not have
volatile-qualified type and have been changed between the
setjmp invocation and longjmp call are
indeterminate.</b></p>
<!-- INDENTATION -->
<p>The following example illustrates the issue described
above.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<pre>int *bad_example_1 = NULL;
int *bad_example_2 = NULL;
int *bad_example_3 = NULL;
volatile int *good_example = NULL;

TX_BEGIN(Pop) {
        bad_example_1 = malloc(...);
        bad_example_2 = malloc(...);
        bad_example_3 = malloc(...);
        good_example = malloc(...);
        ...
        pmemobj_tx_abort(EINVAL); /* manual or library abort called here */
} TX_ONCOMMIT {
        /*
         * This section is longjmp-safe
         */
} TX_ONABORT {
        /*
         * This section is not longjmp-safe
         */

        free(bad_example_1); /* undefined behavior */
         free(good_example); /* OK */
} TX_FINALLY {
        /*
         * This section is not longjmp-safe on transaction abort only
         */

        free(bad_example_2); /* undefined behavior */
} TX_END

free(bad_example_3); /* undefined behavior */
</pre>
</td>
</table>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Objects which are not volatile-qualified, are of
automatic storage duration and have been changed between the
invocations of <b>setjmp</b>(3) and <b>longjmp</b>(3) (that
also means within the work section of the transaction after
TX_BEGIN) should not be used after a transaction abort or
should be used with utmost care. This also includes code
after the <b>TX_END</b> macro.</p>
<!-- INDENTATION -->
<p><b>Libpmemobj</b> is not cancellation-safe. The pool will
never be corrupted because of canceled thread, but other
threads may stall waiting on locks taken by that thread. If
application wants to use <b>pthread_cancel</b>(3), it must
disable cancellation before calling <b>libpmemobj</b> APIs
(see <b>pthread_setcancelstate</b>(3) with
<b>PTHREAD_CANCEL_DISABLE</b>) and re-enable it after.
Deferring cancellation ( <b>pthread_setcanceltype</b>(3)
with <b>PTHREAD_CANCEL_DEFERRED</b>) is not safe enough,
because <b>libpmemobj</b> internally may call functions that
are specified as cancellation points in POSIX API.</p>
</td>
</table>
<a name="LIBRARY API VERSIONING"></a>
<h2>LIBRARY API VERSIONING</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>This section describes how the library API is versioned,
allowing applications to work with an evolving API.</p>
<!-- INDENTATION -->
<p><b>const char *pmemobj_check_version(<br>
unsigned</b> <i>major_required</i><b>,<br>
unsigned</b> <i>minor_required</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_check_version</b>() function is used to
see if the installed <b>libpmemobj</b> supports the version
of the library API required by an application. The easiest
way to do this is for the application to supply the
compile-time version information, supplied by defines in
<b>&lt;libpmemobj.h&gt;</b>, like this:</p>
<!-- INDENTATION -->
<pre>reason = pmemobj_check_version(PMEMOBJ_MAJOR_VERSION,
                            PMEMOBJ_MINOR_VERSION);
if (reason != NULL) {
    /*  version check failed, reason string tells you why */
}
</pre>
<!-- INDENTATION -->
<p>Any mismatch in the major version number is considered a
failure, but a library with a newer minor version number
will pass this check since increasing minor versions imply
backwards compatibility.</p>
<!-- INDENTATION -->
<p>An application can also check specifically for the
existence of an interface by checking for the version where
that interface was introduced. These versions are documented
in this man page as follows: unless otherwise specified, all
interfaces described here are available in version 1.0 of
the library. Interfaces added after version 1.0 will contain
the text <i>introduced in version x.y</i> in the section of
this manual describing the feature.</p>
<!-- INDENTATION -->
<p>When the version check performed by
<b>pmemobj_check_version</b>() is successful, the return
value is NULL. Otherwise the return value is a static string
describing the reason for failing the version check. The
string returned by <b>pmemobj_check_version</b>() must not
be modified or freed.</p>
</td>
</table>
<a name="MANAGING LIBRARY BEHAVIOR"></a>
<h2>MANAGING LIBRARY BEHAVIOR</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The library entry points described in this section are
less commonly used than the previous sections.</p>
<!-- INDENTATION -->
<p><b>void pmemobj_set_funcs(<br>
void *(*</b><i>malloc_func</i><b>)(size_t</b>
<i>size</i><b>),<br>
void (*</b><i>free_func</i><b>)(void
*</b><i>ptr</i><b>),<br>
void *(*</b><i>realloc_func</i><b>)(void *</b><i>ptr</i><b>,
size_t</b> <i>size</i><b>),<br>
char *(*</b><i>strdup_func</i><b>)(const char
*</b><i>s</i><b>));</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_set_funcs</b>() function allows an
application to override memory allocation calls used
internally by <b>libpmemobj</b>. Passing in NULL for any of
the handlers will cause the <b>libpmemobj</b> default
function to be used. The library does not make heavy use of
the system malloc functions, but it does allocate
approximately 4-8 kilobytes for each memory pool in use.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmemobj_check(const char *</b><i>path</i><b>,
const char *</b><i>layout</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_check</b>() function performs a
consistency check of the file indicated by <i>path</i> and
returns 1 if the memory pool is found to be consistent. Any
inconsistencies found will cause <b>pmemobj_check</b>() to
return 0, in which case the use of the file with
<b>libpmemobj</b> will result in undefined behavior. The
debug version of <b>libpmemobj</b> will provide additional
details on inconsistencies when <b>PMEMOBJ_LOG_LEVEL</b> is
at least 1, as described in the <b>DEBUGGING AND ERROR
HANDLING</b> section below. <b>pmemobj_check</b>() will
return -1 and set errno if it cannot perform the consistency
check due to other errors. <b>pmemobj_check</b>() opens the
given <i>path</i> read-only so it never makes any changes to
the file.</p>
</td>
</table>
<a name="DEBUGGING AND ERROR HANDLING"></a>
<h2>DEBUGGING AND ERROR HANDLING</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Two versions of <b>libpmemobj</b> are typically available
on a development system. The normal version, accessed when a
program is linked using the <b>-lpmemobj</b> option, is
optimized for performance. That version skips checks that
impact performance and never logs any trace information or
performs any run-time assertions. If an error is detected
during the call to <b>libpmemobj</b> function, an
application may retrieve an error message describing the
reason of failure using the following function:</p>
<!-- INDENTATION -->
<p><b>const char *pmemobj_errormsg(void);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmemobj_errormsg</b>() function returns a pointer
to a static buffer containing the last error message logged
for current thread. The error message may include
description of the corresponding error code (if errno was
set), as returned by <b>strerror</b>(3). The error message
buffer is thread-local; errors encountered in one thread do
not affect its value in other threads. The buffer is never
cleared by any library function; its content is significant
only when the return value of the immediately preceding call
to <b>libpmemobj</b> function indicated an error, or if
errno was set. The application must not modify or free the
error message string, but it may be modified by subsequent
calls to other library functions.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>A second version of <b>libpmemobj</b>, accessed when a
program uses the libraries under <b>/usr/lib/nvml_debug</b>,
contains run-time assertions and trace points. The typical
way to access the debug version is to set the environment
variable <b>LD_LIBRARY_PATH</b> to
<b>/usr/lib/nvml_debug</b> or <b>/usr/lib64/nvml_debug</b>
depending on where the debug libraries are installed on the
system. The trace points in the debug version of the library
are enabled using the environment variable
<b>PMEMOBJ_LOG_LEVEL</b>, which can be set to the following
values:</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="2%">

<p>0</p>
</td>
<td width="7%"></td>
<td width="77%">

<p>This is the default level when <b>PMEMOBJ_LOG_LEVEL</b>
is not set. No log messages are emitted at this level.</p>
</td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="2%">

<p>1</p>
</td>
<td width="7%"></td>
<td width="77%">

<p>Additional details on any errors detected are logged (in
addition to returning the errno-based errors as usual). The
same information may be retrieved using
<b>pmemobj_errormsg</b>().</p>
</td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="2%">

<p>2</p>
</td>
<td width="7%"></td>
<td width="77%">

<p>A trace of basic operations is logged.</p>
</td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="2%">

<p>3</p>
</td>
<td width="7%"></td>
<td width="77%">

<p>This level enables a very verbose amount of function
call tracing in the library.</p>
</td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="2%">

<p>4</p>
</td>
<td width="7%"></td>
<td width="77%">

<p>This level enables voluminous and fairly obscure tracing
information that is likely only useful to the
<b>libpmemobj</b> developers.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The environment variable <b>PMEMOBJ_LOG_FILE</b>
specifies a file name where all logging information should
be written. If the last character in the name is
&quot;-&quot;, the PID of the current process will be
appended to the file name when the log file is created. If
<b>PMEMOBJ_LOG_FILE</b> is not set, the logging output goes
to stderr.</p>
<!-- INDENTATION -->
<p>Setting the environment variable <b>PMEMOBJ_LOG_LEVEL</b>
has no effect on the non-debug version of
<b>libpmemobj</b>.</p>
<!-- INDENTATION -->
<p>See also <b>libpmem</b>(3) to get information about other
environment variables affecting <b>libpmemobj</b>
behavior.</p>
</td>
</table>
<a name="EXAMPLES"></a>
<h2>EXAMPLES</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>See http://pmem.io/nvml/libpmemobj for examples using the
<b>libpmemobj</b> API.</p>
</td>
</table>
<a name="ACKNOWLEDGEMENTS"></a>
<h2>ACKNOWLEDGEMENTS</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>libpmemobj</b> builds on the persistent memory
programming model recommended by the SNIA NVM Programming
Technical Work Group:</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>http://snia.org/nvmp</p>
</td>
</table>
<a name="SEE ALSO"></a>
<h2>SEE ALSO</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>mmap</b>(2), <b>munmap</b>(2), <b>msync</b>(2),
<b>pthread_mutex</b>(3), <b>pthread_rwlock</b>(3),
<b>pthread_cond</b>(3), <b>strerror</b>(3),
<b>libpmemblk</b>(3), <b>libpmemlog</b>(3),
<b>libpmem</b>(3), <b>libvmem</b>(3) and
<b>http://pmem.io</b>.</p>
</td>
</table>
<hr>
</body>
</html>
