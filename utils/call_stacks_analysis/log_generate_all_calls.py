#!/usr/bin/env python3

import subprocess
import json
import re

from typing import List, Dict, Any

TOP = '../../'
OUTPUT_PATH = TOP + 'src/test/core_log/'
OUTPUT_C = OUTPUT_PATH + 'all_calls.c'
OUTPUT_H = OUTPUT_PATH + 'all_calls.h'

NOTICE = """/*
 * This file is automatically generated by utils/call_stack_analysis/log_generate_all_calls.py.
 * Please do not modify manually.
 */"""

C_PREFIX = f"""// SPDX-License-Identifier: BSD-3-Clause
/* Copyright 2024, Intel Corporation */

{NOTICE}

#include <limits.h>
#include <inttypes.h>
#include <libpmempool.h>
#include <libpmemobj.h>
#include <libpmem2.h>

#include "log_internal.h"
#include "all_calls.h"
#include "pool_hdr.h"

#define PATH "XXX"

static char *path = PATH;
static char *path1 = PATH;
static char *path2 = PATH;
static char *spath = PATH;
static char *file = PATH;
static char *directory = PATH;
static char *device_path = PATH;
static char *region_path = PATH;
static char *direpname = PATH;
static char *qbuf = PATH;
static char *name = PATH;
static char *pathp = PATH;
static char *Mmap_mapfile = "/proc/self/maps";
static size_t len = SIZE_MAX;
static size_t size = SIZE_MAX;
static unsigned r = UINT_MAX; /* set->nreplicas */
static unsigned repn = UINT_MAX;
static unsigned p = UINT_MAX; /* rep->nparts */
static unsigned partn = UINT_MAX;
static int fd = INT_MAX;
static int domain_fd = INT_MAX;

#define DOMAIN_VALUE_LEN 32
char domain_value[DOMAIN_VALUE_LEN] = PATH;

static uint32_t incompat = UINT32_MAX;
static uint32_t ro_compat = UINT32_MAX;
static uint32_t major = UINT32_MAX;

static char signature[POOL_HDR_SIG_LEN] = PATH;
static unsigned nlines = UINT_MAX;

#define SHORT_STR_LENGTH 50

static char parser_errstr[SHORT_STR_LENGTH] = "incorrect descriptor (must be a relative path)";
static unsigned repidx = UINT_MAX;
static unsigned options = UINT_MAX;

#define ERR_MSG_BB \\
	"       please read the manual first and use this option\\n"\\
	"       ONLY IF you are sure that you know what you are doing"

static enum pmempool_pool_type check_pool_type = PMEMPOOL_POOL_TYPE_RESERVED4;

#define FEATURE_IS_NOT_ENABLED_PRIOR_STR	"enable %s prior to %s %s"
#define FEATURE_IS_NOT_DISABLED_PRIOR_STR	"disable %s prior to %s %s"

static uint32_t feature = UINT32_MAX;
static uint32_t question = UINT32_MAX;

static char *OBJ_NLANES_ENV_VARIABLE = "PMEMOBJ_NLANES";
static char layout[PMEMOBJ_MAX_LAYOUT] = PATH;

static uint64_t heap_offset = UINT64_MAX;
static uint64_t run_id = UINT64_MAX;

static int ret = INT_MAX;
static int flags = INT_MAX;

static ssize_t actual_len = SSIZE_MAX;

static unsigned major_required = UINT_MAX;
static unsigned minor_required = UINT_MAX;

static uint64_t flags64 = UINT64_MAX;

uint8_t aclass_id = UINT8_MAX;

static unsigned narenas = UINT_MAX;

static uint64_t ptr = UINT64_MAX;
static uint64_t addr = UINT64_MAX;
static uint64_t rsv = UINT64_MAX;
static uint64_t reserv_region = UINT64_MAX;
static uint64_t map = UINT64_MAX;

static size_t alignment = SIZE_MAX;
static size_t reserv_offset = SIZE_MAX;
static size_t offset = SIZE_MAX;
static size_t max_size = SIZE_MAX;

static unsigned prot = UINT_MAX;

static enum pmem2_sharing_type type = (enum pmem2_sharing_type)UINT64_MAX;
static enum pmem2_granularity g = (enum pmem2_granularity)UINT64_MAX;

static uint32_t st_mode = UINT32_MAX;

static size_t rsv_offset = SIZE_MAX;

static uint64_t length = UINT64_MAX;
static uint64_t reserved_length = UINT64_MAX;

static __off_t st_size = INT64_MAX;

#define SYSFS_ATTR_SIZE 1024

static char ndctl_bus[SYSFS_ATTR_SIZE] = PATH;

"""

C_FUNCTION_W_ERRNUM_PREFIX = """void
call_all_{}(int errnum)
{{
"""

C_FUNCTION_PREFIX = """void
call_all_{}(void)
{{
"""

C_FUNCTION_SUFFIX = """
}

"""

H_PREFIX = f"""/* SPDX-License-Identifier: BSD-3-Clause */
/* Copyright 2024, Intel Corporation */

{NOTICE}

/*
 * all_calls.h -- internal logging interfaces
 */

#ifndef ALL_CALLS_H
#define ALL_CALLS_H

"""

H_SUFFIX = """
#endif /* ALL_CALLS_H */
"""

H_FUNCTION_W_ERRNUM = """void call_all_{}(int errnum);
"""

H_FUNCTION = """void call_all_{}(void);
"""

THE_LONGEST_FU_ERR = "requested granularity not available because fd doesn't point to DAX-enabled file or kernel doesn't support MAP_SYNC flag (Linux >= 4.15)"

STR_REPLACE = {
    'rep->part[p].path': 'path',
    'part->path': 'path',
    'part->fd': 'fd',
    'part_hs->recovery_file_name': 'path',
    'phs->recovery_file_name': 'path',
    'unknown.incompat': 'incompat',
    'unknown.ro_compat': 'ro_compat',
    'dest_size': 'size',
    'actual_size': 'size',
    'minsize': 'size',
    'part->filesize': 'size',
    'pf->path': 'path',
    'attr->major': 'major',
    'hdr.major': 'major',
    'hdr.signature': 'signature',
    'parser_errstr[result]': 'parser_errstr',
    'd->path': 'path',
    'entry->path': 'path',
    'PART(repr, p)->path': 'path',
    'PART(REP(set, src_repn), 0)->path': 'path',
    'rep->part[p].map_sync ? "" : "not"': '"not"',
    'rep->part[p].hdr_map_sync ? "" : "not"': '"not"',
    'set->options': 'options',
    'set->resvsize': 'size',
    'set->poolsize': 'size',
    'src_repn': 'repn',
    'r_n': 'repn',
    'r_h': 'repn',
    'unbroken_p': 'partn',
    'part_stored': 'partn',
    'pool_get_pool_type_str(ptype)': '"pmemobj"',
    'util_feature2str(feature, NULL)': '"CHECK_BAD_BLOCKS"',
    'util_feature2str(other, NULL)': '"CHECK_BAD_BLOCKS"',
    'cause': '"disabling"',
    'msg': '"{compat 0xFFFFFF, incompat 0xFFFFFF, ro_compat 0xFFFFFF} != {compat 0xFFFFFF, incompat 0xFFFFFF, ro_compat 0xFFFFFF}"',
    'pop->layout': 'layout',
    'pop->heap_offset': 'heap_offset',
    'pop->run_id': 'run_id',
    'aclass->id': 'aclass_id',
    'c->id': 'aclass_id',
    'st->st_mode & S_IFMT': 'st_mode',
    'length - cleared': 'length',
    'PMEM_MAJOR_VERSION': '1',
    'PMEM_MINOR_VERSION': '1',
    'flags & ~POBJ_ACTION_XRESERVE_VALID_FLAGS': 'flags64',
    'flags & ~POBJ_TX_XALLOC_VALID_FLAGS': 'flags64',
    'flags & ~POBJ_XLOG_APPEND_BUFFER_VALID_FLAGS': 'flags64',
    'flags & ~POBJ_XPUBLISH_VALID_FLAGS': 'flags64',
    'flags & ~(POBJ_TX_XALLOC_VALID_FLAGS)': 'flags64',
    'flags & ~POBJ_XFREE_VALID_FLAGS': 'flags64',
    'flags & ~POBJ_XADD_VALID_FLAGS': 'flags64',
    'flags & ~POBJ_XLOCK_VALID_FLAGS': 'flags64',
    'st.st_size': 'st_size',
    '*alignment': 'alignment',
    'ndctl_bus_get_provider(bus)': 'ndctl_bus',
    'ERR_WO_ERRNO("%s", err);': f'ERR_WO_ERRNO("{THE_LONGEST_FU_ERR}");'
}

def dump(var, name: str) -> None:
        with open(f'{name}.json', 'w') as outfile:
                json.dump(var, outfile, indent = 4)

def bad_line(reason: str, line: str) -> None:
    print(f'{reason}: {line}')
    exit(1)

def append_code(file_name: str, start_line: int, code: str) -> str:
    if not re.search(f'\.[ch]$', file_name):
        print(f'Unsupported file type: {file_name}')
        exit(1)
    
    with open(TOP + file_name, 'r') as file:
        # skip to the line
        for _ in range(0, start_line):
            file.readline()
        # look up for the end of the statement
        while True:
            line = file.readline()
            line = line.strip()
            code += " " + line
            if code[-1] == ';':
                break
            if re.search(f'(//|/\*)', code):
                bad_line('Comment found', code)
    return code

def code_patch(code: str) -> str:
    for old, new in STR_REPLACE.items():
        if old in code:
            code = code.replace(old, new)
    return code

def grep(func: str) -> List[Dict]:
    cmd = f'cd {TOP}; grep -Irn {func}'
    returned_output = subprocess.check_output(cmd, shell=True)
    string = returned_output.decode("utf-8")
    calls = []
    for line in string.splitlines():
        found = re.search(f'([a-zA-Z0-9_/.]+):([0-9]+):[ \t]*(.+)', line)
        if found:
            file = found.group(1)
            line_no = found.group(2)
            code = found.group(3)
            # Filter out known odd occurrences.
            if file == 'src/core/log_internal.h' or file.startswith('utils/') or file.startswith('src/test/core_log/'):
                continue
            if not code.startswith(func):
                bad_line(f'Does not start with "{func}"', line)
            # You won't belive what src/libpmempool/rm.c could do with the
            # logging functions.
            if '__VA_ARGS__' in code:
                continue
            if code[-1] != ';':
                code = append_code(file, int(line_no), code)
            code = code_patch(code)
            call = {
                'file': file,
                'line': line_no,
                'code': code
            }
            calls.append(call)
        else:
            bad_line('An unexpected line format', line)
    return calls

def init_source_files():
    with open(OUTPUT_C, 'w') as file:
        file.write(C_PREFIX)   
    with open(OUTPUT_H, 'w') as file:
        file.write(H_PREFIX)

def fini_source_files():
    with open(OUTPUT_H, 'a') as file:
        file.write(H_SUFFIX)

def generate_func_with_errno(func: str, calls: List[Dict]) -> None:
    with open(OUTPUT_C, 'a') as file:
        file.write(C_FUNCTION_W_ERRNUM_PREFIX.format(func))
        for call in calls:
            file.write(f'\t// {call["file"]}:{call["line"]}\n')
            file.write('\terrno = errnum;\n')
            file.write(f'\t{call["code"]}\n')
        file.write(C_FUNCTION_SUFFIX)
    
    with open(OUTPUT_H, 'a') as file:
        file.write(H_FUNCTION_W_ERRNUM.format(func))

def generate_func(func: str, calls: List[Dict]) -> None:
    with open(OUTPUT_C, 'a') as file:
        file.write(C_FUNCTION_PREFIX.format(func))
        for call in calls:
            file.write(f'\t// {call["file"]}:{call["line"]}\n')
            file.write(f'\t{call["code"]}\n')
        file.write(C_FUNCTION_SUFFIX)
    
    with open(OUTPUT_H, 'a') as file:
        file.write(H_FUNCTION.format(func))

def main():
    init_source_files()

    for func in ['CORE_LOG_ERROR_LAST', 'ERR_WO_ERRNO']:
        calls = grep(func)
        generate_func(func, calls)

    for func in ['CORE_LOG_ERROR_W_ERRNO_LAST', 'ERR_W_ERRNO']:
        calls = grep(func)
        generate_func_with_errno(func, calls)

    fini_source_files()

if __name__ == '__main__':
    main()
