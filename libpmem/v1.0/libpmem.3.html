<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Mon May  9 10:52:58 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>libpmem</title>

</head>
<body>

<h1 align="center">libpmem</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#MOST COMMONLY USED FUNCTIONS">MOST COMMONLY USED FUNCTIONS</a><br>
<a href="#PARTIAL FLUSHING OPERATIONS">PARTIAL FLUSHING OPERATIONS</a><br>
<a href="#COPYING TO PERSISTENT MEMORY">COPYING TO PERSISTENT MEMORY</a><br>
<a href="#LIBRARY API VERSIONING">LIBRARY API VERSIONING</a><br>
<a href="#DEBUGGING AND ERROR HANDLING">DEBUGGING AND ERROR HANDLING</a><br>
<a href="#ENVIRONMENT VARIABLES">ENVIRONMENT VARIABLES</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">libpmem &minus;
persistent memory support library</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;libpmem.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>cc ...
-lpmem</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Most
commonly used functions:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmem_is_pmem(const void *</b><i>addr</i><b>, size_t</b>
<i>len</i><b>); <br>
void pmem_persist(const void *</b><i>addr</i><b>, size_t</b>
<i>len</i><b>); <br>
int pmem_msync(const void *</b><i>addr</i><b>, size_t</b>
<i>len</i><b>); <br>
void *pmem_map_file(const char *</b><i>path</i><b>,
size_t</b> <i>len</i><b>, int</b> <i>flags</i><b>, <br>
mode_t</b> <i>mode</i><b>, size_t
*</b><i>mapped_lenp</i><b>, int *</b><i>is_pmemp</i><b>);
<br>
int pmem_unmap(void *</b><i>addr</i><b>, size_t</b>
<i>len</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Partial
flushing operations:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pmem_flush(const void *</b><i>addr</i><b>, size_t</b>
<i>len</i><b>); <br>
void pmem_drain(void); <br>
int pmem_has_hw_drain(void);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Copying to
persistent memory:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
*pmem_memmove_persist(void *</b><i>pmemdest</i><b>, const
void *</b><i>src</i><b>, size_t</b> <i>len</i><b>); <br>
void *pmem_memcpy_persist(void *</b><i>pmemdest</i><b>,
const void *</b><i>src</i><b>, size_t</b> <i>len</i><b>);
<br>
void *pmem_memset_persist(void *</b><i>pmemdest</i><b>,
int</b> <i>c</i><b>, size_t</b> <i>len</i><b>); <br>
void *pmem_memmove_nodrain(void *</b><i>pmemdest</i><b>,
const void *</b><i>src</i><b>, size_t</b> <i>len</i><b>);
<br>
void *pmem_memcpy_nodrain(void *</b><i>pmemdest</i><b>,
const void *</b><i>src</i><b>, size_t</b> <i>len</i><b>);
<br>
void *pmem_memset_nodrain(void *</b><i>pmemdest</i><b>,
int</b> <i>c</i><b>, size_t</b> <i>len</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Library API
versioning:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>const char
*pmem_check_version( <br>
unsigned</b> <i>major_required</i><b>, <br>
unsigned</b> <i>minor_required</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Error
handling:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>const char
*pmem_errormsg(void);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>libpmem</b>
provides low-level <i>persistent memory</i> (pmem) support
for applications using direct access storage (DAX), which is
storage that supports load/store access without paging
blocks from a block storage device. Some types of
<i>non-volatile memory DIMMs</i> (NVDIMMs) provide this type
of byte addressable access to storage. A <i>persistent
memory aware file system</i> is typically used to expose the
direct access to applications. Memory mapping a file from
this type of file system results in the load/store,
non-paged access to pmem.</p>

<p style="margin-left:11%; margin-top: 1em">This library is
for applications that use persistent memory directly,
without the help of any library-supplied transactions or
memory allocation. Higher-level libraries that build on
<b>libpmem</b> are available and are recommended for most
applications, see:</p>


<p style="margin-left:22%; margin-top: 1em"><b>libpmemobj</b>(3),
a general use persistent memory API, providing memory
allocation and transactional operations on variable-sized
objects.</p>


<p style="margin-left:22%; margin-top: 1em"><b>libpmemblk</b>(3),
providing pmem-resident arrays of fixed-sized blocks with
atomic updates.</p>


<p style="margin-left:22%; margin-top: 1em"><b>libpmemlog</b>(3),
providing a pmem-resident log file.</p>

<p style="margin-left:11%; margin-top: 1em">Under normal
usage, <b>libpmem</b> will never print messages or
intentionally cause the process to exit. The only exception
to this is the debugging information, when enabled, as
described under <b>DEBUGGING AND ERROR HANDLING</b>
below.</p>

<h2>MOST COMMONLY USED FUNCTIONS
<a name="MOST COMMONLY USED FUNCTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Most pmem-aware
applications will take advantage of higher level libraries
that alleviate the application from calling into
<b>libpmem</b> directly. Application developers that wish to
access raw memory mapped persistence directly (via
<b>mmap</b>(2)) and that wish to take on the responsibility
for flushing stores to persistence will find the functions
described in this section to be the most commonly used.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmem_is_pmem(const void *</b><i>addr</i><b>, size_t</b>
<i>len</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmem_is_pmem</b>() function returns true only if the
entire range [<i>addr</i>, <i>addr</i>+<i>len</i>) consists
of persistent memory. A true return from
<b>pmem_is_pmem</b>() means it is safe to use
<b>pmem_persist</b>() and the related functions below to
make changes durable for that memory range.</p>

<p style="margin-left:22%; margin-top: 1em">The
implementation of <b>pmem_is_pmem</b>() requires a
non-trivial amount of work to determine if the given range
is entirely persistent memory. For this reason, it is better
to call <b>pmem_is_pmem</b>() once when a range of memory is
first encountered, save the result, and use the saved result
to determine whether <b>pmem_persist</b>() or
<b>msync</b>(2) is appropriate for flushing changes to
persistence. Calling <b>pmem_is_pmem</b>() each time changes
are flushed to persistence will not perform well.</p>

<p style="margin-left:22%; margin-top: 1em">WARNING: Using
<b>pmem_persist</b>() on a range where <b>pmem_is_pmem</b>()
returns false may not do anything useful -- use
<b>msync</b>(2) instead.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pmem_persist(const void *</b><i>addr</i><b>, size_t</b>
<i>len</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">Force any
changes in the range [<i>addr</i>, <i>addr</i>+<i>len</i>)
to be stored durably in persistent memory. This is
equivalent to calling <b>msync</b>(2) but may be more
optimal and will avoid calling into the kernel if possible.
There are no alignment restrictions on the range described
by <i>addr</i> and <i>len</i>, but <b>pmem_persist</b>() may
expand the range as necessary to meet platform alignment
requirements.</p>

<p style="margin-left:22%; margin-top: 1em">WARNING: Like
<b>msync</b>(2), there is nothing atomic or transactional
about this call. Any unwritten stores in the given range
will be written, but some stores may have already been
written by virtue of normal cache eviction/replacement
policies. Correctly written code must not depend on stores
waiting until <b>pmem_persist</b>() is called to become
persistent -- they can become persistent at any time before
<b>pmem_persist</b>() is called.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmem_msync(const void *</b><i>addr</i><b>, size_t</b>
<i>len</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The function
<b>pmem_msync</b>() is like <b>pmem_persist</b>() in that it
forces any changes in the range [<i>addr</i>,
<i>addr</i>+<i>len</i>) to be stored durably. Since it calls
<b>msync</b>(), this function works on either persistent
memory or a memory mapped file on traditional storage.
<b>pmem_msync</b>() takes steps to ensure the alignment of
addresses and lengths passed to <b>msync</b>() meet the
requirements of that system call. It calls <b>msync</b>()
with the <i>MS_SYNC</i> flag as described in
<b>msync</b>(2). Typically the application only checks for
the existence of persistent memory once, and then uses that
result throughout the program, for example:</p>

<p style="margin-left:22%; margin-top: 1em">/* do this call
once, after the pmem is memory mapped */ <br>
int is_pmem = pmem_is_pmem(rangeaddr, rangelen);</p>

<p style="margin-left:22%; margin-top: 1em">/* ... make
changes to a range of pmem ... */</p>

<p style="margin-left:22%; margin-top: 1em">/* make the
changes durable */ <br>
if (is_pmem) <br>
pmem_persist(subrangeaddr, subrangelen); <br>
else <br>
pmem_msync(subrangeaddr, subrangelen);</p>

<p style="margin-left:22%; margin-top: 1em">/* ... */</p>

<p style="margin-left:22%; margin-top: 1em">The return
value of <b>pmem_msync</b>() is the return value of
<b>msync</b>(), which can return -1 and set errno to
indicate an error.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
*pmem_map_file(const char *</b><i>path</i><b>, size_t</b>
<i>len</i><b>, int</b> <i>flags</i><b>, <br>
mode_t</b> <i>mode</i><b>, size_t
*</b><i>mapped_lenp</i><b>, int
*</b><i>is_pmemp</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">Given a
<i>path</i>, <b>pmem_map_file</b>() function creates a new
read/write mapping for the named file. It will map the file
using <b>mmap</b>(2), but it also takes extra steps to make
large page mappings more likely.</p>

<p style="margin-left:22%; margin-top: 1em">On success,
<b>pmem_map_file</b>() returns a pointer to mapped area. If
<i>mapped_lenp</i> is not NULL, the length of the mapping is
also stored at the address it points to. The <i>is_pmemp</i>
argument, if non-NULL, points to a flag that
<b>pmem_is_pmem</b>() sets to say if the mapped file is
actual pmem, or if <b>msync</b>() must be used to flush
writes for the mapped range. On error, NULL is returned,
errno is set appropriately, and <i>mapped_lenp</i> and
<i>is_pmemp</i> are left untouched.</p>

<p style="margin-left:22%; margin-top: 1em">The
<i>flags</i> argument can be 0 or bitwise OR of one or more
of the following file creation flags:</p>


<p style="margin-left:22%; margin-top: 1em"><b>PMEM_FILE_CREATE</b>
- Create the named file if it does not exist. <i>len</i>
must be non-zero and specifies the size of the file to be
created. <i>mode</i> has the same meaning as for
<b>open</b>(2) and specifies the mode to use in case a new
file is created. If neither <b>PMEM_FILE_CREATE</b> nor
<b>PMEM_FILE_TMPFILE</b> is specified, then <i>mode</i> is
ignored.</p>


<p style="margin-left:22%; margin-top: 1em"><b>PMEM_FILE_EXCL</b>
- Same meaning as <b>O_EXCL</b> on <b>open</b>(2) - Ensure
that this call creates the file. If this flag is specified
in conjunction with <b>PMEM_FILE_CREATE</b>, and pathname
already exists, then <b>pmem_map_file</b>() will fail.</p>


<p style="margin-left:22%; margin-top: 1em"><b>PMEM_FILE_TMPFILE</b>
- Same meaning as <b>O_TMPFILE</b> on <b>open</b>(2). Create
a mapping for an unnamed temporary file.
<b>PMEM_FILE_CREATE</b> and <i>len</i> must be specified and
<i>path</i> must be an existing directory name.</p>


<p style="margin-left:22%; margin-top: 1em"><b>PMEM_FILE_SPARSE</b>
- When creating a file, create a sparse (holey) file instead
of calling <b>posix_fallocate</b>(2). Valid only if
specified in conjunction with <b>PMEM_FILE_CREATE</b> or
<b>PMEM_FILE_TMPFILE</b>, otherwise ignored.</p>

<p style="margin-left:22%; margin-top: 1em">If creation
flags are not supplied, then <b>pmem_map_file</b>() creates
a mapping for an existing file. In such case, <i>len</i>
should be zero. The entire file is mapped to memory; its
length is used as the length of the mapping and returned via
<i>mapped_lenp</i>.</p>

<p style="margin-left:22%; margin-top: 1em">To delete
mappings created with <b>pmem_map_file</b>(), use
<b>pmem_unmap</b>().</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmem_unmap(void *</b><i>addr</i><b>, size_t</b>
<i>len</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmem_unmap</b>() function deletes all the mappings for
the specified address range, and causes further references
to addresses within the range to generate invalid memory
references. It will use the address specified by the
parameter <i>addr</i>, where <i>addr</i> must be a
previously mapped region. <b>pmem_unmap</b>() will delete
the mappings using the <b>munmap</b>(2), On success,
<b>pmem_unmap</b>() returns zero. On error, -1 is returned,
and errno is set appropriately.</p>

<h2>PARTIAL FLUSHING OPERATIONS
<a name="PARTIAL FLUSHING OPERATIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The functions
in this section provide access to the stages of flushing to
persistence, for the less common cases where an application
needs more control of the flushing operations than the
<b>pmem_persist</b>() function described above.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pmem_flush(const void *</b><i>addr</i><b>, size_t</b>
<i>len</i><b>); <br>
void pmem_drain(void);</b></p>

<p style="margin-left:22%; margin-top: 1em">These functions
provide partial versions of the <b>pmem_persist</b>()
function described above. <b>pmem_persist</b>() can be
thought of as this:</p>

<p style="margin-left:22%; margin-top: 1em">void <br>
pmem_persist(const void *addr, size_t len) <br>
{ <br>
/* flush the processor caches */ <br>
pmem_flush(addr, len); <br>
/* wait for any pmem stores to drain from HW buffers */ <br>
pmem_drain(); <br>
}</p>

<p style="margin-left:22%; margin-top: 1em">These functions
allow advanced programs to create their own variations of
<b>pmem_persist</b>(). For example, a program that needs to
flush several discontiguous ranges can call
<b>pmem_flush</b>() for each range and then follow up by
calling <b>pmem_drain</b>() once.</p>

<p style="margin-left:22%; margin-top: 1em">NOTE: Some
software is designed for custom platforms that obviate the
need for using PCOMMIT (perhaps the platform issues PCOMMIT
on shutdown or something similar). Even in such cases, it is
recommended that applications using <b>libpmem</b> do not
skip the step of calling <b>pmem_drain</b>(), either
directly or by using <b>pmem_persist</b>(). The recommended
way to inhibit use of the PCOMMIT instruction is by setting
the <b>PMEM_NO_PCOMMIT</b> environment variable as described
in the <b>ENVIRONMENT VARIABLES</b> section.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmem_has_hw_drain(void);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmem_has_hw_drain</b>() function returns true if the
machine supports the <i>hardware drain</i> function for
persistent memory, such as that provided by the
<b>PCOMMIT</b> instruction on Intel processors. If support
for hardware drain is not found, or cannot be detected by
the library, <b>pmem_has_hw_drain</b>() will return false.
Although it is typically an administrative task to provide
the correct platform configuration for persistent memory,
this function is provided for the less common cases where an
application needs to ensure this feature is available. Note
that the lack of this feature means that calling
<b>pmem_persist</b>() may not fully ensure stores are
durable, without additional platform features such as
Asynchronous DRAM Refresh (ADR) or something similar.</p>

<h2>COPYING TO PERSISTENT MEMORY
<a name="COPYING TO PERSISTENT MEMORY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The functions
in this section provide optimized copying to persistent
memory.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
*pmem_memmove_persist(void *</b><i>pmemdest</i><b>, const
void *</b><i>src</i><b>, <br>
size_t</b> <i>len</i><b>); <br>
void *pmem_memcpy_persist(void *</b><i>pmemdest</i><b>,
const void *</b><i>src</i><b>, size_t</b> <i>len</i><b>);
<br>
void *pmem_memset_persist(void *</b><i>pmemdest</i><b>,
int</b> <i>c</i><b>, size_t</b> <i>len</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmem_memmove_persist</b>(), <b>pmem_memcpy_persist</b>(),
and <b>pmem_memset_persist</b>(), functions provide the same
memory copying as their namesakes <b>memmove</b>(3)
<b>memcpy</b>(3), and <b>memset</b>(3), and ensure that the
result has been flushed to persistence before returning. For
example, the following code is functionally equivalent to
<b>pmem_memmove_persist</b>():</p>

<p style="margin-left:22%; margin-top: 1em">void * <br>
pmem_memmove_persist(void *pmemdest, const void *src, size_t
len) <br>
{ <br>
void *retval = memmove(pmemdest, src, len);</p>


<p style="margin-left:22%; margin-top: 1em">pmem_persist(pmemdest,
len);</p>

<p style="margin-left:22%; margin-top: 1em">return retval;
<br>
}</p>

<p style="margin-left:22%; margin-top: 1em">Calling
<b>pmem_memmove_persist</b>() may out-perform the above
code, however, since the <b>libpmem</b> implementation may
take advantage of the fact that <i>pmemdest</i> is
persistent memory and use instructions such as
<i>non-temporal</i> stores to avoid the need to flush
processor caches.</p>

<p style="margin-left:22%; margin-top: 1em">WARNING: Using
these functions where <b>pmem_is_pmem</b>() returns false
may not do anything useful. Use the normal libc functions in
that case.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
*pmem_memmove_nodrain(void *</b><i>pmemdest</i><b>, const
void *</b><i>src</i><b>, <br>
size_t</b> <i>len</i><b>); <br>
void *pmem_memcpy_nodrain(void *</b><i>pmemdest</i><b>,
const void *</b><i>src</i><b>, size_t</b> <i>len</i><b>);
<br>
void *pmem_memset_nodrain(void *</b><i>pmemdest</i><b>,
int</b> <i>c</i><b>, size_t</b> <i>len</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmem_memmove_nodrain</b>(), <b>pmem_memcpy_nodrain</b>()
and <b>pmem_memset_nodrain</b>() functions are similar to
<b>pmem_memmove_persist</b>(), <b>pmem_memcpy_persist</b>(),
and <b>pmem_memset_persist</b>() described above, except
they skip the final <b>pmem_drain</b>() step. This allows
applications to optimize cases where several ranges are
being copied to persistent memory, followed by a single call
to <b>pmem_drain</b>(). The following example illustrates
how these functions might be used to avoid multiple calls to
<b>pmem_drain</b>() when copying several ranges of memory to
pmem:</p>

<p style="margin-left:22%; margin-top: 1em">/* ... write
several ranges to pmem ... */ <br>
pmem_memcpy_nodrain(pmemdest1, src1, len1); <br>
pmem_memcpy_nodrain(pmemdest2, src2, len2);</p>

<p style="margin-left:22%; margin-top: 1em">/* ... */</p>

<p style="margin-left:22%; margin-top: 1em">/* wait for any
pmem stores to drain from HW buffers */ <br>
pmem_drain();</p>

<p style="margin-left:22%; margin-top: 1em">WARNING: Using
<b>pmem_memmove_nodrain</b>(), <b>pmem_memcpy_nodrain</b>()
or <b>pmem_memset_nodrain</b>() on a destination where
<b>pmem_is_pmem</b>() returns false may not do anything
useful.</p>

<h2>LIBRARY API VERSIONING
<a name="LIBRARY API VERSIONING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section
describes how the library API is versioned, allowing
applications to work with an evolving API.</p>

<p style="margin-left:11%; margin-top: 1em"><b>const char
*pmem_check_version( <br>
unsigned</b> <i>major_required</i><b>, <br>
unsigned</b> <i>minor_required</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmem_check_version</b>() function is used to see if the
installed <b>libpmem</b> supports the version of the library
API required by an application. The easiest way to do this
is for the application to supply the compile-time version
information, supplied by defines in
<b>&lt;libpmem.h&gt;</b>, like this:</p>

<p style="margin-left:22%; margin-top: 1em">reason =
pmem_check_version(PMEM_MAJOR_VERSION, <br>
PMEM_MINOR_VERSION); <br>
if (reason != NULL) { <br>
/* version check failed, reason string tells you why */ <br>
}</p>

<p style="margin-left:22%; margin-top: 1em">Any mismatch in
the major version number is considered a failure, but a
library with a newer minor version number will pass this
check since increasing minor versions imply backwards
compatibility.</p>

<p style="margin-left:22%; margin-top: 1em">An application
can also check specifically for the existence of an
interface by checking for the version where that interface
was introduced. These versions are documented in this man
page as follows: unless otherwise specified, all interfaces
described here are available in version 1.0 of the library.
Interfaces added after version 1.0 will contain the text
<i>introduced in version x.y</i> in the section of this
manual describing the feature.</p>

<p style="margin-left:22%; margin-top: 1em">When the
version check performed by <b>pmem_check_version</b>() is
successful, the return value is NULL. Otherwise the return
value is a static string describing the reason for failing
the version check. The string returned by
<b>pmem_check_version</b>() must not be modified or
freed.</p>

<h2>DEBUGGING AND ERROR HANDLING
<a name="DEBUGGING AND ERROR HANDLING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Two versions of
<b>libpmem</b> are typically available on a development
system. The normal version, accessed when a program is
linked using the <b>-lpmem</b> option, is optimized for
performance. That version skips checks that impact
performance and never logs any trace information or performs
any run-time assertions. If an error is detected during the
call to <b>libpmem</b> function, an application may retrieve
an error message describing the reason of failure using the
following function:</p>

<p style="margin-left:11%; margin-top: 1em"><b>const char
*pmem_errormsg(void);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmem_errormsg</b>() function returns a pointer to a
static buffer containing the last error message logged for
current thread. The error message may include description of
the corresponding error code (if errno was set), as returned
by <b>strerror</b>(3). The error message buffer is
thread-local; errors encountered in one thread do not affect
its value in other threads. The buffer is never cleared by
any library function; its content is significant only when
the return value of the immediately preceding call to
<b>libpmem</b> function indicated an error, or if errno was
set. The application must not modify or free the error
message string, but it may be modified by subsequent calls
to other library functions.</p>

<p style="margin-left:11%; margin-top: 1em">A second
version of <b>libpmem</b>, accessed when a program uses the
libraries under <b>/usr/lib/nvml_debug</b>, contains
run-time assertions and trace points. The typical way to
access the debug version is to set the environment variable
<b>LD_LIBRARY_PATH</b> to <b>/usr/lib/nvml_debug</b> or
<b>/usr/lib64/nvml_debug</b> depending on where the debug
libraries are installed on the system. The trace points in
the debug version of the library are enabled using the
environment variable <b>PMEM_LOG_LEVEL</b>, which can be set
to the following values:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>0</p></td>
<td width="10%"></td>
<td width="78%">


<p>This is the default level when <b>PMEM_LOG_LEVEL</b> is
not set. No log messages are emitted at this level.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>1</p></td>
<td width="10%"></td>
<td width="78%">


<p>Additional details on any errors detected are logged (in
addition to returning the errno-based errors as usual). The
same information may be retrieved using
<b>pmem_errormsg</b>().</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>2</p></td>
<td width="10%"></td>
<td width="78%">


<p>A trace of basic operations is logged.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>3</p></td>
<td width="10%"></td>
<td width="78%">


<p>This level enables a very verbose amount of function
call tracing in the library.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>4</p></td>
<td width="10%"></td>
<td width="78%">


<p>This level enables voluminous and fairly obscure tracing
information that is likely only useful to the <b>libpmem</b>
developers.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The environment
variable <b>PMEM_LOG_FILE</b> specifies a file name where
all logging information should be written. If the last
character in the name is &quot;-&quot;, the PID of the
current process will be appended to the file name when the
log file is created. If <b>PMEM_LOG_FILE</b> is not set, the
logging output goes to stderr.</p>

<p style="margin-left:11%; margin-top: 1em">Setting the
environment variable <b>PMEM_LOG_LEVEL</b> has no effect on
the non-debug version of <b>libpmem</b>.</p>

<h2>ENVIRONMENT VARIABLES
<a name="ENVIRONMENT VARIABLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>libpmem</b>
can change its default behavior based on the following
environment variables. These are largely intended for
testing and are not normally required.</p>


<p style="margin-left:11%; margin-top: 1em"><b>PMEM_IS_PMEM_FORCE=</b><i>val</i></p>

<p style="margin-left:22%; margin-top: 1em">If <i>val</i>
is 0 (zero), then <b>pmem_is_pmem</b>() will always return
false. Setting <i>val</i> to 1 causes <b>pmem_is_pmem</b>()
to always return true. This variable is mostly used for
testing but can be used to force pmem behavior on a system
where a range of pmem is not detectable as pmem for some
reason.</p>


<p style="margin-left:11%; margin-top: 1em"><b>PMEM_NO_PCOMMIT=1</b></p>

<p style="margin-left:22%; margin-top: 1em">Setting this
environment variable to 1 forces <b>libpmem</b> to never
issue the Intel PCOMMIT instruction. This can be used on
platforms where the hardware drain function is performed
some other way, like automatic flushing during a power
failure.</p>

<p style="margin-left:22%; margin-top: 1em">WARNING: Using
this environment variable incorrectly may impact program
correctness.</p>


<p style="margin-left:11%; margin-top: 1em"><b>PMEM_NO_CLWB=1</b></p>

<p style="margin-left:22%; margin-top: 1em">Setting this
environment variable to 1 forces <b>libpmem</b> to never
issue the <b>CLWB</b> instruction on Intel hardware, falling
back to other cache flush instructions instead
(<b>CLFLUSHOPT</b> or <b>CLFLUSH</b> on Intel hardware).
Without this environment variable, <b>libpmem</b> will
always use the <b>CLWB</b> instruction for flushing
processor caches on platforms that support the instruction.
This variable is intended for use during library testing but
may be required for some rare cases where using <b>CLWB</b>
has a negative impact on performance.</p>


<p style="margin-left:11%; margin-top: 1em"><b>PMEM_NO_CLFLUSHOPT=1</b></p>

<p style="margin-left:22%; margin-top: 1em">Setting this
environment variable to 1 forces <b>libpmem</b> to never
issue the <b>CLFLUSHOPT</b> instruction on Intel hardware,
falling back to the <b>CLFLUSH</b> instructions instead.
Without this environment variable, <b>libpmem</b> will
always use the <b>CLFLUSHOPT</b> instruction for flushing
processor caches on platforms that support the instruction,
but where <b>CLWB</b> is not available. This variable is
intended for use during library testing.</p>


<p style="margin-left:11%; margin-top: 1em"><b>PMEM_NO_MOVNT=1</b></p>

<p style="margin-left:22%; margin-top: 1em">Setting this
environment variable to 1 forces <b>libpmem</b> to never use
the <i>non-temporal</i> move instructions on Intel hardware.
Without this environment variable, <b>libpmem</b> will use
the non-temporal instructions for copying larger ranges to
persistent memory on platforms that support the
instructions. This variable is intended for use during
library testing.</p>


<p style="margin-left:11%; margin-top: 1em"><b>PMEM_MOVNT_THRESHOLD=</b><i>val</i></p>

<p style="margin-left:22%; margin-top: 1em">This
environment variable allows overriding the minimal length of
<b>pmem_memcpy_*</b>(), <b>pmem_memmove_*</b>() or
<b>pmem_memset_*</b>() operations, for which <b>libpmem</b>
uses <i>non-temporal</i> move instructions. Setting this
environment variable to 0 forces <b>libpmem</b> to always
use the <i>non-temporal</i> move instructions if available.
It has no effect if <b>PMEM_NO_MOVNT</b> variable is set to
1. This variable is intended for use during library
testing.</p>


<p style="margin-left:11%; margin-top: 1em"><b>PMEM_MMAP_HINT=</b><i>val</i>
This environment variable allows overriding the hint address
used by <b>pmem_map_file</b>(). If set, it also disables
mapping address randomization. This variable is intended for
use during library testing and debugging. Setting it to some
fairly large value (i.e. 0x10000000000) will very likely
result in mapping the file at the specified address (if not
used) or at the first unused region above given address,
without adding any random offset. When debugging, this makes
it easier to calculate the actual address of the persistent
memory block, based on its offset in the file. In case of
<b>libpmemobj</b> it simplifies conversion of a persistent
object identifier (OID) into a direct pointer to the object.
<b>NOTE: Setting this environment variable affects all the
NVM libraries,</b> disabling mapping address randomization
and causing the specified address to be used as a hint about
where to place the mapping.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
example uses <b>libpmem</b> to flush changes made to raw,
memory-mapped persistent memory.</p>

<p style="margin-left:11%; margin-top: 1em">WARNING: there
is nothing transactional about the <b>pmem_persist</b>() or
<b>pmem_msync</b>() calls in this example. Interrupting the
program may result in a partial write to pmem. Use a
transactional library such as <b>libpmemobj</b>(3) to avoid
torn updates.</p>

<p style="margin-left:22%; margin-top: 1em">#include
&lt;sys/types.h&gt; <br>
#include &lt;sys/stat.h&gt; <br>
#include &lt;fcntl.h&gt; <br>
#include &lt;stdio.h&gt; <br>
#include &lt;errno.h&gt; <br>
#include &lt;stdlib.h&gt; <br>
#include &lt;unistd.h&gt; <br>
#include &lt;string.h&gt; <br>
#include &lt;libpmem.h&gt;</p>

<p style="margin-left:22%; margin-top: 1em">/* using 4k of
pmem for this example */</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="8%">


<p>#define</p></td>
<td width="77%">


<p>PMEM_LEN 4096</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="8%">


<p>#define</p></td>
<td width="77%">


<p>PATH &quot;/pmem-fs/myfile&quot;</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">int <br>
main(int argc, char *argv[]) <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>char *pmemaddr;</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>size_t mapped_len;</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>int is_pmem;</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>/* create a pmem file and memory map it */</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>if ((pmemaddr = pmem_map_file(PATH, PMEM_LEN,
PMEM_FILE_CREATE,</p> </td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="7%">
</td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="62%">


<p>0666, &amp;mapped_len, &amp;is_pmem)) == NULL) {</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="7%">


<p>perror(&quot;pmem_map_file&quot;);</p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="7%">


<p>exit(1);</p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>}</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>/* store a string to the persistent memory */</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>strcpy(pmemaddr, &quot;hello, persistent
memory&quot;);</p> </td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>/* flush above strcpy to persistence */</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>if (is_pmem)</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="7%">


<p>pmem_persist(pmemaddr, mapped_len);</p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>else</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="7%">


<p>pmem_msync(pmemaddr, mapped_len);</p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>/*</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>* Delete the mappings. The region is also</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>* automatically unmapped when the process is</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>* terminated.</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>*/</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>pmem_unmap(pmemaddr, mapped_len);</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:22%;">}</p>

<p style="margin-left:11%; margin-top: 1em">See
http://pmem.io/nvml/libpmem for more examples using the
<b>libpmem</b> API.</p>

<h2>ACKNOWLEDGEMENTS
<a name="ACKNOWLEDGEMENTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>libpmem</b>
builds on the persistent memory programming model
recommended by the SNIA NVM Programming Technical Work
Group:</p>


<p style="margin-left:22%; margin-top: 1em">http://snia.org/nvmp</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>open</b>(2),
<b>mmap</b>(2), <b>munmap</b>(2), <b>msync</b>(2),
<b>strerror</b>(3), <b>libpmemobj</b>(3),
<b>libpmemblk</b>(3), <b>libpmemlog</b>(3),
<b>libvmem</b>(3) and <b>http://pmem.io</b>.</p>
<hr>
</body>
</html>
