/*
 * This file is automatically generated by utils/call_stack_analysis/log_call_all_generate.py.
 * Please do not modify manually.
 */
void
call_all_CORE_LOG_ERROR_LAST(void)
{
}

void
call_all_ERR_WO_ERRNO(void)
{
	// src/test/out_err/out_err.c:30
	ERR_WO_ERRNO("ERR #%d", _d);
	// src/tools/pmempool/output.c:779
	ERR_WO_ERRNO("snprintf for incompat features: %d", _d);
	// src/libpmem/pmem.c:413
	ERR_WO_ERRNO("invalid flag specified %x", _u);
	// src/libpmem/pmem.c:420
	ERR_WO_ERRNO("flag unsupported for Device DAX %x", _u);
	// src/libpmem/pmem.c:429
	ERR_WO_ERRNO("unable to read Device DAX size");
	// src/libpmem/pmem.c:434
	ERR_WO_ERRNO("Device DAX length must be either 0 or the exact size of the device: %zu", _zu);
	// src/libpmem/pmem.c:446
	ERR_WO_ERRNO("invalid file length %zu", _zu);
	// src/libpmem/pmem.c:457
	ERR_WO_ERRNO("non-zero 'len' not allowed without PMEM_FILE_CREATE");
	// src/libpmem/pmem.c:464
	ERR_WO_ERRNO("zero 'len' not allowed with PMEM_FILE_CREATE");
	// src/libpmem/pmem.c:470
	ERR_WO_ERRNO("PMEM_FILE_TMPFILE not allowed without PMEM_FILE_CREATE");
	// src/libpmem/pmem.c:513
	ERR_WO_ERRNO("stat %s: negative size", _s);
	// src/libpmem/pmem.c:588
	ERR_WO_ERRNO("invalid flags 0x%x", _u);
	// src/libpmem/pmem.c:619
	ERR_WO_ERRNO("invalid flags 0x%x", _u);
	// src/libpmem/pmem.c:651
	ERR_WO_ERRNO("invalid flags 0x%x", _u);
	// src/libpmem/libpmem.c:56
	ERR_WO_ERRNO("libpmem major version mismatch (need %u, found %u)", _u, _u);
	// src/libpmem/libpmem.c:63
	ERR_WO_ERRNO("libpmem minor version mismatch (need %u, found %u)", _u, _u);
	// src/libpmemobj/alloc_class.c:231
	ERR_WO_ERRNO("unable to register allocation class");
	// src/libpmemobj/tx.c:513
	ERR_WO_ERRNO("Unrecognized lock type");
	// src/libpmemobj/tx.c:550
	ERR_WO_ERRNO("Unrecognized lock type");
	// src/libpmemobj/tx.c:588
	ERR_WO_ERRNO("requested size too large");
	// src/libpmemobj/tx.c:617
	ERR_WO_ERRNO("out of memory");
	// src/libpmemobj/tx.c:633
	ERR_WO_ERRNO("requested size too large");
	// src/libpmemobj/tx.c:647
	ERR_WO_ERRNO("pmemobj_tx_free failed");
	// src/libpmemobj/tx.c:665
	ERR_WO_ERRNO("pmemobj_tx_free failed");
	// src/libpmemobj/tx.c:682
	ERR_WO_ERRNO("Buffer from a different pool");
	// src/libpmemobj/tx.c:739
	ERR_WO_ERRNO("nested transaction for different pool");
	// src/libpmemobj/tx.c:865
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/tx.c:1236
	ERR_WO_ERRNO("snapshot size too large");
	// src/libpmemobj/tx.c:1243
	ERR_WO_ERRNO("object outside of heap");
	// src/libpmemobj/tx.c:1383
	ERR_WO_ERRNO("out of memory");
	// src/libpmemobj/tx.c:1410
	ERR_WO_ERRNO("object outside of pool");
	// src/libpmemobj/tx.c:1448
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/tx.c:1456
	ERR_WO_ERRNO("object outside of pool");
	// src/libpmemobj/tx.c:1493
	ERR_WO_ERRNO("invalid pool uuid");
	// src/libpmemobj/tx.c:1531
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/tx.c:1539
	ERR_WO_ERRNO("invalid pool uuid");
	// src/libpmemobj/tx.c:1576
	ERR_WO_ERRNO("allocation with size 0");
	// src/libpmemobj/tx.c:1607
	ERR_WO_ERRNO("allocation with size 0");
	// src/libpmemobj/tx.c:1638
	ERR_WO_ERRNO("allocation with size 0");
	// src/libpmemobj/tx.c:1645
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/tx.c:1714
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/tx.c:1722
	ERR_WO_ERRNO("cannot duplicate NULL string");
	// src/libpmemobj/tx.c:1772
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/tx.c:1780
	ERR_WO_ERRNO("cannot duplicate NULL string");
	// src/libpmemobj/tx.c:1831
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/tx.c:1842
	ERR_WO_ERRNO("invalid pool uuid");
	// src/libpmemobj/tx.c:1914
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/tx.c:1959
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/tx.c:2208
	ERR_WO_ERRNO("invalid cache size, must be between 0 and max alloc size");
	// src/libpmemobj/tx.c:2232
	ERR_WO_ERRNO("tx.cache.threshold parameter is deprecated");
	// src/libpmemobj/tx.c:2247
	ERR_WO_ERRNO("tx.cache.threshold parameter is deprecated");
	// src/libpmemobj/palloc.c:196
	ERR_WO_ERRNO("no allocation class for size %lu bytes", _lu);
	// src/libpmemobj/palloc.c:211
	ERR_WO_ERRNO("allocation class not suitable for size %lu bytes", _lu);
	// src/libpmemobj/palloc.c:275
	ERR_WO_ERRNO("invalid operation or heap corruption");
	// src/libpmemobj/libpmemobj.c:52
	ERR_WO_ERRNO("libpmemobj major version mismatch (need %u, found %u)", _u, _u);
	// src/libpmemobj/libpmemobj.c:59
	ERR_WO_ERRNO("libpmemobj minor version mismatch (need %u, found %u)", _u, _u);
	// src/libpmemobj/stats.c:74
	ERR_WO_ERRNO("invalid enable type");
	// src/libpmemobj/ulog.c:245
	ERR_WO_ERRNO("cannot auto reserve next ulog");
	// src/libpmemobj/heap.c:768
	ERR_WO_ERRNO("lost runtime tracking info of %u run due to OOM", _u);
	// src/libpmemobj/heap.c:1051
	ERR_WO_ERRNO("lost runtime tracking info of %u run due to OOM", _u);
	// src/libpmemobj/heap.c:1167
	ERR_WO_ERRNO("lost runtime tracking info of %u run due to OOM", _u);
	// src/libpmemobj/heap.c:1410
	ERR_WO_ERRNO("at least one automatic arena must exist");
	// src/libpmemobj/heap.c:1605
	ERR_WO_ERRNO("mapped region smaller than the heap size");
	// src/libpmemobj/heap.c:1787
	ERR_WO_ERRNO("heap: invalid header's checksum");
	// src/libpmemobj/heap.c:1792
	ERR_WO_ERRNO("heap: invalid signature");
	// src/libpmemobj/heap.c:1810
	ERR_WO_ERRNO("heap: invalid zone size");
	// src/libpmemobj/heap.c:1825
	ERR_WO_ERRNO("heap: invalid chunk type");
	// src/libpmemobj/heap.c:1830
	ERR_WO_ERRNO("heap: unknown chunk type");
	// src/libpmemobj/heap.c:1835
	ERR_WO_ERRNO("heap: invalid chunk flags");
	// src/libpmemobj/heap.c:1852
	ERR_WO_ERRNO("heap: invalid zone magic");
	// src/libpmemobj/heap.c:1868
	ERR_WO_ERRNO("heap: chunk sizes mismatch");
	// src/libpmemobj/heap.c:1884
	ERR_WO_ERRNO("heap: invalid heap size");
	// src/libpmemobj/memops.c:575
	ERR_WO_ERRNO("Capacity insufficient");
	// src/libpmemobj/memops.c:586
	ERR_WO_ERRNO("Buffer currently used");
	// src/libpmemobj/memops.c:691
	ERR_WO_ERRNO("no extend function present");
	// src/libpmemobj/sync.c:43
	ERR_WO_ERRNO("error initializing lock");
	// src/libpmemobj/sync.c:50
	ERR_WO_ERRNO("error setting lock runid");
	// src/libpmemobj/obj.c:773
	ERR_WO_ERRNO("invalid checksum of pool descriptor");
	// src/libpmemobj/obj.c:780
	ERR_WO_ERRNO("wrong layout (\"%s\"), pool created with layout \"%s\"", _s, _s);
	// src/libpmemobj/obj.c:788
	ERR_WO_ERRNO("unaligned heap: off %lu", _lu);
	// src/libpmemobj/obj.c:1036
	ERR_WO_ERRNO("%s variable must be a positive integer", _s);
	// src/libpmemobj/obj.c:1065
	ERR_WO_ERRNO("Layout too long");
	// src/libpmemobj/obj.c:1114
	ERR_WO_ERRNO("initialization of replica #%u failed", _u);
	// src/libpmemobj/obj.c:1134
	ERR_WO_ERRNO("pool initialization failed");
	// src/libpmemobj/obj.c:1184
	ERR_WO_ERRNO("invalid run_id %lu", _lu);
	// src/libpmemobj/obj.c:1246
	ERR_WO_ERRNO("read-only mode is not supported");
	// src/libpmemobj/obj.c:1279
	ERR_WO_ERRNO("initialization of replica #%u failed", _u);
	// src/libpmemobj/obj.c:1319
	ERR_WO_ERRNO("inconsistent replica #%u", _u);
	// src/libpmemobj/obj.c:1405
	ERR_WO_ERRNO("pool initialization failed");
	// src/libpmemobj/obj.c:1537
	ERR_WO_ERRNO("critnib_remove for pools_ht");
	// src/libpmemobj/obj.c:1541
	ERR_WO_ERRNO("critnib_remove for pools_tree");
	// src/libpmemobj/obj.c:1724
	ERR_WO_ERRNO("requested size too large");
	// src/libpmemobj/obj.c:1767
	ERR_WO_ERRNO("allocation with size 0");
	// src/libpmemobj/obj.c:1798
	ERR_WO_ERRNO("allocation with size 0");
	// src/libpmemobj/obj.c:1804
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/obj.c:1843
	ERR_WO_ERRNO("allocation with size 0");
	// src/libpmemobj/obj.c:1921
	ERR_WO_ERRNO("requested size too large");
	// src/libpmemobj/obj.c:2298
	ERR_WO_ERRNO("invalid flags 0x%x", _u);
	// src/libpmemobj/obj.c:2316
	ERR_WO_ERRNO("invalid flags 0x%x", _u);
	// src/libpmemobj/obj.c:2418
	ERR_WO_ERRNO("requested size too large");
	// src/libpmemobj/obj.c:2424
	ERR_WO_ERRNO("requested size cannot equals zero");
	// src/libpmemobj/obj.c:2560
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/obj.c:2669
	ERR_WO_ERRNO("Not all PMEMoids belong to the provided pool");
	// src/libpmemobj/obj.c:2739
	ERR_WO_ERRNO("requested size too large");
	// src/libpmemobj/pmalloc.c:237
	ERR_WO_ERRNO("unit size must be evenly divisible by alignment");
	// src/libpmemobj/pmalloc.c:243
	ERR_WO_ERRNO("alignment cannot be larger than 2 megabytes");
	// src/libpmemobj/pmalloc.c:261
	ERR_WO_ERRNO("invalid header type");
	// src/libpmemobj/pmalloc.c:268
	ERR_WO_ERRNO("no available free allocation class identifier");
	// src/libpmemobj/pmalloc.c:278
	ERR_WO_ERRNO("class id outside of the allowed range");
	// src/libpmemobj/pmalloc.c:286
	ERR_WO_ERRNO("attempted to overwrite an allocation class");
	// src/libpmemobj/pmalloc.c:344
	ERR_WO_ERRNO("invalid header type");
	// src/libpmemobj/pmalloc.c:369
	ERR_WO_ERRNO("class id outside of the allowed range");
	// src/libpmemobj/pmalloc.c:380
	ERR_WO_ERRNO("class with the given id does not exist");
	// src/libpmemobj/pmalloc.c:459
	ERR_WO_ERRNO("incorrect size for extend, must be larger than %lu", _lu);
	// src/libpmemobj/pmalloc.c:511
	ERR_WO_ERRNO("incorrect grow size, must be 0 or larger than %lu", _lu);
	// src/libpmemobj/pmalloc.c:576
	ERR_WO_ERRNO("cannot change max arena number");
	// src/libpmemobj/pmalloc.c:642
	ERR_WO_ERRNO("arena id outside of the allowed range: <1,%u>", _u);
	// src/libpmemobj/pmalloc.c:680
	ERR_WO_ERRNO("arena id outside of the allowed range: <1,%u>", _u);
	// src/libpmemobj/pmalloc.c:687
	ERR_WO_ERRNO("incorrect arena state, must be 0 or 1");
	// src/libpmemobj/pmalloc.c:719
	ERR_WO_ERRNO("arena id outside of the allowed range: <1,%u>", _u);
	// src/libpmemobj/pmalloc.c:767
	ERR_WO_ERRNO("arena id outside of the allowed range: <1,%u>", _u);
	// src/libpmemobj/pmalloc.c:919
	ERR_WO_ERRNO("invalid arena assignment type");
	// src/libpmemobj/pmalloc.c:969
	ERR_WO_ERRNO("number of default arenas can't be 0");
	// src/common/set.c:257
	ERR_WO_ERRNO("unable to map at requested address %p", _p);
	// src/common/set.c:476
	ERR_WO_ERRNO("size autodetection is supported only for device dax");
	// src/common/set.c:732
	ERR_WO_ERRNO("cannot mix directories and files in a set");
	// src/common/set.c:758
	ERR_WO_ERRNO("cannot mix directories and files in a set");
	// src/common/set.c:768
	ERR_WO_ERRNO("cannot resolve realpath of new directory");
	// src/common/set.c:780
	ERR_WO_ERRNO("cannot use the same directory twice");
	// src/common/set.c:877
	ERR_WO_ERRNO("replica #%u part %u %smapped with MAP_SYNC", _u, _u, _s);
	// src/common/set.c:887
	ERR_WO_ERRNO("replica #%u part %u header %smapped with MAP_SYNC", _u, _u, _s);
	// src/common/set.c:916
	ERR_WO_ERRNO("either all the parts must be Device DAX or none");
	// src/common/set.c:926
	ERR_WO_ERRNO("Multiple DAX devices with alignment other than 4KB. Use the SINGLEHDR poolset option.");
	// src/common/set.c:945
	ERR_WO_ERRNO("both SINGLEHDR and NOHDR poolset options used at the same time");
	// src/common/set.c:1066
	ERR_WO_ERRNO("unable to load part %s", _s);
	// src/common/set.c:1105
	ERR_WO_ERRNO("failed to load parts from directory %s", _s);
	// src/common/set.c:1302
	ERR_WO_ERRNO("Remote replicas are no longer supported. This functionality is deprecated.");
	// src/common/set.c:1339
	ERR_WO_ERRNO("%s [%s:%d]", _s, _s, _d);
	// src/common/set.c:1357
	ERR_WO_ERRNO("cannot load part files from directories");
	// src/common/set.c:1511
	ERR_WO_ERRNO("file size does not match config: %s, %zu != %zu", _s, _zu, _zu);
	// src/common/set.c:1609
	ERR_WO_ERRNO("size must be zero for device dax");
	// src/common/set.c:1643
	ERR_WO_ERRNO("file is not a poolset file and its size (%zu) is smaller than %zu", _zu, _zu);
	// src/common/set.c:1680
	ERR_WO_ERRNO("poolset file options (%u) do not match incompat feature flags (%#x)", _u, _u);
	// src/common/set.c:1708
	ERR_WO_ERRNO("Non-empty file detected");
	// src/common/set.c:1816
	ERR_WO_ERRNO("invalid major version (0)");
	// src/common/set.c:1823
	ERR_WO_ERRNO("wrong pool type: \"%.8s\"", _8s);
	// src/common/set.c:1830
	ERR_WO_ERRNO("pool version %d (library expects %d)", _d, _d);
	// src/common/set.c:1833
	ERR_WO_ERRNO("Please run the pmdk-convert utility to upgrade the pool.");
	// src/common/set.c:1858
	ERR_WO_ERRNO("invalid checksum of pool header");
	// src/common/set.c:1866
	ERR_WO_ERRNO("wrong architecture flags");
	// src/common/set.c:1874
	ERR_WO_ERRNO("wrong pool set UUID");
	// src/common/set.c:1884
	ERR_WO_ERRNO("wrong part UUID");
	// src/common/set.c:1891
	ERR_WO_ERRNO("incompatible pool format");
	// src/common/set.c:1900
	ERR_WO_ERRNO("incompatible feature flags");
	// src/common/set.c:2253
	ERR_WO_ERRNO("cannot extend pool by 0 bytes");
	// src/common/set.c:2258
	ERR_WO_ERRNO("extending the pool by appending parts with headers is not supported!");
	// src/common/set.c:2266
	ERR_WO_ERRNO("exceeded reservation size");
	// src/common/set.c:2275
	ERR_WO_ERRNO("unable to append a new part to the pool");
	// src/common/set.c:2290
	ERR_WO_ERRNO("cannot open the new part");
	// src/common/set.c:2300
	ERR_WO_ERRNO("cannot map the new part");
	// src/common/set.c:2310
	ERR_WO_ERRNO("new part cannot be mapped with MAP_SYNC");
	// src/common/set.c:2313
	ERR_WO_ERRNO("new part mapped with MAP_SYNC");
	// src/common/set.c:2356
	ERR_WO_ERRNO("file contains bad blocks -- '%s'", _s);
	// src/common/set.c:2390
	ERR_WO_ERRNO("file %s already exists", _s);
	// src/common/set.c:2407
	ERR_WO_ERRNO("the NOHDRS poolset option is not supported for local poolsets");
	// src/common/set.c:2414
	ERR_WO_ERRNO("pool attributes are not supported for poolsets without headers (with the NOHDRS option)");
	// src/common/set.c:2421
	ERR_WO_ERRNO("directory based pools are not supported for poolsets with headers (without SINGLEHDR option)");
	// src/common/set.c:2428
	ERR_WO_ERRNO("reservation pool size %zu smaller than %zu", _zu, _zu);
	// src/common/set.c:2436
	ERR_WO_ERRNO("cannot create a new part in provided directories");
	// src/common/set.c:2455
	ERR_WO_ERRNO("pool set contains bad blocks and cannot be created, run 'pmempool create --clear-bad-blocks' utility to clear bad blocks and create a pool");
	// src/common/set.c:2463
	ERR_WO_ERRNO("net pool size %zu smaller than %zu", _zu, _zu);
	// src/common/set.c:2470
	ERR_WO_ERRNO("replication not supported");
	// src/common/set.c:2633
	ERR_WO_ERRNO("pool mapping failed - address space reservation too small");
	// src/common/set.c:2806
	ERR_WO_ERRNO("wrong replica UUID");
	// src/common/set.c:2862
	ERR_WO_ERRNO("device dax cannot be mapped privately");
	// src/common/set.c:2877
	ERR_WO_ERRNO("error: a bad block recovery file exists, run 'pmempool sync --bad-blocks' utility to try to recover the pool");
	// src/common/set.c:2900
	ERR_WO_ERRNO("pool set contains bad blocks and cannot be opened, run 'pmempool sync --bad-blocks' utility to try to recover the pool");
	// src/common/set.c:3018
	ERR_WO_ERRNO("device dax cannot be mapped privately");
	// src/common/set.c:3038
	ERR_WO_ERRNO("error: a bad block recovery file exists, run 'pmempool sync --bad-blocks' utility to try to recover the pool");
	// src/common/set.c:3064
	ERR_WO_ERRNO("pool set contains bad blocks and cannot be opened, run 'pmempool sync --bad-blocks' utility to try to recover the pool -- '%s'", _s);
	// src/common/set.c:3215
	ERR_WO_ERRNO("util_poolset_parse failed -- '%s'", _s);
	// src/common/set_badblocks.c:46
	ERR_WO_ERRNO("checking the pool file for bad blocks failed -- '%s'", _s);
	// src/common/set_badblocks.c:53
	ERR_WO_ERRNO("part file contains bad blocks -- '%s'", _s);
	// src/common/set_badblocks.c:120
	ERR_WO_ERRNO("clearing bad blocks in the pool file failed -- '%s'", _s);
	// src/common/shutdown_state.c:77
	ERR_WO_ERRNO("Cannot read unsafe shutdown count. For more information please check https://github.com/pmem/pmdk/issues/4207");
	// src/common/shutdown_state.c:87
	ERR_WO_ERRNO("cannot read uuid of %d", _d);
	// src/common/shutdown_state.c:101
	ERR_WO_ERRNO("cannot read uuid of %d", _d);
	// src/common/shutdown_state.c:232
	ERR_WO_ERRNO("an ADR failure was detected, the pool might be corrupted");
	// src/common/file.c:111
	ERR_WO_ERRNO("invalid (NULL) path");
	// src/common/file.c:182
	ERR_WO_ERRNO("file size (%ld) too big to be represented in 64-bit signed integer", _ld);
	// src/common/file.c:409
	ERR_WO_ERRNO("size %zu smaller than %zu", _zu, _zu);
	// src/common/file.c:415
	ERR_WO_ERRNO("invalid size (%zu) for os_off_t", _zu);
	// src/common/file.c:485
	ERR_WO_ERRNO("stat \"%s\": negative size", _s);
	// src/common/file.c:491
	ERR_WO_ERRNO("size %zu smaller than %zu", _zu, _zu);
	// src/common/mmap.c:287
	ERR_WO_ERRNO("duplicated persistent memory range; presumably unmapped with munmap() instead of pmem_unmap(): addr %p len %zu", _p, _zu);
	// src/common/mmap.c:308
	ERR_WO_ERRNO("Cannot find DAX device region id");
	// src/common/mmap.c:336
	ERR_WO_ERRNO("invalid munmap length, must be non-zero and page aligned");
	// src/common/ctl.c:215
	ERR_WO_ERRNO("read queries require non-NULL argument");
	// src/common/ctl.c:231
	ERR_WO_ERRNO("write queries require non-NULL argument");
	// src/common/ctl.c:278
	ERR_WO_ERRNO("invalid query");
	// src/common/ctl.c:302
	ERR_WO_ERRNO("invalid query entry point %s", _s);
	// src/common/ctl.c:374
	ERR_WO_ERRNO("failed to parse query %s", _s);
	// src/common/ctl.c:436
	ERR_WO_ERRNO("Config file too large");
	// src/common/ctl.c:562
	ERR_WO_ERRNO("invalid destination size %zu", _zu);
	// src/common/pool_hdr.c:116
	ERR_WO_ERRNO("invalid reserved values");
	// src/common/pool_hdr.c:121
	ERR_WO_ERRNO("invalid machine value");
	// src/common/pool_hdr.c:126
	ERR_WO_ERRNO("invalid data value");
	// src/common/pool_hdr.c:131
	ERR_WO_ERRNO("invalid machine_class value");
	// src/common/pool_hdr.c:136
	ERR_WO_ERRNO("invalid alignment_desc value");
	// src/common/pool_hdr.c:173
	ERR_WO_ERRNO("unsafe to continue due to unknown incompat features: %#x", _u);
	// src/common/pool_hdr.c:182
	ERR_WO_ERRNO("switching to read-only mode due to unknown ro_compat features: %#x", _u);
	// src/common/mmap_posix.c:90
	ERR_WO_ERRNO("end of address space reached");
}

void
call_all_CORE_LOG_ERROR_W_ERRNO_LAST(int errnum)
{
	errno = errnum;
}

void
call_all_ERR_W_ERRNO(int errnum)
{
	errno = errnum;
	// src/test/pmem2_perror/pmem2_perror.c:62
	ERR_W_ERRNO("open");
	UT_ASSERTeq(errno, errnum);
	// src/test/pmem2_perror/pmem2_perror.c:79
	ERR_W_ERRNO("open");
	UT_ASSERTeq(errno, errnum);
	// src/test/out_err/out_err.c:34
	ERR_W_ERRNO("ERR #%d", _d);
	UT_ASSERTeq(errno, errnum);
	// src/test/out_err/out_err.c:38
	ERR_W_ERRNO("ERR #%d", _d);
	UT_ASSERTeq(errno, errnum);
	// src/libpmem/pmem.c:280
	ERR_W_ERRNO("msync");
	UT_ASSERTeq(errno, errnum);
	// src/libpmem/pmem.c:487
	ERR_W_ERRNO("open %s", _s);
	UT_ASSERTeq(errno, errnum);
	// src/libpmem/pmem.c:500
	ERR_W_ERRNO("ftruncate");
	UT_ASSERTeq(errno, errnum);
	// src/libpmem/pmem.c:506
	ERR_W_ERRNO("posix_fallocate");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/lane.c:267
	ERR_W_ERRNO("Malloc of volatile lanes");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/lane.c:276
	ERR_W_ERRNO("Malloc for lane locks");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/lane.c:289
	ERR_W_ERRNO("lane_init");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/tx.c:499
	ERR_W_ERRNO("pmemobj_mutex_lock");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/tx.c:508
	ERR_W_ERRNO("pmemobj_rwlock_wrlock");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/tx.c:776
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/tx.c:945
	ERR_W_ERRNO("explicit transaction abort");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/list.c:473
	ERR_W_ERRNO("palloc_reserve");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/stats.c:124
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/critnib.c:279
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/critnib.c:316
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/heap.c:187
	ERR_W_ERRNO("heap: arena malloc error");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/memops.c:90
	ERR_W_ERRNO("Zalloc");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/memops.c:116
	ERR_W_ERRNO("Zalloc");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/memops.c:177
	ERR_W_ERRNO("Zalloc");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/obj.c:662
	ERR_W_ERRNO("lane_boot");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/obj.c:667
	ERR_W_ERRNO("lane_recover_and_section_boot");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/obj.c:725
	ERR_W_ERRNO("palloc_init");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/obj.c:964
	ERR_W_ERRNO("critnib_insert to pools_ht");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/obj.c:969
	ERR_W_ERRNO("critnib_insert to pools_tree");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/obj.c:984
	ERR_W_ERRNO("ravl_new_sized");
	UT_ASSERTeq(errno, errnum);
	// src/common/file_posix.c:158
	ERR_W_ERRNO("stat \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:195
	ERR_W_ERRNO("mmap: %s", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:252
	ERR_W_ERRNO("mmap: %s", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:283
	ERR_W_ERRNO("munmap: %s", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:369
	ERR_W_ERRNO("unlink %s failed (part %u, replica %u)", _s, _u, _u);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:422
	ERR_W_ERRNO("fstat %d %s", _d, _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:435
	ERR_W_ERRNO("chmod %u/%u/%s", _u, _u, _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:518
	ERR_W_ERRNO("Strdup");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:622
	ERR_W_ERRNO("Strdup");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:648
	ERR_W_ERRNO("Realloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:841
	ERR_W_ERRNO("Realloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:849
	ERR_W_ERRNO("Zalloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1027
	ERR_W_ERRNO("fs_new: \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1060
	ERR_W_ERRNO("Strdup");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1139
	ERR_W_ERRNO("no directories in replica");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1156
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1196
	ERR_W_ERRNO("lseek %d", _d);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1202
	ERR_W_ERRNO("dup");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1208
	ERR_W_ERRNO("fdopen %d", _d);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1219
	ERR_W_ERRNO("Reading poolset file");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1226
	ERR_W_ERRNO("Malloc for pool set");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1232
	ERR_W_ERRNO("Strdup");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1404
	ERR_W_ERRNO("Malloc for pool set");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1410
	ERR_W_ERRNO("Strdup");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1419
	ERR_W_ERRNO("Malloc for pool set replica");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1503
	ERR_W_ERRNO("posix_fallocate \"%s\", %zu", _s, _zu);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1573
	ERR_W_ERRNO("open: path \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1632
	ERR_W_ERRNO("read %d", _d);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1756
	ERR_W_ERRNO("fstat");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:2212
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:3013
	ERR_W_ERRNO("no parts in replicas");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:3144
	ERR_W_ERRNO("read");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:3208
	ERR_W_ERRNO("open: path \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/set_badblocks.c:171
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/shutdown_state.c:95
	ERR_W_ERRNO("Zalloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/vecq.h:68
	ERR_W_ERRNO("Realloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:40
	ERR_W_ERRNO("os_access \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:94
	ERR_W_ERRNO("fstat");
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:126
	ERR_W_ERRNO("stat");
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:143
	ERR_W_ERRNO("open");
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:206
	ERR_W_ERRNO("open \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:244
	ERR_W_ERRNO("open \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:430
	ERR_W_ERRNO("open \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:435
	ERR_W_ERRNO("posix_fallocate \"%s\", %zu", _s, _zu);
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:440
	ERR_W_ERRNO("flock \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:469
	ERR_W_ERRNO("open \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:474
	ERR_W_ERRNO("flock \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:507
	ERR_W_ERRNO("flock unlock");
	UT_ASSERTeq(errno, errnum);
	// src/common/mmap.c:104
	ERR_W_ERRNO("mmap %zu bytes", _zu);
	UT_ASSERTeq(errno, errnum);
	// src/common/mmap.c:126
	ERR_W_ERRNO("munmap");
	UT_ASSERTeq(errno, errnum);
	// src/common/mmap.c:155
	ERR_W_ERRNO("mprotect: PROT_READ");
	UT_ASSERTeq(errno, errnum);
	// src/common/mmap.c:184
	ERR_W_ERRNO("mprotect: PROT_READ|PROT_WRITE");
	UT_ASSERTeq(errno, errnum);
	// src/common/mmap.c:213
	ERR_W_ERRNO("mprotect: PROT_NONE");
	UT_ASSERTeq(errno, errnum);
	// src/common/mmap.c:297
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/mmap.c:360
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/mmap.c:375
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/ctl.c:132
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/ctl.c:142
	ERR_W_ERRNO("strtok_r");
	UT_ASSERTeq(errno, errnum);
	// src/common/ctl.c:400
	ERR_W_ERRNO("Strdup");
	UT_ASSERTeq(errno, errnum);
	// src/common/ctl.c:445
	ERR_W_ERRNO("Zalloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/ctl.c:479
	ERR_W_ERRNO("Zalloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/bad_blocks.c:63
	ERR_W_ERRNO("open %s", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/bad_blocks.c:142
	ERR_W_ERRNO("open %s", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/bad_blocks.c:200
	ERR_W_ERRNO("open %s", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/mmap_posix.c:43
	ERR_W_ERRNO("%s", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/mmap_posix.c:141
	ERR_W_ERRNO("mmap MAP_ANONYMOUS");
	UT_ASSERTeq(errno, errnum);
	// src/common/vec.h:62
	ERR_W_ERRNO("Realloc");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:181
	ERR_W_ERRNO("os_spin_init");
	UT_ASSERTeq(errno, errnum);
	// src/core/out.c:126
	ERR_W_ERRNO("snprintf");
	UT_ASSERTeq(errno, errnum);
	// src/core/ravl.c:51
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/core/ravl.c:167
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/core/util_posix.c:49
	ERR_W_ERRNO("stat failed for %s", _s);
	UT_ASSERTeq(errno, errnum);
	// src/core/util_posix.c:59
	ERR_W_ERRNO("stat failed for %s", _s);
	UT_ASSERTeq(errno, errnum);
	// src/core/util_posix.c:99
	ERR_W_ERRNO("mkstemp");
	UT_ASSERTeq(errno, errnum);
	// src/core/util_posix.c:138
	ERR_W_ERRNO("open");
	UT_ASSERTeq(errno, errnum);
}
