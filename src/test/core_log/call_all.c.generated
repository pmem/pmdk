/*
 * This file is automatically generated by utils/call_stack_analysis/log_call_all_generate.py.
 * Please do not modify manually.
 */
void
call_all_CORE_LOG_ERROR_LAST(void)
{
}

void
call_all_ERR_WO_ERRNO(void)
{
	// src/tools/pmempool/output.c:779
	ERR_WO_ERRNO("snprintf for incompat features: %d", _d);
	// src/libpmem/pmem.c:413
	ERR_WO_ERRNO("invalid flag specified %x", _u);
	// src/libpmem/pmem.c:420
	ERR_WO_ERRNO("flag unsupported for Device DAX %x", _u);
	// src/libpmem/pmem.c:429
	ERR_WO_ERRNO("unable to read Device DAX size");
	// src/libpmem/pmem.c:434
	ERR_WO_ERRNO("Device DAX length must be either 0 or the exact size of the device: %zu", _zu);
	// src/libpmem/pmem.c:446
	ERR_WO_ERRNO("invalid file length %zu", _zu);
	// src/libpmem/pmem.c:457
	ERR_WO_ERRNO("non-zero 'len' not allowed without PMEM_FILE_CREATE");
	// src/libpmem/pmem.c:464
	ERR_WO_ERRNO("zero 'len' not allowed with PMEM_FILE_CREATE");
	// src/libpmem/pmem.c:470
	ERR_WO_ERRNO("PMEM_FILE_TMPFILE not allowed without PMEM_FILE_CREATE");
	// src/libpmem/pmem.c:513
	ERR_WO_ERRNO("stat %s: negative size", _s);
	// src/libpmem/pmem.c:588
	ERR_WO_ERRNO("invalid flags 0x%x", _u);
	// src/libpmem/pmem.c:619
	ERR_WO_ERRNO("invalid flags 0x%x", _u);
	// src/libpmem/pmem.c:651
	ERR_WO_ERRNO("invalid flags 0x%x", _u);
	// src/libpmem/libpmem.c:56
	ERR_WO_ERRNO("libpmem major version mismatch (need %u, found %u)", _u, _u);
	// src/libpmem/libpmem.c:63
	ERR_WO_ERRNO("libpmem minor version mismatch (need %u, found %u)", _u, _u);
	// src/libpmemobj/alloc_class.c:231
	ERR_WO_ERRNO("unable to register allocation class");
	// src/libpmemobj/tx.c:513
	ERR_WO_ERRNO("Unrecognized lock type");
	// src/libpmemobj/tx.c:550
	ERR_WO_ERRNO("Unrecognized lock type");
	// src/libpmemobj/tx.c:588
	ERR_WO_ERRNO("requested size too large");
	// src/libpmemobj/tx.c:617
	ERR_WO_ERRNO("out of memory");
	// src/libpmemobj/tx.c:633
	ERR_WO_ERRNO("requested size too large");
	// src/libpmemobj/tx.c:647
	ERR_WO_ERRNO("pmemobj_tx_free failed");
	// src/libpmemobj/tx.c:665
	ERR_WO_ERRNO("pmemobj_tx_free failed");
	// src/libpmemobj/tx.c:682
	ERR_WO_ERRNO("Buffer from a different pool");
	// src/libpmemobj/tx.c:739
	ERR_WO_ERRNO("nested transaction for different pool");
	// src/libpmemobj/tx.c:865
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/tx.c:1236
	ERR_WO_ERRNO("snapshot size too large");
	// src/libpmemobj/tx.c:1243
	ERR_WO_ERRNO("object outside of heap");
	// src/libpmemobj/tx.c:1383
	ERR_WO_ERRNO("out of memory");
	// src/libpmemobj/tx.c:1410
	ERR_WO_ERRNO("object outside of pool");
	// src/libpmemobj/tx.c:1448
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/tx.c:1456
	ERR_WO_ERRNO("object outside of pool");
	// src/libpmemobj/tx.c:1493
	ERR_WO_ERRNO("invalid pool uuid");
	// src/libpmemobj/tx.c:1531
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/tx.c:1539
	ERR_WO_ERRNO("invalid pool uuid");
	// src/libpmemobj/tx.c:1576
	ERR_WO_ERRNO("allocation with size 0");
	// src/libpmemobj/tx.c:1607
	ERR_WO_ERRNO("allocation with size 0");
	// src/libpmemobj/tx.c:1638
	ERR_WO_ERRNO("allocation with size 0");
	// src/libpmemobj/tx.c:1645
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/tx.c:1714
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/tx.c:1722
	ERR_WO_ERRNO("cannot duplicate NULL string");
	// src/libpmemobj/tx.c:1772
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/tx.c:1780
	ERR_WO_ERRNO("cannot duplicate NULL string");
	// src/libpmemobj/tx.c:1831
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/tx.c:1842
	ERR_WO_ERRNO("invalid pool uuid");
	// src/libpmemobj/tx.c:1914
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/tx.c:1959
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/tx.c:2208
	ERR_WO_ERRNO("invalid cache size, must be between 0 and max alloc size");
	// src/libpmemobj/tx.c:2232
	ERR_WO_ERRNO("tx.cache.threshold parameter is deprecated");
	// src/libpmemobj/tx.c:2247
	ERR_WO_ERRNO("tx.cache.threshold parameter is deprecated");
	// src/libpmemobj/palloc.c:196
	ERR_WO_ERRNO("no allocation class for size %lu bytes", _lu);
	// src/libpmemobj/palloc.c:211
	ERR_WO_ERRNO("allocation class not suitable for size %lu bytes", _lu);
	// src/libpmemobj/palloc.c:275
	ERR_WO_ERRNO("invalid operation or heap corruption");
	// src/libpmemobj/libpmemobj.c:52
	ERR_WO_ERRNO("libpmemobj major version mismatch (need %u, found %u)", _u, _u);
	// src/libpmemobj/libpmemobj.c:59
	ERR_WO_ERRNO("libpmemobj minor version mismatch (need %u, found %u)", _u, _u);
	// src/libpmemobj/stats.c:74
	ERR_WO_ERRNO("invalid enable type");
	// src/libpmemobj/ulog.c:245
	ERR_WO_ERRNO("cannot auto reserve next ulog");
	// src/libpmemobj/heap.c:768
	ERR_WO_ERRNO("lost runtime tracking info of %u run due to OOM", _u);
	// src/libpmemobj/heap.c:1051
	ERR_WO_ERRNO("lost runtime tracking info of %u run due to OOM", _u);
	// src/libpmemobj/heap.c:1167
	ERR_WO_ERRNO("lost runtime tracking info of %u run due to OOM", _u);
	// src/libpmemobj/heap.c:1410
	ERR_WO_ERRNO("at least one automatic arena must exist");
	// src/libpmemobj/heap.c:1605
	ERR_WO_ERRNO("mapped region smaller than the heap size");
	// src/libpmemobj/heap.c:1787
	ERR_WO_ERRNO("heap: invalid header's checksum");
	// src/libpmemobj/heap.c:1792
	ERR_WO_ERRNO("heap: invalid signature");
	// src/libpmemobj/heap.c:1810
	ERR_WO_ERRNO("heap: invalid zone size");
	// src/libpmemobj/heap.c:1825
	ERR_WO_ERRNO("heap: invalid chunk type");
	// src/libpmemobj/heap.c:1830
	ERR_WO_ERRNO("heap: unknown chunk type");
	// src/libpmemobj/heap.c:1835
	ERR_WO_ERRNO("heap: invalid chunk flags");
	// src/libpmemobj/heap.c:1852
	ERR_WO_ERRNO("heap: invalid zone magic");
	// src/libpmemobj/heap.c:1868
	ERR_WO_ERRNO("heap: chunk sizes mismatch");
	// src/libpmemobj/heap.c:1884
	ERR_WO_ERRNO("heap: invalid heap size");
	// src/libpmemobj/memops.c:575
	ERR_WO_ERRNO("Capacity insufficient");
	// src/libpmemobj/memops.c:586
	ERR_WO_ERRNO("Buffer currently used");
	// src/libpmemobj/memops.c:691
	ERR_WO_ERRNO("no extend function present");
	// src/libpmemobj/sync.c:43
	ERR_WO_ERRNO("error initializing lock");
	// src/libpmemobj/sync.c:50
	ERR_WO_ERRNO("error setting lock runid");
	// src/libpmemobj/obj.c:773
	ERR_WO_ERRNO("invalid checksum of pool descriptor");
	// src/libpmemobj/obj.c:780
	ERR_WO_ERRNO("wrong layout (\"%s\"), pool created with layout \"%s\"", _s, _s);
	// src/libpmemobj/obj.c:788
	ERR_WO_ERRNO("unaligned heap: off %lu", _lu);
	// src/libpmemobj/obj.c:1036
	ERR_WO_ERRNO("%s variable must be a positive integer", _s);
	// src/libpmemobj/obj.c:1065
	ERR_WO_ERRNO("Layout too long");
	// src/libpmemobj/obj.c:1114
	ERR_WO_ERRNO("initialization of replica #%u failed", _u);
	// src/libpmemobj/obj.c:1134
	ERR_WO_ERRNO("pool initialization failed");
	// src/libpmemobj/obj.c:1184
	ERR_WO_ERRNO("invalid run_id %lu", _lu);
	// src/libpmemobj/obj.c:1246
	ERR_WO_ERRNO("read-only mode is not supported");
	// src/libpmemobj/obj.c:1279
	ERR_WO_ERRNO("initialization of replica #%u failed", _u);
	// src/libpmemobj/obj.c:1319
	ERR_WO_ERRNO("inconsistent replica #%u", _u);
	// src/libpmemobj/obj.c:1405
	ERR_WO_ERRNO("pool initialization failed");
	// src/libpmemobj/obj.c:1537
	ERR_WO_ERRNO("critnib_remove for pools_ht");
	// src/libpmemobj/obj.c:1541
	ERR_WO_ERRNO("critnib_remove for pools_tree");
	// src/libpmemobj/obj.c:1724
	ERR_WO_ERRNO("requested size too large");
	// src/libpmemobj/obj.c:1767
	ERR_WO_ERRNO("allocation with size 0");
	// src/libpmemobj/obj.c:1798
	ERR_WO_ERRNO("allocation with size 0");
	// src/libpmemobj/obj.c:1804
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/obj.c:1843
	ERR_WO_ERRNO("allocation with size 0");
	// src/libpmemobj/obj.c:1921
	ERR_WO_ERRNO("requested size too large");
	// src/libpmemobj/obj.c:2298
	ERR_WO_ERRNO("invalid flags 0x%x", _u);
	// src/libpmemobj/obj.c:2316
	ERR_WO_ERRNO("invalid flags 0x%x", _u);
	// src/libpmemobj/obj.c:2418
	ERR_WO_ERRNO("requested size too large");
	// src/libpmemobj/obj.c:2424
	ERR_WO_ERRNO("requested size cannot equals zero");
	// src/libpmemobj/obj.c:2560
	ERR_WO_ERRNO("unknown flags 0x%lx", _lu);
	// src/libpmemobj/obj.c:2669
	ERR_WO_ERRNO("Not all PMEMoids belong to the provided pool");
	// src/libpmemobj/obj.c:2739
	ERR_WO_ERRNO("requested size too large");
	// src/libpmemobj/pmalloc.c:237
	ERR_WO_ERRNO("unit size must be evenly divisible by alignment");
	// src/libpmemobj/pmalloc.c:243
	ERR_WO_ERRNO("alignment cannot be larger than 2 megabytes");
	// src/libpmemobj/pmalloc.c:261
	ERR_WO_ERRNO("invalid header type");
	// src/libpmemobj/pmalloc.c:268
	ERR_WO_ERRNO("no available free allocation class identifier");
	// src/libpmemobj/pmalloc.c:278
	ERR_WO_ERRNO("class id outside of the allowed range");
	// src/libpmemobj/pmalloc.c:286
	ERR_WO_ERRNO("attempted to overwrite an allocation class");
	// src/libpmemobj/pmalloc.c:344
	ERR_WO_ERRNO("invalid header type");
	// src/libpmemobj/pmalloc.c:369
	ERR_WO_ERRNO("class id outside of the allowed range");
	// src/libpmemobj/pmalloc.c:380
	ERR_WO_ERRNO("class with the given id does not exist");
	// src/libpmemobj/pmalloc.c:459
	ERR_WO_ERRNO("incorrect size for extend, must be larger than %lu", _lu);
	// src/libpmemobj/pmalloc.c:511
	ERR_WO_ERRNO("incorrect grow size, must be 0 or larger than %lu", _lu);
	// src/libpmemobj/pmalloc.c:576
	ERR_WO_ERRNO("cannot change max arena number");
	// src/libpmemobj/pmalloc.c:642
	ERR_WO_ERRNO("arena id outside of the allowed range: <1,%u>", _u);
	// src/libpmemobj/pmalloc.c:680
	ERR_WO_ERRNO("arena id outside of the allowed range: <1,%u>", _u);
	// src/libpmemobj/pmalloc.c:687
	ERR_WO_ERRNO("incorrect arena state, must be 0 or 1");
	// src/libpmemobj/pmalloc.c:719
	ERR_WO_ERRNO("arena id outside of the allowed range: <1,%u>", _u);
	// src/libpmemobj/pmalloc.c:767
	ERR_WO_ERRNO("arena id outside of the allowed range: <1,%u>", _u);
	// src/libpmemobj/pmalloc.c:919
	ERR_WO_ERRNO("invalid arena assignment type");
	// src/libpmemobj/pmalloc.c:969
	ERR_WO_ERRNO("number of default arenas can't be 0");
	// src/common/set.c:257
	ERR_WO_ERRNO("unable to map at requested address %p", _p);
	// src/common/set.c:476
	ERR_WO_ERRNO("size autodetection is supported only for device dax");
	// src/common/set.c:732
	ERR_WO_ERRNO("cannot mix directories and files in a set");
	// src/common/set.c:758
	ERR_WO_ERRNO("cannot mix directories and files in a set");
	// src/common/set.c:768
	ERR_WO_ERRNO("cannot resolve realpath of new directory");
	// src/common/set.c:780
	ERR_WO_ERRNO("cannot use the same directory twice");
	// src/common/set.c:877
	ERR_WO_ERRNO("replica #%u part %u %smapped with MAP_SYNC", _u, _u, _s);
	// src/common/set.c:887
	ERR_WO_ERRNO("replica #%u part %u header %smapped with MAP_SYNC", _u, _u, _s);
	// src/common/set.c:916
	ERR_WO_ERRNO("either all the parts must be Device DAX or none");
	// src/common/set.c:926
	ERR_WO_ERRNO("Multiple DAX devices with alignment other than 4KB. Use the SINGLEHDR poolset option.");
	// src/common/set.c:945
	ERR_WO_ERRNO("both SINGLEHDR and NOHDR poolset options used at the same time");
	// src/common/set.c:1066
	ERR_WO_ERRNO("unable to load part %s", _s);
	// src/common/set.c:1105
	ERR_WO_ERRNO("failed to load parts from directory %s", _s);
	// src/common/set.c:1302
	ERR_WO_ERRNO("Remote replicas are no longer supported. This functionality is deprecated.");
	// src/common/set.c:1339
	ERR_WO_ERRNO("%s [%s:%d]", _s, _s, _d);
	// src/common/set.c:1357
	ERR_WO_ERRNO("cannot load part files from directories");
	// src/common/set.c:1511
	ERR_WO_ERRNO("file size does not match config: %s, %zu != %zu", _s, _zu, _zu);
	// src/common/set.c:1609
	ERR_WO_ERRNO("size must be zero for device dax");
	// src/common/set.c:1643
	ERR_WO_ERRNO("file is not a poolset file and its size (%zu) is smaller than %zu", _zu, _zu);
	// src/common/set.c:1680
	ERR_WO_ERRNO("poolset file options (%u) do not match incompat feature flags (%#x)", _u, _u);
	// src/common/set.c:1708
	ERR_WO_ERRNO("Non-empty file detected");
	// src/common/set.c:1816
	ERR_WO_ERRNO("invalid major version (0)");
	// src/common/set.c:1823
	ERR_WO_ERRNO("wrong pool type: \"%.8s\"", _8s);
	// src/common/set.c:1830
	ERR_WO_ERRNO("pool version %d (library expects %d)", _d, _d);
	// src/common/set.c:1833
	ERR_WO_ERRNO("Please run the pmdk-convert utility to upgrade the pool.");
	// src/common/set.c:1858
	ERR_WO_ERRNO("invalid checksum of pool header");
	// src/common/set.c:1866
	ERR_WO_ERRNO("wrong architecture flags");
	// src/common/set.c:1874
	ERR_WO_ERRNO("wrong pool set UUID");
	// src/common/set.c:1884
	ERR_WO_ERRNO("wrong part UUID");
	// src/common/set.c:1891
	ERR_WO_ERRNO("incompatible pool format");
	// src/common/set.c:1900
	ERR_WO_ERRNO("incompatible feature flags");
	// src/common/set.c:2253
	ERR_WO_ERRNO("cannot extend pool by 0 bytes");
	// src/common/set.c:2258
	ERR_WO_ERRNO("extending the pool by appending parts with headers is not supported!");
	// src/common/set.c:2266
	ERR_WO_ERRNO("exceeded reservation size");
	// src/common/set.c:2275
	ERR_WO_ERRNO("unable to append a new part to the pool");
	// src/common/set.c:2290
	ERR_WO_ERRNO("cannot open the new part");
	// src/common/set.c:2300
	ERR_WO_ERRNO("cannot map the new part");
	// src/common/set.c:2310
	ERR_WO_ERRNO("new part cannot be mapped with MAP_SYNC");
	// src/common/set.c:2313
	ERR_WO_ERRNO("new part mapped with MAP_SYNC");
	// src/common/set.c:2356
	ERR_WO_ERRNO("file contains bad blocks -- '%s'", _s);
	// src/common/set.c:2390
	ERR_WO_ERRNO("file %s already exists", _s);
	// src/common/set.c:2407
	ERR_WO_ERRNO("the NOHDRS poolset option is not supported for local poolsets");
	// src/common/set.c:2414
	ERR_WO_ERRNO("pool attributes are not supported for poolsets without headers (with the NOHDRS option)");
	// src/common/set.c:2421
	ERR_WO_ERRNO("directory based pools are not supported for poolsets with headers (without SINGLEHDR option)");
	// src/common/set.c:2428
	ERR_WO_ERRNO("reservation pool size %zu smaller than %zu", _zu, _zu);
	// src/common/set.c:2436
	ERR_WO_ERRNO("cannot create a new part in provided directories");
	// src/common/set.c:2455
	ERR_WO_ERRNO("pool set contains bad blocks and cannot be created, run 'pmempool create --clear-bad-blocks' utility to clear bad blocks and create a pool");
	// src/common/set.c:2463
	ERR_WO_ERRNO("net pool size %zu smaller than %zu", _zu, _zu);
	// src/common/set.c:2470
	ERR_WO_ERRNO("replication not supported");
	// src/common/set.c:2633
	ERR_WO_ERRNO("pool mapping failed - address space reservation too small");
	// src/common/set.c:2806
	ERR_WO_ERRNO("wrong replica UUID");
	// src/common/set.c:2862
	ERR_WO_ERRNO("device dax cannot be mapped privately");
	// src/common/set.c:2877
	ERR_WO_ERRNO("error: a bad block recovery file exists, run 'pmempool sync --bad-blocks' utility to try to recover the pool");
	// src/common/set.c:2900
	ERR_WO_ERRNO("pool set contains bad blocks and cannot be opened, run 'pmempool sync --bad-blocks' utility to try to recover the pool");
	// src/common/set.c:3018
	ERR_WO_ERRNO("device dax cannot be mapped privately");
	// src/common/set.c:3038
	ERR_WO_ERRNO("error: a bad block recovery file exists, run 'pmempool sync --bad-blocks' utility to try to recover the pool");
	// src/common/set.c:3064
	ERR_WO_ERRNO("pool set contains bad blocks and cannot be opened, run 'pmempool sync --bad-blocks' utility to try to recover the pool -- '%s'", _s);
	// src/common/set.c:3215
	ERR_WO_ERRNO("util_poolset_parse failed -- '%s'", _s);
	// src/common/set_badblocks.c:46
	ERR_WO_ERRNO("checking the pool file for bad blocks failed -- '%s'", _s);
	// src/common/set_badblocks.c:53
	ERR_WO_ERRNO("part file contains bad blocks -- '%s'", _s);
	// src/common/set_badblocks.c:120
	ERR_WO_ERRNO("clearing bad blocks in the pool file failed -- '%s'", _s);
	// src/common/shutdown_state.c:77
	ERR_WO_ERRNO("Cannot read unsafe shutdown count. For more information please check https://github.com/pmem/pmdk/issues/4207");
	// src/common/shutdown_state.c:87
	ERR_WO_ERRNO("cannot read uuid of %d", _d);
	// src/common/shutdown_state.c:101
	ERR_WO_ERRNO("cannot read uuid of %d", _d);
	// src/common/shutdown_state.c:232
	ERR_WO_ERRNO("an ADR failure was detected, the pool might be corrupted");
	// src/common/file.c:111
	ERR_WO_ERRNO("invalid (NULL) path");
	// src/common/file.c:182
	ERR_WO_ERRNO("file size (%ld) too big to be represented in 64-bit signed integer", _ld);
	// src/common/file.c:409
	ERR_WO_ERRNO("size %zu smaller than %zu", _zu, _zu);
	// src/common/file.c:415
	ERR_WO_ERRNO("invalid size (%zu) for os_off_t", _zu);
	// src/common/file.c:485
	ERR_WO_ERRNO("stat \"%s\": negative size", _s);
	// src/common/file.c:491
	ERR_WO_ERRNO("size %zu smaller than %zu", _zu, _zu);
	// src/common/mmap.c:287
	ERR_WO_ERRNO("duplicated persistent memory range; presumably unmapped with munmap() instead of pmem_unmap(): addr %p len %zu", _p, _zu);
	// src/common/mmap.c:308
	ERR_WO_ERRNO("Cannot find DAX device region id");
	// src/common/mmap.c:336
	ERR_WO_ERRNO("invalid munmap length, must be non-zero and page aligned");
	// src/common/ctl.c:215
	ERR_WO_ERRNO("read queries require non-NULL argument");
	// src/common/ctl.c:231
	ERR_WO_ERRNO("write queries require non-NULL argument");
	// src/common/ctl.c:278
	ERR_WO_ERRNO("invalid query");
	// src/common/ctl.c:302
	ERR_WO_ERRNO("invalid query entry point %s", _s);
	// src/common/ctl.c:374
	ERR_WO_ERRNO("failed to parse query %s", _s);
	// src/common/ctl.c:436
	ERR_WO_ERRNO("Config file too large");
	// src/common/ctl.c:562
	ERR_WO_ERRNO("invalid destination size %zu", _zu);
	// src/common/pool_hdr.c:116
	ERR_WO_ERRNO("invalid reserved values");
	// src/common/pool_hdr.c:121
	ERR_WO_ERRNO("invalid machine value");
	// src/common/pool_hdr.c:126
	ERR_WO_ERRNO("invalid data value");
	// src/common/pool_hdr.c:131
	ERR_WO_ERRNO("invalid machine_class value");
	// src/common/pool_hdr.c:136
	ERR_WO_ERRNO("invalid alignment_desc value");
	// src/common/pool_hdr.c:173
	ERR_WO_ERRNO("unsafe to continue due to unknown incompat features: %#x", _u);
	// src/common/pool_hdr.c:182
	ERR_WO_ERRNO("switching to read-only mode due to unknown ro_compat features: %#x", _u);
	// src/common/mmap_posix.c:90
	ERR_WO_ERRNO("end of address space reached");
}

void
call_all_CORE_LOG_WARNING(void)
{
	// src/libpmemobj/palloc.c:307
	CORE_LOG_WARNING("unable to track runtime chunk state");
	// src/libpmemobj/heap.c:1192
	CORE_LOG_WARNING("failed to allocate memory block runtime tracking info");
	// src/libpmemobj/heap.c:1204
	CORE_LOG_WARNING("failed to allocate memory block runtime tracking info");
	// src/libpmemobj/memops.c:352
	CORE_LOG_WARNING("out of memory - unable to track entries");
	// src/common/set.c:428
	CORE_LOG_WARNING("file permissions changed during pool initialization, file: %s (%o)", _s, _u);
	// src/common/set.c:2002
	CORE_LOG_WARNING("usable space mapping failed - part #%d - retrying", _d);
	// src/common/set.c:2649
	CORE_LOG_WARNING("usable space mapping failed - part #%d - retrying", _d);
	// src/common/set.c:2897
	CORE_LOG_WARNING("pool set contains bad blocks, ignoring");
	// src/common/set.c:2955
	CORE_LOG_WARNING("cannot open the part -- \"%s\"", _s);
	// src/common/set.c:3060
	CORE_LOG_WARNING("pool set contains bad blocks, ignoring -- '%s'", _s);
	// src/common/shutdown_state.c:206
	CORE_LOG_WARNING("incorrect checksum - SDS will be reinitialized");
	// src/common/shutdown_state.c:219
	CORE_LOG_WARNING("the pool was not closed - SDS will be reinitialized");
	// src/common/shutdown_state.c:226
	CORE_LOG_WARNING("an ADR failure was detected but the pool was closed - SDS will be reinitialized");
	// src/common/file.c:263
	CORE_LOG_WARNING("requested size of write goes beyond the file length, %zu > %zu", _zu, _zu);
	// src/common/file.c:326
	CORE_LOG_WARNING("requested size of write goes beyond the file length, %zu > %zu", _zu, _zu);
	// src/common/file.c:380
	CORE_LOG_WARNING("requested size of read goes beyond the file length, %zu > %zu", _zu, _zu);
	// src/common/mmap.c:54
	CORE_LOG_WARNING("Invalid PMEM_MMAP_HINT");
	// src/common/mmap.c:56
	CORE_LOG_WARNING("No /proc, PMEM_MMAP_HINT ignored");
}

void
call_all_CORE_LOG_ERROR(void)
{
	// src/tools/pmempool/common.c:1307
	CORE_LOG_ERROR("cannot open pool set -- '%s'", _s);
	// src/libpmem/pmem.c:480
	CORE_LOG_ERROR("failed to create temporary file at \"%s\"", _s);
	// src/libpmem/pmem_posix.c:61
	CORE_LOG_ERROR("can't track mapped region");
	// src/libpmemobj/lane.c:417
	CORE_LOG_ERROR("lane %lu internal redo failed: %d", _lu, _d);
	// src/libpmemobj/list.c:564
	CORE_LOG_ERROR("pmemobj_mutex_lock failed");
	// src/libpmemobj/list.c:603
	CORE_LOG_ERROR("pmemobj_mutex_lock failed");
	// src/libpmemobj/list.c:731
	CORE_LOG_ERROR("pmemobj_mutex_lock failed");
	// src/libpmemobj/list.c:765
	CORE_LOG_ERROR("pmemobj_mutex_lock failed");
	// src/libpmemobj/list.c:842
	CORE_LOG_ERROR("list_mutexes_lock failed");
	// src/libpmemobj/heap.c:1327
	CORE_LOG_ERROR("cannot decrease max number of arenas");
	// src/libpmemobj/obj.c:90
	CORE_LOG_ERROR("ctl_new");
	// src/libpmemobj/obj.c:105
	CORE_LOG_ERROR("unable to parse config stored in %s environment variable", _s);
	// src/libpmemobj/obj.c:116
	CORE_LOG_ERROR("unable to parse config stored in %s file (from %s environment variable)", _s, _s);
	// src/libpmemobj/obj.c:1090
	CORE_LOG_ERROR("cannot create pool or pool set");
	// src/libpmemobj/obj.c:1127
	CORE_LOG_ERROR("creation of pool descriptor failed");
	// src/libpmemobj/obj.c:1189
	CORE_LOG_ERROR("lane_check");
	// src/libpmemobj/obj.c:1198
	CORE_LOG_ERROR("heap_check");
	// src/libpmemobj/obj.c:1238
	CORE_LOG_ERROR("cannot open pool or pool set");
	// src/libpmemobj/obj.c:1375
	CORE_LOG_ERROR("descriptor check of replica #%u failed", _u);
	// src/libpmemobj/obj.c:2438
	CORE_LOG_ERROR("obj_realloc_root failed");
	// src/common/file_posix.c:115
	CORE_LOG_ERROR("Cannot open file %s", _s);
	// src/common/set.c:183
	CORE_LOG_ERROR("cannot find a contiguous region of given size");
	// src/common/set.c:343
	CORE_LOG_ERROR("replica open failed: replica %u", _u);
	// src/common/set.c:1053
	CORE_LOG_ERROR("cannot read size of file (%s) in a poolset directory", _s);
	// src/common/set.c:1484
	CORE_LOG_ERROR("failed to create file: %s", _s);
	// src/common/set.c:1494
	CORE_LOG_ERROR("failed to open file: %s", _s);
	// src/common/set.c:1964
	CORE_LOG_ERROR("cannot find a contiguous region of given size");
	// src/common/set.c:1972
	CORE_LOG_ERROR("pool mapping failed - replica #%u part #0", _u);
	// src/common/set.c:2016
	CORE_LOG_ERROR("usable space mapping failed - part #%d", _d);
	// src/common/set.c:2085
	CORE_LOG_ERROR("header mapping failed - part #%d", _d);
	// src/common/set.c:2093
	CORE_LOG_ERROR("header creation failed - part #%d", _d);
	// src/common/set.c:2130
	CORE_LOG_ERROR("replica #%u map failed", _u);
	// src/common/set.c:2139
	CORE_LOG_ERROR("replica #%u headers initialization failed", _u);
	// src/common/set.c:2398
	CORE_LOG_ERROR("cannot create pool set -- '%s'", _s);
	// src/common/set.c:2445
	CORE_LOG_ERROR("failed to check pool set for bad blocks -- '%s'", _s);
	// src/common/set.c:2485
	CORE_LOG_ERROR("cannot generate pool set UUID");
	// src/common/set.c:2497
	CORE_LOG_ERROR("cannot generate pool set part UUID");
	// src/common/set.c:2524
	CORE_LOG_ERROR("replica #%u creation failed", _u);
	// src/common/set.c:2591
	CORE_LOG_ERROR("cannot find a contiguous region of given size");
	// src/common/set.c:2601
	CORE_LOG_ERROR("pool mapping failed - replica #%u part #0", _u);
	// src/common/set.c:2615
	CORE_LOG_ERROR("header mapping failed - part #%d", _d);
	// src/common/set.c:2662
	CORE_LOG_ERROR("usable space mapping failed - part #%d", _d);
	// src/common/set.c:2793
	CORE_LOG_ERROR("header check failed - part #%d", _d);
	// src/common/set.c:2823
	CORE_LOG_ERROR("ADR failure detected");
	// src/common/set.c:2883
	CORE_LOG_ERROR("an error occurred when checking whether recovery file exists.");
	// src/common/set.c:2890
	CORE_LOG_ERROR("failed to check pool set for bad blocks");
	// src/common/set.c:2916
	CORE_LOG_ERROR("replica #%u open failed", _u);
	// src/common/set.c:2963
	CORE_LOG_ERROR("header mapping failed -- \"%s\"", _s);
	// src/common/set.c:3007
	CORE_LOG_ERROR("cannot open pool set -- '%s'", _s);
	// src/common/set.c:3030
	CORE_LOG_ERROR("reading compat features failed");
	// src/common/set.c:3045
	CORE_LOG_ERROR("an error occurred when checking whether recovery file exists.");
	// src/common/set.c:3052
	CORE_LOG_ERROR("failed to check pool set for bad blocks -- '%s'", _s);
	// src/common/set.c:3079
	CORE_LOG_ERROR("replica #%u open failed", _u);
	// src/common/set.c:3316
	CORE_LOG_ERROR("os_part_deep_common(%p, %p, %lu)", _p, _p, _lu);
	// src/common/set_badblocks.c:86
	CORE_LOG_ERROR("%i pool file(s) contain bad blocks", _d);
	// src/common/set_badblocks.c:213
	CORE_LOG_ERROR("allocating name of bad block recovery file failed");
	// src/common/shutdown_state.c:80
	CORE_LOG_ERROR("cannot read unsafe shutdown count for %d", _d);
	// src/common/file.c:212
	CORE_LOG_ERROR("cannot determine file length \"%s\"", _s);
	// src/common/file.c:218
	CORE_LOG_ERROR("failed to map entire file \"%s\"", _s);
	// src/common/file.c:250
	CORE_LOG_ERROR("cannot determine file length \"%s\"", _s);
	// src/common/file.c:256
	CORE_LOG_ERROR("offset beyond file length, %ju > %ju", _ju, _ju);
	// src/common/file.c:272
	CORE_LOG_ERROR("failed to map entire file \"%s\"", _s);
	// src/common/file.c:307
	CORE_LOG_ERROR("failed to open file \"%s\"", _s);
	// src/common/file.c:320
	CORE_LOG_ERROR("cannot determine file length \"%s\"", _s);
	// src/common/file.c:335
	CORE_LOG_ERROR("failed to map entire file \"%s\"", _s);
	// src/common/file.c:361
	CORE_LOG_ERROR("failed to open file \"%s\"", _s);
	// src/common/file.c:374
	CORE_LOG_ERROR("cannot determine file length \"%s\"", _s);
	// src/common/file.c:389
	CORE_LOG_ERROR("failed to map entire file \"%s\"", _s);
	// src/common/file.c:547
	CORE_LOG_ERROR("failed to open file \"%s\"", _s);
	// src/common/mmap.c:94
	CORE_LOG_ERROR("cannot find a contiguous region of given size");
	// src/common/ctl.c:238
	CORE_LOG_ERROR("Invalid arguments");
	// src/common/bad_blocks.c:152
	CORE_LOG_ERROR("pmem2_badblock_context_new failed -- %s", _s);
	// src/common/bad_blocks.c:161
	CORE_LOG_ERROR("pmem2_badblock_clear -- %s", _s);
	// src/common/bad_blocks.c:210
	CORE_LOG_ERROR("pmem2_badblock_context_new failed -- %s", _s);
	// src/common/bad_blocks.c:217
	CORE_LOG_ERROR("pmem2_badblock_clear -- %s", _s);
	// src/common/bad_blocks.c:255
	CORE_LOG_ERROR("counting bad blocks failed -- '%s'", _s);
	// src/common/bad_blocks.c:260
	CORE_LOG_ERROR("pool file '%s' contains %li bad block(s)", _s, _d);
	// src/common/uuid.c:24
	CORE_LOG_ERROR("invalid buffer for uuid string");
	// src/common/uuid.c:29
	CORE_LOG_ERROR("invalid uuid structure");
	// src/common/uuid.c:42
	CORE_LOG_ERROR("snprintf(uuid): %d", _d);
	// src/common/uuid.c:60
	CORE_LOG_ERROR("invalid uuid string");
	// src/common/uuid.c:66
	CORE_LOG_ERROR("invalid uuid string");
	// src/common/uuid.c:79
	CORE_LOG_ERROR("sscanf(uuid)");
	// src/common/os_deep_linux.c:38
	CORE_LOG_ERROR("deep_flush not supported");
	// src/common/os_deep_linux.c:42
	CORE_LOG_ERROR("cannot write to deep_flush in region %u", _u);
	// src/common/os_deep_linux.c:127
	CORE_LOG_ERROR("pmem_msync(%p, %lu)", _p, _lu);
	// src/common/os_deep_linux.c:156
	CORE_LOG_ERROR("deep_flush not supported");
	// src/common/os_deep_linux.c:159
	CORE_LOG_ERROR("invalid dax_region id %u", _u);
	// src/common/os_deep_linux.c:166
	CORE_LOG_ERROR("pmem2_deep_flush_write(%u)", _u);
	// src/common/os_deep_linux.c:175
	CORE_LOG_ERROR("pmem_msync(%p, %lu)", _p, _lu);
	// src/common/uuid_linux.c:31
	CORE_LOG_ERROR("open(uuid)");
	// src/common/uuid_linux.c:37
	CORE_LOG_ERROR("read(uuid)");
	// src/core/util_posix.c:52
	CORE_LOG_ERROR("stat failed for %s", _s);
	// src/core/util_posix.c:62
	CORE_LOG_ERROR("stat failed for %s", _s);
}

void
call_all_CORE_LOG_FATAL(void)
{
	// src/libpmem/pmem.c:362
	CORE_LOG_FATAL("util_bool_compare_and_swap32");
	// src/libpmem/pmem.c:915
	CORE_LOG_FATAL("invalid flush function address");
	// src/libpmemobj/lane.c:43
	CORE_LOG_FATAL("critnib_new");
	// src/libpmemobj/lane.c:80
	CORE_LOG_FATAL("os_tls_set");
	// src/libpmemobj/lane.c:105
	CORE_LOG_FATAL("os_tls_key_create");
	// src/libpmemobj/lane.c:483
	CORE_LOG_FATAL("Malloc");
	// src/libpmemobj/lane.c:499
	CORE_LOG_FATAL("critnib_insert");
	// src/libpmemobj/lane.c:555
	CORE_LOG_FATAL("lane_release");
	// src/libpmemobj/lane.c:560
	CORE_LOG_FATAL("util_bool_compare_and_swap64");
	// src/libpmemobj/memblock.c:1106
	CORE_LOG_FATAL("failed to initialize valgrind state");
	// src/libpmemobj/memblock.c:1146
	CORE_LOG_FATAL("failed to initialize valgrind state");
	// src/libpmemobj/memblock.c:1466
	CORE_LOG_FATAL("possible zone chunks metadata corruption");
	// src/libpmemobj/tx.c:161
	CORE_LOG_FATAL("%s called outside of transaction", _s);
	// src/libpmemobj/tx.c:272
	CORE_LOG_FATAL("Malloc");
	// src/libpmemobj/tx.c:284
	CORE_LOG_FATAL("Malloc");
	// src/libpmemobj/tx.c:321
	CORE_LOG_FATAL("Malloc");
	// src/libpmemobj/tx.c:574
	CORE_LOG_FATAL("invalid state of ranges tree");
	// src/libpmemobj/tx.c:769
	CORE_LOG_FATAL("Invalid stage %d to begin new transaction", _d);
	// src/libpmemobj/tx.c:807
	CORE_LOG_FATAL("transaction callback is already set, old %p new %p old_arg %p new_arg %p", _p, _p, _p, _p);
	// src/libpmemobj/tx.c:1049
	CORE_LOG_FATAL("pmemobj_tx_end called without pmemobj_tx_commit");
	// src/libpmemobj/tx.c:1053
	CORE_LOG_FATAL("pmemobj_tx_end called without pmemobj_tx_begin");
	// src/libpmemobj/palloc.c:304
	CORE_LOG_FATAL("duplicate runtime chunk state, possible double free");
	// src/libpmemobj/sync.h:87
	CORE_LOG_FATAL("pmemobj_mutex_lock");
	// src/libpmemobj/sync.h:102
	CORE_LOG_FATAL("pmemobj_mutex_unlock");
	// src/libpmemobj/obj.c:148
	CORE_LOG_FATAL("critnib_new for pools_ht");
	// src/libpmemobj/obj.c:156
	CORE_LOG_FATAL("critnib_new for pools_tree");
	// src/libpmemobj/obj.c:211
	CORE_LOG_FATAL("error: %s", _s);
	// src/libpmemobj/obj.c:252
	CORE_LOG_FATAL("pmem_msync");
	// src/common/set.c:221
	CORE_LOG_FATAL("munmap: %s", _s);
	// src/common/set.c:2220
	CORE_LOG_FATAL("cannot add a new part to the replica info");
	// src/common/util_pmem.h:30
	CORE_LOG_FATAL("pmem_msync");
	// src/core/last_error_msg.c:37
	CORE_LOG_FATAL("os_thread_key_create");
	// src/core/last_error_msg.c:78
	CORE_LOG_FATAL("os_tls_set");
	// src/core/sys_util.h:31
	CORE_LOG_FATAL("os_mutex_init");
	// src/core/sys_util.h:46
	CORE_LOG_FATAL("os_mutex_destroy");
	// src/core/sys_util.h:61
	CORE_LOG_FATAL("os_mutex_lock");
	// src/core/sys_util.h:77
	CORE_LOG_FATAL("os_mutex_trylock");
	// src/core/sys_util.h:93
	CORE_LOG_FATAL("os_mutex_unlock");
	// src/core/sys_util.h:108
	CORE_LOG_FATAL("os_rwlock_init");
	// src/core/sys_util.h:123
	CORE_LOG_FATAL("os_rwlock_rdlock");
	// src/core/sys_util.h:138
	CORE_LOG_FATAL("os_rwlock_wrlock");
	// src/core/sys_util.h:153
	CORE_LOG_FATAL("os_rwlock_unlock");
	// src/core/sys_util.h:168
	CORE_LOG_FATAL("os_rwlock_destroy");
	// src/core/sys_util.h:197
	CORE_LOG_FATAL("os_spin_destroy");
	// src/core/sys_util.h:211
	CORE_LOG_FATAL("os_spin_lock");
	// src/core/sys_util.h:226
	CORE_LOG_FATAL("os_spin_unlock");
	// src/core/sys_util.h:239
	CORE_LOG_FATAL("os_semaphore_init");
	// src/core/sys_util.h:249
	CORE_LOG_FATAL("os_semaphore_destroy");
	// src/core/sys_util.h:266
	CORE_LOG_FATAL("os_semaphore_wait");
	// src/core/sys_util.h:282
	CORE_LOG_FATAL("os_semaphore_trywait");
	// src/core/sys_util.h:294
	CORE_LOG_FATAL("os_semaphore_post");
	// src/core/sys_util.h:301
	CORE_LOG_FATAL("os_cond_init");
	// src/core/sys_util.h:308
	CORE_LOG_FATAL("os_cond_destroy");
	// src/core/core_assert.h:39
	CORE_LOG_FATAL("assertion failure: %s", _s);
	// src/core/core_assert.h:45
	CORE_LOG_FATAL("assertion failure: %s (%s = %s)", _s, _s, _s);
	// src/core/alloc.c:62
	CORE_LOG_FATAL("unknown allocation type");
	// src/core/out.c:113
	CORE_LOG_FATAL("Cannot set log threshold");
	// src/core/out.c:145
	CORE_LOG_FATAL("Cannot set legacy log function");
}

void
call_all_CORE_LOG_ERROR_W_ERRNO_LAST(int errnum)
{
	errno = errnum;
}

void
call_all_ERR_W_ERRNO(int errnum)
{
	errno = errnum;
	// src/libpmem/pmem.c:280
	ERR_W_ERRNO("msync");
	UT_ASSERTeq(errno, errnum);
	// src/libpmem/pmem.c:487
	ERR_W_ERRNO("open %s", _s);
	UT_ASSERTeq(errno, errnum);
	// src/libpmem/pmem.c:500
	ERR_W_ERRNO("ftruncate");
	UT_ASSERTeq(errno, errnum);
	// src/libpmem/pmem.c:506
	ERR_W_ERRNO("posix_fallocate");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/lane.c:267
	ERR_W_ERRNO("Malloc of volatile lanes");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/lane.c:276
	ERR_W_ERRNO("Malloc for lane locks");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/lane.c:289
	ERR_W_ERRNO("lane_init");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/tx.c:499
	ERR_W_ERRNO("pmemobj_mutex_lock");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/tx.c:508
	ERR_W_ERRNO("pmemobj_rwlock_wrlock");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/tx.c:776
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/tx.c:945
	ERR_W_ERRNO("explicit transaction abort");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/list.c:473
	ERR_W_ERRNO("palloc_reserve");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/stats.c:124
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/critnib.c:279
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/critnib.c:316
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/heap.c:187
	ERR_W_ERRNO("heap: arena malloc error");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/memops.c:90
	ERR_W_ERRNO("Zalloc");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/memops.c:116
	ERR_W_ERRNO("Zalloc");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/memops.c:177
	ERR_W_ERRNO("Zalloc");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/obj.c:662
	ERR_W_ERRNO("lane_boot");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/obj.c:667
	ERR_W_ERRNO("lane_recover_and_section_boot");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/obj.c:725
	ERR_W_ERRNO("palloc_init");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/obj.c:964
	ERR_W_ERRNO("critnib_insert to pools_ht");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/obj.c:969
	ERR_W_ERRNO("critnib_insert to pools_tree");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/obj.c:984
	ERR_W_ERRNO("ravl_new_sized");
	UT_ASSERTeq(errno, errnum);
	// src/common/file_posix.c:158
	ERR_W_ERRNO("stat \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:195
	ERR_W_ERRNO("mmap: %s", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:252
	ERR_W_ERRNO("mmap: %s", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:283
	ERR_W_ERRNO("munmap: %s", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:369
	ERR_W_ERRNO("unlink %s failed (part %u, replica %u)", _s, _u, _u);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:422
	ERR_W_ERRNO("fstat %d %s", _d, _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:435
	ERR_W_ERRNO("chmod %u/%u/%s", _u, _u, _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:518
	ERR_W_ERRNO("Strdup");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:622
	ERR_W_ERRNO("Strdup");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:648
	ERR_W_ERRNO("Realloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:841
	ERR_W_ERRNO("Realloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:849
	ERR_W_ERRNO("Zalloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1027
	ERR_W_ERRNO("fs_new: \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1060
	ERR_W_ERRNO("Strdup");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1139
	ERR_W_ERRNO("no directories in replica");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1156
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1196
	ERR_W_ERRNO("lseek %d", _d);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1202
	ERR_W_ERRNO("dup");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1208
	ERR_W_ERRNO("fdopen %d", _d);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1219
	ERR_W_ERRNO("Reading poolset file");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1226
	ERR_W_ERRNO("Malloc for pool set");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1232
	ERR_W_ERRNO("Strdup");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1404
	ERR_W_ERRNO("Malloc for pool set");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1410
	ERR_W_ERRNO("Strdup");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1419
	ERR_W_ERRNO("Malloc for pool set replica");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1503
	ERR_W_ERRNO("posix_fallocate \"%s\", %zu", _s, _zu);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1573
	ERR_W_ERRNO("open: path \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1632
	ERR_W_ERRNO("read %d", _d);
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:1756
	ERR_W_ERRNO("fstat");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:2212
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:3013
	ERR_W_ERRNO("no parts in replicas");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:3144
	ERR_W_ERRNO("read");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:3208
	ERR_W_ERRNO("open: path \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/set_badblocks.c:171
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/shutdown_state.c:95
	ERR_W_ERRNO("Zalloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/vecq.h:68
	ERR_W_ERRNO("Realloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:40
	ERR_W_ERRNO("os_access \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:94
	ERR_W_ERRNO("fstat");
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:126
	ERR_W_ERRNO("stat");
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:143
	ERR_W_ERRNO("open");
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:206
	ERR_W_ERRNO("open \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:244
	ERR_W_ERRNO("open \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:430
	ERR_W_ERRNO("open \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:435
	ERR_W_ERRNO("posix_fallocate \"%s\", %zu", _s, _zu);
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:440
	ERR_W_ERRNO("flock \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:469
	ERR_W_ERRNO("open \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:474
	ERR_W_ERRNO("flock \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/file.c:507
	ERR_W_ERRNO("flock unlock");
	UT_ASSERTeq(errno, errnum);
	// src/common/mmap.c:104
	ERR_W_ERRNO("mmap %zu bytes", _zu);
	UT_ASSERTeq(errno, errnum);
	// src/common/mmap.c:126
	ERR_W_ERRNO("munmap");
	UT_ASSERTeq(errno, errnum);
	// src/common/mmap.c:155
	ERR_W_ERRNO("mprotect: PROT_READ");
	UT_ASSERTeq(errno, errnum);
	// src/common/mmap.c:184
	ERR_W_ERRNO("mprotect: PROT_READ|PROT_WRITE");
	UT_ASSERTeq(errno, errnum);
	// src/common/mmap.c:213
	ERR_W_ERRNO("mprotect: PROT_NONE");
	UT_ASSERTeq(errno, errnum);
	// src/common/mmap.c:297
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/mmap.c:360
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/mmap.c:375
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/ctl.c:132
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/ctl.c:142
	ERR_W_ERRNO("strtok_r");
	UT_ASSERTeq(errno, errnum);
	// src/common/ctl.c:400
	ERR_W_ERRNO("Strdup");
	UT_ASSERTeq(errno, errnum);
	// src/common/ctl.c:445
	ERR_W_ERRNO("Zalloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/ctl.c:479
	ERR_W_ERRNO("Zalloc");
	UT_ASSERTeq(errno, errnum);
	// src/common/bad_blocks.c:63
	ERR_W_ERRNO("open %s", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/bad_blocks.c:142
	ERR_W_ERRNO("open %s", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/bad_blocks.c:200
	ERR_W_ERRNO("open %s", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/mmap_posix.c:43
	ERR_W_ERRNO("%s", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/mmap_posix.c:141
	ERR_W_ERRNO("mmap MAP_ANONYMOUS");
	UT_ASSERTeq(errno, errnum);
	// src/common/vec.h:62
	ERR_W_ERRNO("Realloc");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:181
	ERR_W_ERRNO("os_spin_init");
	UT_ASSERTeq(errno, errnum);
	// src/core/ravl.c:51
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/core/ravl.c:167
	ERR_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/core/util_posix.c:49
	ERR_W_ERRNO("stat failed for %s", _s);
	UT_ASSERTeq(errno, errnum);
	// src/core/util_posix.c:59
	ERR_W_ERRNO("stat failed for %s", _s);
	UT_ASSERTeq(errno, errnum);
	// src/core/util_posix.c:99
	ERR_W_ERRNO("mkstemp");
	UT_ASSERTeq(errno, errnum);
	// src/core/util_posix.c:138
	ERR_W_ERRNO("open");
	UT_ASSERTeq(errno, errnum);
	// src/core/out.c:126
	ERR_W_ERRNO("snprintf");
	UT_ASSERTeq(errno, errnum);
}

void
call_all_CORE_LOG_WARNING_W_ERRNO(int errnum)
{
	errno = errnum;
	// src/common/set.c:2955
	CORE_LOG_WARNING_W_ERRNO("cannot open the part -- \"%s\"", _s);
	UT_ASSERTeq(errno, errnum);
}

void
call_all_CORE_LOG_ERROR_W_ERRNO(int errnum)
{
	errno = errnum;
	// src/libpmemobj/obj.c:90
	CORE_LOG_ERROR_W_ERRNO("ctl_new");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/obj.c:1189
	CORE_LOG_ERROR_W_ERRNO("lane_check");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/obj.c:1198
	CORE_LOG_ERROR_W_ERRNO("heap_check");
	UT_ASSERTeq(errno, errnum);
	// src/common/os_deep_linux.c:38
	CORE_LOG_ERROR_W_ERRNO("deep_flush not supported");
	UT_ASSERTeq(errno, errnum);
	// src/common/os_deep_linux.c:156
	CORE_LOG_ERROR_W_ERRNO("deep_flush not supported");
	UT_ASSERTeq(errno, errnum);
	// src/common/uuid_linux.c:31
	CORE_LOG_ERROR_W_ERRNO("open(uuid)");
	UT_ASSERTeq(errno, errnum);
	// src/common/uuid_linux.c:37
	CORE_LOG_ERROR_W_ERRNO("read(uuid)");
	UT_ASSERTeq(errno, errnum);
}

void
call_all_CORE_LOG_FATAL_W_ERRNO(int errnum)
{
	errno = errnum;
	// src/libpmemobj/lane.c:80
	CORE_LOG_FATAL_W_ERRNO("os_tls_set");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/lane.c:105
	CORE_LOG_FATAL_W_ERRNO("os_tls_key_create");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/tx.c:272
	CORE_LOG_FATAL_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/tx.c:284
	CORE_LOG_FATAL_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/tx.c:321
	CORE_LOG_FATAL_W_ERRNO("Malloc");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/sync.h:87
	CORE_LOG_FATAL_W_ERRNO("pmemobj_mutex_lock");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/sync.h:102
	CORE_LOG_FATAL_W_ERRNO("pmemobj_mutex_unlock");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/obj.c:148
	CORE_LOG_FATAL_W_ERRNO("critnib_new for pools_ht");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/obj.c:156
	CORE_LOG_FATAL_W_ERRNO("critnib_new for pools_tree");
	UT_ASSERTeq(errno, errnum);
	// src/libpmemobj/obj.c:252
	CORE_LOG_FATAL_W_ERRNO("pmem_msync");
	UT_ASSERTeq(errno, errnum);
	// src/common/set.c:221
	CORE_LOG_FATAL_W_ERRNO("munmap: %s", _s);
	UT_ASSERTeq(errno, errnum);
	// src/common/util_pmem.h:30
	CORE_LOG_FATAL_W_ERRNO("pmem_msync");
	UT_ASSERTeq(errno, errnum);
	// src/core/last_error_msg.c:37
	CORE_LOG_FATAL_W_ERRNO("os_thread_key_create");
	UT_ASSERTeq(errno, errnum);
	// src/core/last_error_msg.c:78
	CORE_LOG_FATAL_W_ERRNO("os_tls_set");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:31
	CORE_LOG_FATAL_W_ERRNO("os_mutex_init");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:46
	CORE_LOG_FATAL_W_ERRNO("os_mutex_destroy");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:61
	CORE_LOG_FATAL_W_ERRNO("os_mutex_lock");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:77
	CORE_LOG_FATAL_W_ERRNO("os_mutex_trylock");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:93
	CORE_LOG_FATAL_W_ERRNO("os_mutex_unlock");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:108
	CORE_LOG_FATAL_W_ERRNO("os_rwlock_init");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:123
	CORE_LOG_FATAL_W_ERRNO("os_rwlock_rdlock");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:138
	CORE_LOG_FATAL_W_ERRNO("os_rwlock_wrlock");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:153
	CORE_LOG_FATAL_W_ERRNO("os_rwlock_unlock");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:168
	CORE_LOG_FATAL_W_ERRNO("os_rwlock_destroy");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:197
	CORE_LOG_FATAL_W_ERRNO("os_spin_destroy");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:211
	CORE_LOG_FATAL_W_ERRNO("os_spin_lock");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:226
	CORE_LOG_FATAL_W_ERRNO("os_spin_unlock");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:239
	CORE_LOG_FATAL_W_ERRNO("os_semaphore_init");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:249
	CORE_LOG_FATAL_W_ERRNO("os_semaphore_destroy");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:266
	CORE_LOG_FATAL_W_ERRNO("os_semaphore_wait");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:282
	CORE_LOG_FATAL_W_ERRNO("os_semaphore_trywait");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:294
	CORE_LOG_FATAL_W_ERRNO("os_semaphore_post");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:301
	CORE_LOG_FATAL_W_ERRNO("os_cond_init");
	UT_ASSERTeq(errno, errnum);
	// src/core/sys_util.h:308
	CORE_LOG_FATAL_W_ERRNO("os_cond_destroy");
	UT_ASSERTeq(errno, errnum);
}
