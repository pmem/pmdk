// SPDX-License-Identifier: BSD-3-Clause
/* Copyright 2024, Intel Corporation */

/*
 * This file is automatically generated by utils/call_stack_analysis/log_generate_all_calls.py.
 * Please do not modify manually.
 */

#include <limits.h>
#include <inttypes.h>
#include <libpmempool.h>
#include <libpmemobj.h>
#include <libpmem2.h>

#include "log_internal.h"
#include "all_calls.h"
#include "pool_hdr.h"

#define PATH "XXX"

static char *path = PATH;
static char *path1 = PATH;
static char *path2 = PATH;
static char *spath = PATH;
static char *file = PATH;
static char *directory = PATH;
static char *device_path = PATH;
static char *region_path = PATH;
static char *direpname = PATH;
static char *qbuf = PATH;
static char *name = PATH;
static char *pathp = PATH;
static char *Mmap_mapfile = "/proc/self/maps";
static size_t len = SIZE_MAX;
static size_t size = SIZE_MAX;
static unsigned r = UINT_MAX; /* set->nreplicas */
static unsigned repn = UINT_MAX;
static unsigned p = UINT_MAX; /* rep->nparts */
static unsigned partn = UINT_MAX;
static int fd = INT_MAX;
static int domain_fd = INT_MAX;

#define DOMAIN_VALUE_LEN 32
char domain_value[DOMAIN_VALUE_LEN] = PATH;

static uint32_t incompat = UINT32_MAX;
static uint32_t ro_compat = UINT32_MAX;
static uint32_t major = UINT32_MAX;

static char signature[POOL_HDR_SIG_LEN] = PATH;
static unsigned nlines = UINT_MAX;

#define SHORT_STR_LENGTH 50

static char parser_errstr[SHORT_STR_LENGTH] = "incorrect descriptor (must be a relative path)";
static unsigned repidx = UINT_MAX;
static unsigned options = UINT_MAX;

#define ERR_MSG_BB \
	"       please read the manual first and use this option\n"\
	"       ONLY IF you are sure that you know what you are doing"

static enum pmempool_pool_type check_pool_type = PMEMPOOL_POOL_TYPE_RESERVED4;

#define FEATURE_IS_NOT_ENABLED_PRIOR_STR	"enable %s prior to %s %s"
#define FEATURE_IS_NOT_DISABLED_PRIOR_STR	"disable %s prior to %s %s"

static uint32_t feature = UINT32_MAX;
static uint32_t question = UINT32_MAX;

static char *OBJ_NLANES_ENV_VARIABLE = "PMEMOBJ_NLANES";
static char layout[PMEMOBJ_MAX_LAYOUT] = PATH;

static uint64_t heap_offset = UINT64_MAX;
static uint64_t run_id = UINT64_MAX;

static int ret = INT_MAX;
static int flags = INT_MAX;

static ssize_t actual_len = SSIZE_MAX;

static unsigned major_required = UINT_MAX;
static unsigned minor_required = UINT_MAX;

static uint64_t flags64 = UINT64_MAX;

uint8_t aclass_id = UINT8_MAX;

static unsigned narenas = UINT_MAX;

static uint64_t ptr = UINT64_MAX;
static uint64_t addr = UINT64_MAX;
static uint64_t rsv = UINT64_MAX;
static uint64_t reserv_region = UINT64_MAX;
static uint64_t map = UINT64_MAX;

static size_t alignment = SIZE_MAX;
static size_t reserv_offset = SIZE_MAX;
static size_t offset = SIZE_MAX;
static size_t max_size = SIZE_MAX;

static unsigned prot = UINT_MAX;

static enum pmem2_sharing_type type = (enum pmem2_sharing_type)UINT64_MAX;
static enum pmem2_granularity g = (enum pmem2_granularity)UINT64_MAX;

static uint32_t st_mode = UINT32_MAX;

static size_t rsv_offset = SIZE_MAX;

static uint64_t length = UINT64_MAX;
static uint64_t reserved_length = UINT64_MAX;

static __off_t st_size = INT64_MAX;

#define SYSFS_ATTR_SIZE 1024

static char ndctl_bus[SYSFS_ATTR_SIZE] = PATH;

void
call_all_CORE_LOG_ERROR_LAST(void)
{

}

void
call_all_ERR_WO_ERRNO(void)
{
	// src/test/out_err/out_err.c:31
	ERR_WO_ERRNO("ERR #%d", 1);
	// src/tools/pmempool/output.c:779
	ERR_WO_ERRNO("snprintf for incompat features: %d", ret);
	// src/libpmem/pmem.c:413
	ERR_WO_ERRNO("invalid flag specified %x", flags);
	// src/libpmem/pmem.c:420
	ERR_WO_ERRNO( "flag unsupported for Device DAX %x", flags);
	// src/libpmem/pmem.c:429
	ERR_WO_ERRNO("unable to read Device DAX size");
	// src/libpmem/pmem.c:434
	ERR_WO_ERRNO( "Device DAX length must be either 0 or the exact size of the device: %zu", actual_len);
	// src/libpmem/pmem.c:446
	ERR_WO_ERRNO("invalid file length %zu", len);
	// src/libpmem/pmem.c:457
	ERR_WO_ERRNO( "non-zero 'len' not allowed without PMEM_FILE_CREATE");
	// src/libpmem/pmem.c:464
	ERR_WO_ERRNO("zero 'len' not allowed with PMEM_FILE_CREATE");
	// src/libpmem/pmem.c:470
	ERR_WO_ERRNO( "PMEM_FILE_TMPFILE not allowed without PMEM_FILE_CREATE");
	// src/libpmem/pmem.c:513
	ERR_WO_ERRNO("stat %s: negative size", path);
	// src/libpmem/pmem.c:588
	ERR_WO_ERRNO("invalid flags 0x%x", flags);
	// src/libpmem/pmem.c:619
	ERR_WO_ERRNO("invalid flags 0x%x", flags);
	// src/libpmem/pmem.c:651
	ERR_WO_ERRNO("invalid flags 0x%x", flags);
	// src/libpmem/libpmem.c:56
	ERR_WO_ERRNO( "libpmem major version mismatch (need %u, found %u)", major_required, 1);
	// src/libpmem/libpmem.c:63
	ERR_WO_ERRNO( "libpmem minor version mismatch (need %u, found %u)", minor_required, 1);
	// src/libpmem2/pmem2_utils_other.c:24
	ERR_WO_ERRNO("file type 0%o not supported", st_mode);
	// src/libpmem2/pmem2_utils_other.c:38
	ERR_WO_ERRNO("requested granularity not available because fd doesn't point to DAX-enabled file or kernel doesn't support MAP_SYNC flag (Linux >= 4.15)");
	// src/libpmem2/pmem2_utils_other.c:53
	ERR_WO_ERRNO("requested granularity not available because fd doesn't point to DAX-enabled file or kernel doesn't support MAP_SYNC flag (Linux >= 4.15)");
	// src/libpmem2/numa_none.c:17
	ERR_WO_ERRNO( "Cannot get numa node from source - ndctl is not available");
	// src/libpmem2/persist.c:34
	ERR_WO_ERRNO("invalid flags 0x%x", flags);
	// src/libpmem2/persist.c:58
	ERR_WO_ERRNO("invalid flags 0x%x", flags);
	// src/libpmem2/persist.c:342
	ERR_WO_ERRNO("Anonymous source does not support deep flush");
	// src/libpmem2/persist.c:441
	ERR_WO_ERRNO("invalid flags 0x%x", flags);
	// src/libpmem2/persist.c:463
	ERR_WO_ERRNO("invalid flags 0x%x", flags);
	// src/libpmem2/persist.c:486
	ERR_WO_ERRNO("invalid flags 0x%x", flags);
	// src/libpmem2/persist.c:506
	ERR_WO_ERRNO("invalid flags 0x%x", flags);
	// src/libpmem2/persist.c:527
	ERR_WO_ERRNO("invalid flags 0x%x", flags);
	// src/libpmem2/persist.c:547
	ERR_WO_ERRNO("invalid flags 0x%x", flags);
	// src/libpmem2/map_posix.c:304
	ERR_WO_ERRNO( "please define the max granularity requested for the mapping");
	// src/libpmem2/map_posix.c:354
	ERR_WO_ERRNO( "the directory is not a supported file type");
	// src/libpmem2/map_posix.c:364
	ERR_WO_ERRNO( "device DAX does not support mapping with MAP_PRIVATE");
	// src/libpmem2/map_posix.c:394
	ERR_WO_ERRNO( "virtual memory reservation offset %zu is not a multiple of %llu", rsv_offset, Mmap_align);
	// src/libpmem2/map_posix.c:402
	ERR_WO_ERRNO( "Reservation %p has not enough space for the intended content", rsv);
	// src/libpmem2/map_posix.c:411
	ERR_WO_ERRNO( "base mapping address %p (virtual memory reservation address + offset) is not a multiple of %zu required by device DAX", reserv_region, alignment);
	// src/libpmem2/map_posix.c:421
	ERR_WO_ERRNO( "region of the reservation %p at the offset %zu and length %zu is at least partly occupied by other mapping", rsv, rsv_offset, reserved_length);
	// src/libpmem2/map_posix.c:495
	ERR_WO_ERRNO("requested granularity not available because fd doesn't point to DAX-enabled file or kernel doesn't support MAP_SYNC flag (Linux >= 4.15)");
	// src/libpmem2/pmem2_utils_linux.c:43
	ERR_WO_ERRNO("file type 0%o not supported", st_mode);
	// src/libpmem2/pmem2_utils_ndctl.c:82
	ERR_WO_ERRNO( "Issue while reading Device Dax size - cannot find dax region");
	// src/libpmem2/region_namespace_ndctl.c:109
	ERR_WO_ERRNO("%s is empty", path);
	// src/libpmem2/region_namespace_ndctl.c:114
	ERR_WO_ERRNO("%s doesn't end with new line", path);
	// src/libpmem2/region_namespace_ndctl.c:155
	ERR_WO_ERRNO("cannot check region or namespace of a directory");
	// src/libpmem2/region_namespace_ndctl.c:253
	ERR_WO_ERRNO("unknown region");
	// src/libpmem2/usc_none.c:17
	ERR_WO_ERRNO("Cannot read device id - ndctl is not available");
	// src/libpmem2/usc_none.c:27
	ERR_WO_ERRNO("Cannot read device usc - ndctl is not available");
	// src/libpmem2/pmem2_utils_none.c:20
	ERR_WO_ERRNO( "Cannot read Device Dax alignment - ndctl is not available");
	// src/libpmem2/pmem2_utils_none.c:35
	ERR_WO_ERRNO("Cannot read Device Dax size - ndctl is not available");
	// src/libpmem2/source_posix.c:38
	ERR_WO_ERRNO("fd must be open with O_RDONLY or O_RDWR");
	// src/libpmem2/source_posix.c:65
	ERR_WO_ERRNO( "cannot set fd to directory in pmem2_source_from_fd");
	// src/libpmem2/source_posix.c:121
	ERR_WO_ERRNO( "kernel says size of regular file is negative (%ld)", st_size);
	// src/libpmem2/source_posix.c:170
	ERR_WO_ERRNO( "alignment (%zu) has to be a power of two", alignment);
	// src/libpmem2/source_posix.c:192
	ERR_WO_ERRNO( "File descriptor is not set, source type does not support fd");
	// src/libpmem2/usc_ndctl.c:29
	ERR_WO_ERRNO( "Anonymous source does not support unsafe shutdown count");
	// src/libpmem2/usc_ndctl.c:55
	ERR_WO_ERRNO( "Unsafe shutdown count is not supported for this source");
	// src/libpmem2/usc_ndctl.c:66
	ERR_WO_ERRNO( "Unsafe shutdown count is not supported for this source");
	// src/libpmem2/usc_ndctl.c:92
	ERR_WO_ERRNO("Anonymous source does not have device id");
	// src/libpmem2/map.c:129
	ERR_WO_ERRNO("offset is not a multiple of %lu", alignment);
	// src/libpmem2/map.c:217
	ERR_WO_ERRNO("Cannot find mapping %p to delete", map);
	// src/libpmem2/map.c:278
	ERR_WO_ERRNO( "Provided mapping(addr %p len %zu) is already registered by libpmem2", addr, len);
	// src/libpmem2/vm_reservation.c:116
	ERR_WO_ERRNO("address %p is not a multiple of 0x%llx", addr, Mmap_align);
	// src/libpmem2/vm_reservation.c:122
	ERR_WO_ERRNO("reservation size %zu is not a multiple of %llu", size, Mmap_align);
	// src/libpmem2/vm_reservation.c:190
	ERR_WO_ERRNO("vm reservation %p isn't empty", rsv);
	// src/libpmem2/vm_reservation.c:226
	ERR_WO_ERRNO( "mapping not found at the range (offset %zu, size %zu) in reservation %p", reserv_offset, len, rsv);
	// src/libpmem2/vm_reservation.c:253
	ERR_WO_ERRNO("mapping previous to mapping %p not found", map);
	// src/libpmem2/vm_reservation.c:278
	ERR_WO_ERRNO("mapping next to mapping %p not found", map);
	// src/libpmem2/vm_reservation.c:303
	ERR_WO_ERRNO("reservation %p stores no mapping", rsv);
	// src/libpmem2/vm_reservation.c:328
	ERR_WO_ERRNO("reservation %p stores no mapping", rsv);
	// src/libpmem2/vm_reservation.c:348
	ERR_WO_ERRNO( "mapping at the given region of the reservation already exists");
	// src/libpmem2/vm_reservation.c:372
	ERR_WO_ERRNO("Cannot find mapping %p in the reservation %p", map, rsv);
	// src/libpmem2/vm_reservation.c:435
	ERR_WO_ERRNO( "reservation extension size %zu is not a multiple of %llu", size, Pagesize);
	// src/libpmem2/vm_reservation.c:488
	ERR_WO_ERRNO( "reservation shrink offset %zu is not a multiple of %llu", offset, Mmap_align);
	// src/libpmem2/vm_reservation.c:495
	ERR_WO_ERRNO( "reservation shrink size %zu is not a multiple of %llu", size, Mmap_align);
	// src/libpmem2/vm_reservation.c:502
	ERR_WO_ERRNO( "reservation shrink offset %zu is out of reservation range", offset);
	// src/libpmem2/vm_reservation.c:509
	ERR_WO_ERRNO("reservation shrink size %zu cannot be zero", size);
	// src/libpmem2/vm_reservation.c:515
	ERR_WO_ERRNO( "reservation shrink size %zu stands out of reservation range", size);
	// src/libpmem2/vm_reservation.c:522
	ERR_WO_ERRNO( "shrinking reservation from the middle is not supported");
	// src/libpmem2/vm_reservation.c:528
	ERR_WO_ERRNO("shrinking whole reservation is not supported");
	// src/libpmem2/vm_reservation.c:534
	ERR_WO_ERRNO( "reservation region (offset %zu, size %zu) to be shrunk is occupied by a mapping", offset, size);
	// src/libpmem2/vm_reservation_posix.c:94
	ERR_WO_ERRNO("mapping exists in the given address");
	// src/libpmem2/pmem2_utils.h:22
	ERR_WO_ERRNO("errno is not set");
	// src/libpmem2/deep_flush_other.c:44
	ERR_WO_ERRNO("requested granularity not available because fd doesn't point to DAX-enabled file or kernel doesn't support MAP_SYNC flag (Linux >= 4.15)");
	// src/libpmem2/mcsafe_ops_posix.c:49
	ERR_WO_ERRNO( "physical I/O error occurred on read operation, possible bad block");
	// src/libpmem2/mcsafe_ops_posix.c:75
	ERR_WO_ERRNO( "physical I/O error occurred on write operation, possible bad block");
	// src/libpmem2/mcsafe_ops_posix.c:137
	ERR_WO_ERRNO("physical I/O error occurred, possible bad block");
	// src/libpmem2/mcsafe_ops_posix.c:279
	ERR_WO_ERRNO( "operation doesn't support provided source type, only sources created from file descriptor or file handle are supported");
	// src/libpmem2/mcsafe_ops_posix.c:301
	ERR_WO_ERRNO( "size of read %zu from offset %zu goes beyond the file length %zu", size, offset, max_size);
	// src/libpmem2/badblocks_ndctl.c:118
	ERR_WO_ERRNO( "(pfn) cannot read offset of the namespace");
	// src/libpmem2/badblocks_ndctl.c:125
	ERR_WO_ERRNO("(pfn) cannot read size of the namespace");
	// src/libpmem2/badblocks_ndctl.c:134
	ERR_WO_ERRNO( "(dax) cannot read offset of the namespace");
	// src/libpmem2/badblocks_ndctl.c:141
	ERR_WO_ERRNO("(dax) cannot read size of the namespace");
	// src/libpmem2/badblocks_ndctl.c:150
	ERR_WO_ERRNO( "(raw/btt) cannot read offset of the namespace");
	// src/libpmem2/badblocks_ndctl.c:157
	ERR_WO_ERRNO( "(raw/btt) cannot read size of the namespace");
	// src/libpmem2/badblocks_ndctl.c:195
	ERR_WO_ERRNO("ndctl_bus_cmd_new_ars_cap() failed (bus '%s')", ndctl_bus);
	// src/libpmem2/badblocks_ndctl.c:202
	ERR_WO_ERRNO("ndctl_cmd_submit() failed (bus '%s')", ndctl_bus);
	// src/libpmem2/badblocks_ndctl.c:211
	ERR_WO_ERRNO("ndctl_cmd_ars_cap_get_range() failed");
	// src/libpmem2/badblocks_ndctl.c:221
	ERR_WO_ERRNO("ndctl_cmd_submit() failed (bus '%s')", ndctl_bus);
	// src/libpmem2/badblocks_ndctl.c:234
	ERR_WO_ERRNO("failed to clear %llu out of %llu bad blocks", length, length);
	// src/libpmem2/badblocks_ndctl.c:263
	ERR_WO_ERRNO("Anonymous source does not support bad blocks");
	// src/libpmem2/badblocks_ndctl.c:554
	ERR_WO_ERRNO( "Cannot find any matching device, no bad blocks found");
	// src/libpmem2/badblocks_ndctl.c:695
	ERR_WO_ERRNO("bad block's offset is greater than INT64_MAX");
	// src/libpmem2/badblocks_ndctl.c:701
	ERR_WO_ERRNO("bad block's length is greater than INT64_MAX");
	// src/libpmem2/config.c:80
	ERR_WO_ERRNO("unknown granularity value %d", g);
	// src/libpmem2/config.c:99
	ERR_WO_ERRNO("offset is greater than INT64_MAX");
	// src/libpmem2/config.c:132
	ERR_WO_ERRNO("file length is equal 0");
	// src/libpmem2/config.c:137
	ERR_WO_ERRNO("length is not a multiple of %lu", alignment);
	// src/libpmem2/config.c:144
	ERR_WO_ERRNO("overflow of offset and length");
	// src/libpmem2/config.c:152
	ERR_WO_ERRNO("mapping larger than file size");
	// src/libpmem2/config.c:173
	ERR_WO_ERRNO("unknown sharing value %d", type);
	// src/libpmem2/config.c:209
	ERR_WO_ERRNO("invalid flag %u", prot);
	// src/libpmem2/deep_flush.c:30
	ERR_WO_ERRNO( "requested deep flush rage ptr %p size %zu exceeds map range %p", ptr, size, map);
	// src/libpmem2/extent_linux.c:50
	ERR_WO_ERRNO( "checking extents does not make sense in case of directories");
	// src/libpmem2/numa_ndctl.c:28
	ERR_WO_ERRNO("Anonymous sources are not bound to numa nodes.");
	// src/libpmem2/numa_ndctl.c:47
	ERR_WO_ERRNO("unknown region");
	// src/libpmem2/auto_flush_linux.c:52
	ERR_WO_ERRNO("read(%d, %p, %d) empty string", domain_fd, domain_value, DOMAIN_VALUE_LEN);
	// src/libpmemobj/alloc_class.c:231
	ERR_WO_ERRNO( "unable to register allocation class");
	// src/libpmemobj/tx.c:513
	ERR_WO_ERRNO("Unrecognized lock type");
	// src/libpmemobj/tx.c:550
	ERR_WO_ERRNO("Unrecognized lock type");
	// src/libpmemobj/tx.c:588
	ERR_WO_ERRNO("requested size too large");
	// src/libpmemobj/tx.c:617
	ERR_WO_ERRNO("out of memory");
	// src/libpmemobj/tx.c:633
	ERR_WO_ERRNO("requested size too large");
	// src/libpmemobj/tx.c:647
	ERR_WO_ERRNO("pmemobj_tx_free failed");
	// src/libpmemobj/tx.c:665
	ERR_WO_ERRNO("pmemobj_tx_free failed");
	// src/libpmemobj/tx.c:682
	ERR_WO_ERRNO("Buffer from a different pool");
	// src/libpmemobj/tx.c:739
	ERR_WO_ERRNO("nested transaction for different pool");
	// src/libpmemobj/tx.c:865
	ERR_WO_ERRNO("unknown flags 0x%" PRIx64, flags64);
	// src/libpmemobj/tx.c:1236
	ERR_WO_ERRNO("snapshot size too large");
	// src/libpmemobj/tx.c:1243
	ERR_WO_ERRNO("object outside of heap");
	// src/libpmemobj/tx.c:1383
	ERR_WO_ERRNO("out of memory");
	// src/libpmemobj/tx.c:1410
	ERR_WO_ERRNO("object outside of pool");
	// src/libpmemobj/tx.c:1448
	ERR_WO_ERRNO("unknown flags 0x%" PRIx64, flags64);
	// src/libpmemobj/tx.c:1456
	ERR_WO_ERRNO("object outside of pool");
	// src/libpmemobj/tx.c:1493
	ERR_WO_ERRNO("invalid pool uuid");
	// src/libpmemobj/tx.c:1531
	ERR_WO_ERRNO("unknown flags 0x%" PRIx64, flags64);
	// src/libpmemobj/tx.c:1539
	ERR_WO_ERRNO("invalid pool uuid");
	// src/libpmemobj/tx.c:1576
	ERR_WO_ERRNO("allocation with size 0");
	// src/libpmemobj/tx.c:1607
	ERR_WO_ERRNO("allocation with size 0");
	// src/libpmemobj/tx.c:1638
	ERR_WO_ERRNO("allocation with size 0");
	// src/libpmemobj/tx.c:1645
	ERR_WO_ERRNO("unknown flags 0x%" PRIx64, flags64);
	// src/libpmemobj/tx.c:1714
	ERR_WO_ERRNO("unknown flags 0x%" PRIx64, flags64);
	// src/libpmemobj/tx.c:1722
	ERR_WO_ERRNO("cannot duplicate NULL string");
	// src/libpmemobj/tx.c:1772
	ERR_WO_ERRNO("unknown flags 0x%" PRIx64, flags64);
	// src/libpmemobj/tx.c:1780
	ERR_WO_ERRNO("cannot duplicate NULL string");
	// src/libpmemobj/tx.c:1831
	ERR_WO_ERRNO("unknown flags 0x%" PRIx64, flags64);
	// src/libpmemobj/tx.c:1842
	ERR_WO_ERRNO("invalid pool uuid");
	// src/libpmemobj/tx.c:1914
	ERR_WO_ERRNO("unknown flags 0x%" PRIx64, flags64);
	// src/libpmemobj/tx.c:1959
	ERR_WO_ERRNO("unknown flags 0x%" PRIx64, flags64);
	// src/libpmemobj/tx.c:2208
	ERR_WO_ERRNO( "invalid cache size, must be between 0 and max alloc size");
	// src/libpmemobj/tx.c:2232
	ERR_WO_ERRNO("tx.cache.threshold parameter is deprecated");
	// src/libpmemobj/tx.c:2247
	ERR_WO_ERRNO("tx.cache.threshold parameter is deprecated");
	// src/libpmemobj/palloc.c:196
	ERR_WO_ERRNO("no allocation class for size %lu bytes", size);
	// src/libpmemobj/palloc.c:211
	ERR_WO_ERRNO("allocation class not suitable for size %lu bytes", size);
	// src/libpmemobj/palloc.c:275
	ERR_WO_ERRNO("invalid operation or heap corruption");
	// src/libpmemobj/pmalloc.c:237
	ERR_WO_ERRNO("unit size must be evenly divisible by alignment");
	// src/libpmemobj/pmalloc.c:243
	ERR_WO_ERRNO("alignment cannot be larger than 2 megabytes");
	// src/libpmemobj/pmalloc.c:261
	ERR_WO_ERRNO("invalid header type");
	// src/libpmemobj/pmalloc.c:268
	ERR_WO_ERRNO( "no available free allocation class identifier");
	// src/libpmemobj/pmalloc.c:278
	ERR_WO_ERRNO("class id outside of the allowed range");
	// src/libpmemobj/pmalloc.c:286
	ERR_WO_ERRNO( "attempted to overwrite an allocation class");
	// src/libpmemobj/pmalloc.c:344
	ERR_WO_ERRNO("invalid header type");
	// src/libpmemobj/pmalloc.c:369
	ERR_WO_ERRNO("class id outside of the allowed range");
	// src/libpmemobj/pmalloc.c:380
	ERR_WO_ERRNO("class with the given id does not exist");
	// src/libpmemobj/pmalloc.c:459
	ERR_WO_ERRNO( "incorrect size for extend, must be larger than %" PRIu64, PMEMOBJ_MIN_PART);
	// src/libpmemobj/pmalloc.c:511
	ERR_WO_ERRNO( "incorrect grow size, must be 0 or larger than %" PRIu64, PMEMOBJ_MIN_PART);
	// src/libpmemobj/pmalloc.c:576
	ERR_WO_ERRNO("cannot change max arena number");
	// src/libpmemobj/pmalloc.c:642
	ERR_WO_ERRNO("arena id outside of the allowed range: <1,%u>", narenas);
	// src/libpmemobj/pmalloc.c:680
	ERR_WO_ERRNO("arena id outside of the allowed range: <1,%u>", narenas);
	// src/libpmemobj/pmalloc.c:687
	ERR_WO_ERRNO("incorrect arena state, must be 0 or 1");
	// src/libpmemobj/pmalloc.c:719
	ERR_WO_ERRNO("arena id outside of the allowed range: <1,%u>", narenas);
	// src/libpmemobj/pmalloc.c:767
	ERR_WO_ERRNO("arena id outside of the allowed range: <1,%u>", narenas);
	// src/libpmemobj/pmalloc.c:919
	ERR_WO_ERRNO("invalid arena assignment type");
	// src/libpmemobj/pmalloc.c:969
	ERR_WO_ERRNO("number of default arenas can't be 0");
	// src/libpmemobj/libpmemobj.c:52
	ERR_WO_ERRNO( "libpmemobj major version mismatch (need %u, found %u)", major_required, PMEMOBJ_MAJOR_VERSION);
	// src/libpmemobj/libpmemobj.c:59
	ERR_WO_ERRNO( "libpmemobj minor version mismatch (need %u, found %u)", minor_required, PMEMOBJ_MINOR_VERSION);
	// src/libpmemobj/stats.c:74
	ERR_WO_ERRNO("invalid enable type");
	// src/libpmemobj/ulog.c:245
	ERR_WO_ERRNO("cannot auto reserve next ulog");
	// src/libpmemobj/heap.c:768
	ERR_WO_ERRNO( "lost runtime tracking info of %u run due to OOM", aclass_id);
	// src/libpmemobj/heap.c:1051
	ERR_WO_ERRNO("lost runtime tracking info of %u run due to OOM", aclass_id);
	// src/libpmemobj/heap.c:1167
	ERR_WO_ERRNO("lost runtime tracking info of %u run due to OOM", aclass_id);
	// src/libpmemobj/heap.c:1410
	ERR_WO_ERRNO("at least one automatic arena must exist");
	// src/libpmemobj/heap.c:1605
	ERR_WO_ERRNO("mapped region smaller than the heap size");
	// src/libpmemobj/heap.c:1787
	ERR_WO_ERRNO("heap: invalid header's checksum");
	// src/libpmemobj/heap.c:1792
	ERR_WO_ERRNO("heap: invalid signature");
	// src/libpmemobj/heap.c:1810
	ERR_WO_ERRNO("heap: invalid zone size");
	// src/libpmemobj/heap.c:1825
	ERR_WO_ERRNO("heap: invalid chunk type");
	// src/libpmemobj/heap.c:1830
	ERR_WO_ERRNO("heap: unknown chunk type");
	// src/libpmemobj/heap.c:1835
	ERR_WO_ERRNO("heap: invalid chunk flags");
	// src/libpmemobj/heap.c:1852
	ERR_WO_ERRNO("heap: invalid zone magic");
	// src/libpmemobj/heap.c:1868
	ERR_WO_ERRNO("heap: chunk sizes mismatch");
	// src/libpmemobj/heap.c:1884
	ERR_WO_ERRNO("heap: invalid heap size");
	// src/libpmemobj/memops.c:575
	ERR_WO_ERRNO("Capacity insufficient");
	// src/libpmemobj/memops.c:586
	ERR_WO_ERRNO("Buffer currently used");
	// src/libpmemobj/memops.c:691
	ERR_WO_ERRNO("no extend function present");
	// src/libpmemobj/sync.c:43
	ERR_WO_ERRNO("error initializing lock");
	// src/libpmemobj/sync.c:50
	ERR_WO_ERRNO("error setting lock runid");
	// src/libpmemobj/obj.c:773
	ERR_WO_ERRNO("invalid checksum of pool descriptor");
	// src/libpmemobj/obj.c:780
	ERR_WO_ERRNO( "wrong layout (\"%s\"), pool created with layout \"%s\"", layout, layout);
	// src/libpmemobj/obj.c:788
	ERR_WO_ERRNO("unaligned heap: off %" PRIu64, heap_offset);
	// src/libpmemobj/obj.c:1036
	ERR_WO_ERRNO("%s variable must be a positive integer", OBJ_NLANES_ENV_VARIABLE);
	// src/libpmemobj/obj.c:1065
	ERR_WO_ERRNO("Layout too long");
	// src/libpmemobj/obj.c:1114
	ERR_WO_ERRNO("initialization of replica #%u failed", r);
	// src/libpmemobj/obj.c:1134
	ERR_WO_ERRNO("pool initialization failed");
	// src/libpmemobj/obj.c:1184
	ERR_WO_ERRNO("invalid run_id %" PRIu64, run_id);
	// src/libpmemobj/obj.c:1246
	ERR_WO_ERRNO("read-only mode is not supported");
	// src/libpmemobj/obj.c:1279
	ERR_WO_ERRNO("initialization of replica #%u failed", r);
	// src/libpmemobj/obj.c:1319
	ERR_WO_ERRNO("inconsistent replica #%u", r);
	// src/libpmemobj/obj.c:1405
	ERR_WO_ERRNO("pool initialization failed");
	// src/libpmemobj/obj.c:1537
	ERR_WO_ERRNO("critnib_remove for pools_ht");
	// src/libpmemobj/obj.c:1541
	ERR_WO_ERRNO("critnib_remove for pools_tree");
	// src/libpmemobj/obj.c:1724
	ERR_WO_ERRNO("requested size too large");
	// src/libpmemobj/obj.c:1767
	ERR_WO_ERRNO("allocation with size 0");
	// src/libpmemobj/obj.c:1798
	ERR_WO_ERRNO("allocation with size 0");
	// src/libpmemobj/obj.c:1804
	ERR_WO_ERRNO("unknown flags 0x%" PRIx64, flags64);
	// src/libpmemobj/obj.c:1843
	ERR_WO_ERRNO("allocation with size 0");
	// src/libpmemobj/obj.c:1921
	ERR_WO_ERRNO("requested size too large");
	// src/libpmemobj/obj.c:2298
	ERR_WO_ERRNO("invalid flags 0x%x", flags);
	// src/libpmemobj/obj.c:2316
	ERR_WO_ERRNO("invalid flags 0x%x", flags);
	// src/libpmemobj/obj.c:2418
	ERR_WO_ERRNO("requested size too large");
	// src/libpmemobj/obj.c:2424
	ERR_WO_ERRNO("requested size cannot equals zero");
	// src/libpmemobj/obj.c:2560
	ERR_WO_ERRNO("unknown flags 0x%" PRIx64, flags64);
	// src/libpmemobj/obj.c:2669
	ERR_WO_ERRNO( "Not all PMEMoids belong to the provided pool");
	// src/libpmemobj/obj.c:2739
	ERR_WO_ERRNO("requested size too large");
	// src/libpmempool/libpmempool.c:59
	ERR_WO_ERRNO( "libpmempool major version mismatch (need %u, found %u)", major_required, PMEMPOOL_MAJOR_VERSION);
	// src/libpmempool/libpmempool.c:66
	ERR_WO_ERRNO( "libpmempool minor version mismatch (need %u, found %u)", minor_required, PMEMPOOL_MINOR_VERSION);
	// src/libpmempool/libpmempool.c:135
	ERR_WO_ERRNO("provided args_size is not supported");
	// src/libpmempool/libpmempool.c:149
	ERR_WO_ERRNO( "dry_run, advanced and always_yes are applicable " "only if repair is set");
	// src/libpmempool/libpmempool.c:161
	ERR_WO_ERRNO("dry run does not allow one to perform backup");
	// src/libpmempool/libpmempool.c:170
	ERR_WO_ERRNO("PMEMPOOL_CHECK_FORMAT_STR flag must be set");
	// src/libpmempool/check_backup.c:103
	ERR_WO_ERRNO("not implemented question id: %u", question);
	// src/libpmempool/check_backup.c:268
	ERR_WO_ERRNO("not implemented question id: %u", question);
	// src/libpmempool/check_pool_hdr.c:219
	ERR_WO_ERRNO("not implemented question id: %u", question);
	// src/libpmempool/check_pool_hdr.c:318
	ERR_WO_ERRNO("not implemented question id: %u", question);
	// src/libpmempool/check_pool_hdr.c:461
	ERR_WO_ERRNO("not implemented question id: %u", question);
	// src/libpmempool/check_pool_hdr.c:584
	ERR_WO_ERRNO("not implemented question id: %u", question);
	// src/libpmempool/check_pool_hdr.c:686
	ERR_WO_ERRNO("not implemented question id: %u", question);
	// src/libpmempool/check_pool_hdr.c:739
	ERR_WO_ERRNO("not implemented question id: %u", question);
	// src/libpmempool/check_sds.c:129
	ERR_WO_ERRNO("not implemented question id: %u", question);
	// src/libpmempool/check_util.c:267
	ERR_WO_ERRNO("no error message for the user");
	// src/libpmempool/check_util.c:625
	ERR_WO_ERRNO("failed to convert uuid to string");
	// src/libpmempool/feature.c:50
	ERR_WO_ERRNO("vsprintf");
	// src/libpmempool/feature.c:55
	ERR_WO_ERRNO("buffer truncated %d >= %zu", ret, size);
	// src/libpmempool/feature.c:113
	ERR_WO_ERRNO("features mismatch detected: %s", "{compat 0xFFFFFF, incompat 0xFFFFFF, ro_compat 0xFFFFFF} != {compat 0xFFFFFF, incompat 0xFFFFFF, ro_compat 0xFFFFFF}");
	// src/libpmempool/feature.c:133
	ERR_WO_ERRNO("invalid features detected: %s", "{compat 0xFFFFFF, incompat 0xFFFFFF, ro_compat 0xFFFFFF} != {compat 0xFFFFFF, incompat 0xFFFFFF, ro_compat 0xFFFFFF}");
	// src/libpmempool/feature.c:175
	ERR_WO_ERRNO("cannot open pool set -- '%s'", path);
	// src/libpmempool/feature.c:199
	ERR_WO_ERRNO( "invalid features - replica #%d part #%d", r, p);
	// src/libpmempool/feature.c:305
	ERR_WO_ERRNO(FEATURE_IS_NOT_ENABLED_PRIOR_STR, "CHECK_BAD_BLOCKS", "disabling", "CHECK_BAD_BLOCKS");
	// src/libpmempool/feature.c:309
	ERR_WO_ERRNO(FEATURE_IS_NOT_DISABLED_PRIOR_STR, "CHECK_BAD_BLOCKS", "disabling", "CHECK_BAD_BLOCKS");
	// src/libpmempool/feature.c:360
	ERR_WO_ERRNO("unsupported feature: %s", "CHECK_BAD_BLOCKS");
	// src/libpmempool/feature.c:607
	ERR_WO_ERRNO("invalid flags: 0x%x", flags);
	// src/libpmempool/feature.c:621
	ERR_WO_ERRNO("invalid feature: 0x%x", feature);
	// src/libpmempool/pool.c:49
	ERR_WO_ERRNO("cannot open poolset part file");
	// src/libpmempool/pool.c:56
	ERR_WO_ERRNO("cannot read pool header from poolset");
	// src/libpmempool/pool.c:86
	ERR_WO_ERRNO("cannot determine pool type from poolset");
	// src/libpmempool/pool.c:100
	ERR_WO_ERRNO("opening poolset failed");
	// src/libpmempool/pool.c:139
	ERR_WO_ERRNO( "can not convert pmempool_pool_type %u to pool_type", check_pool_type);
	// src/libpmempool/pool.c:249
	ERR_WO_ERRNO("declared pool type does not match");
	// src/libpmempool/pool.c:315
	ERR_WO_ERRNO("%s", path);
	// src/libpmempool/pool.c:755
	ERR_WO_ERRNO("cannot read pool header from poolset");
	// src/libpmempool/pool.c:774
	ERR_WO_ERRNO("unknown type of a pool");
	// src/libpmempool/replica.c:135
	ERR_WO_ERRNO("clearing bad blocks in device dax failed -- '%s'", path);
	// src/libpmempool/replica.c:645
	ERR_WO_ERRNO("invalid checksum of pool header");
	// src/libpmempool/replica.c:653
	ERR_WO_ERRNO("invalid signature");
	// src/libpmempool/replica.c:786
	ERR_WO_ERRNO( "wrong format of bad block recovery file (bad blocks are not sorted by the offset in ascending order) -- '%s'", path);
	// src/libpmempool/replica.c:1212
	ERR_WO_ERRNO( "error: a bad block recovery file exists, run 'pmempool sync --bad-blocks' to fix bad blocks first");
	// src/libpmempool/replica.c:1218
	ERR_WO_ERRNO( "error: a bad block recovery file exists, but the '--bad-blocks' option is not set\n" ERR_MSG_BB);
	// src/libpmempool/replica.c:1325
	ERR_WO_ERRNO( "error: bad blocks found, run 'pmempool sync --bad-blocks' to fix bad blocks first");
	// src/libpmempool/replica.c:1331
	ERR_WO_ERRNO( "error: bad blocks found, but the '--bad-blocks' option is not set\n" ERR_MSG_BB);
	// src/libpmempool/replica.c:1369
	ERR_WO_ERRNO("clearing bad blocks failed");
	// src/libpmempool/replica.c:1452
	ERR_WO_ERRNO( "different poolset uuids in parts from the same replica (repn %u, parts %u and %u) - cannot synchronize", repn, partn, p);
	// src/libpmempool/replica.c:1481
	ERR_WO_ERRNO( "different adjacent replica UUID between parts (repn %u, parts %u and %u) - cannot synchronize", repn, partn, p);
	// src/libpmempool/replica.c:1507
	ERR_WO_ERRNO( "two consecutive unbroken parts are not linked to each other (repn %u, parts %u and %u) - cannot synchronize", repn, p, p + 1);
	// src/libpmempool/replica.c:1624
	ERR_WO_ERRNO("no healthy replica found");
	// src/libpmempool/replica.c:1638
	ERR_WO_ERRNO( "inconsistent poolset uuids between replicas %u and %u - cannot synchronize", repn, r);
	// src/libpmempool/replica.c:1712
	ERR_WO_ERRNO( "inconsistent replica uuids between replicas %u and %u", r, repn);
	// src/libpmempool/replica.c:1720
	ERR_WO_ERRNO( "inconsistent replica uuids between replicas %u and %u", r, repn);
	// src/libpmempool/replica.c:1745
	ERR_WO_ERRNO( "inconsistent replica uuids on borders of replica %u", r);
	// src/libpmempool/replica.c:1786
	ERR_WO_ERRNO( "alien replica found (probably coming from a different poolset)");
	// src/libpmempool/replica.c:1832
	ERR_WO_ERRNO( "some replicas are too small to hold synchronized data");
	// src/libpmempool/replica.c:1844
	ERR_WO_ERRNO( "pool sizes from different replicas differ");
	// src/libpmempool/replica.c:2074
	ERR_WO_ERRNO( "replica %u, part %u: file is too small", r, p);
	// src/libpmempool/replica.c:2098
	ERR_WO_ERRNO( "directory %s for part %u in replica %u does not exist or is not accessible", path, partn, repn);
	// src/libpmempool/replica.c:2189
	ERR_WO_ERRNO("file is not a poolset file");
	// src/libpmempool/replica.c:2195
	ERR_WO_ERRNO("unsupported flags");
	// src/libpmempool/replica.c:2203
	ERR_WO_ERRNO("cannot open a poolset file");
	// src/libpmempool/replica.c:2210
	ERR_WO_ERRNO("parsing input poolset failed");
	// src/libpmempool/replica.c:2215
	ERR_WO_ERRNO("no replica(s) found in the pool set");
	// src/libpmempool/replica.c:2267
	ERR_WO_ERRNO("source file is not a poolset file");
	// src/libpmempool/replica.c:2273
	ERR_WO_ERRNO("destination file is not a poolset file");
	// src/libpmempool/replica.c:2279
	ERR_WO_ERRNO("unsupported flags");
	// src/libpmempool/replica.c:2287
	ERR_WO_ERRNO("cannot open source poolset file");
	// src/libpmempool/replica.c:2294
	ERR_WO_ERRNO("parsing source poolset failed");
	// src/libpmempool/replica.c:2303
	ERR_WO_ERRNO("cannot open destination poolset file");
	// src/libpmempool/replica.c:2312
	ERR_WO_ERRNO("parsing destination poolset failed");
	// src/libpmempool/replica.c:2322
	ERR_WO_ERRNO( "transform is not supported for given pool type: %s", "pmemobj");
	// src/libpmempool/rm.c:54
	ERR_WO_ERRNO("%s: removing file failed", path);
	// src/libpmempool/rm.c:56
	ERR_WO_ERRNO("removing file failed");
	// src/libpmempool/rm.c:101
	ERR_WO_ERRNO("invalid flags specified");
	// src/libpmempool/rm.c:113
	ERR_WO_ERRNO("removing file failed");
	// src/libpmempool/sync.c:927
	ERR_WO_ERRNO( "cannot generate pool set part UUID");
	// src/libpmempool/sync.c:953
	ERR_WO_ERRNO( "repeated uuid - some replicas were created with a different poolset file");
	// src/libpmempool/sync.c:966
	ERR_WO_ERRNO( "repeated uuid - some replicas were created with a different poolset file");
	// src/libpmempool/sync.c:976
	ERR_WO_ERRNO( "cannot generate pool set part UUID");
	// src/libpmempool/sync.c:1118
	ERR_WO_ERRNO( "cannot check file permissions of %s (replica %u, part %u)", path, repn, 0);
	// src/libpmempool/sync.c:1142
	ERR_WO_ERRNO( "cannot set permission rights for created parts: replica %u, part %u", r, p);
	// src/libpmempool/sync.c:1342
	ERR_WO_ERRNO("no healthy replica found");
	// src/libpmempool/sync.c:1357
	ERR_WO_ERRNO("recreating broken parts failed");
	// src/libpmempool/sync.c:1364
	ERR_WO_ERRNO("opening poolset part files failed");
	// src/libpmempool/sync.c:1371
	ERR_WO_ERRNO("opening poolset failed");
	// src/libpmempool/sync.c:1399
	ERR_WO_ERRNO( "a part of the pool has uncorrectable errors in all replicas");
	// src/libpmempool/sync.c:1418
	ERR_WO_ERRNO("no healthy replica found");
	// src/libpmempool/sync.c:1426
	ERR_WO_ERRNO("gathering uuids failed");
	// src/libpmempool/sync.c:1433
	ERR_WO_ERRNO("creating headers for broken parts failed");
	// src/libpmempool/sync.c:1441
	ERR_WO_ERRNO("copying data to broken parts failed");
	// src/libpmempool/sync.c:1448
	ERR_WO_ERRNO("updating uuids failed");
	// src/libpmempool/sync.c:1455
	ERR_WO_ERRNO("granting permissions to created parts failed");
	// src/libpmempool/transform.c:78
	ERR_WO_ERRNO( "realpath failed for %s, errno %d", path, errno);
	// src/libpmempool/transform.c:93
	ERR_WO_ERRNO( "some part file's path is used multiple times");
	// src/libpmempool/transform.c:100
	ERR_WO_ERRNO( "comparing file inodes failed for %s and %s", path, pathp);
	// src/libpmempool/transform.c:145
	ERR_WO_ERRNO( "transform of directory poolsets is not supported");
	// src/libpmempool/transform.c:156
	ERR_WO_ERRNO("part sizes check failed");
	// src/libpmempool/transform.c:174
	ERR_WO_ERRNO("getting pool size from master replica failed");
	// src/libpmempool/transform.c:179
	ERR_WO_ERRNO("target poolset is too small");
	// src/libpmempool/transform.c:272
	ERR_WO_ERRNO( "there are more then one corresponding replicas; cannot transform");
	// src/libpmempool/transform.c:303
	ERR_WO_ERRNO( "the NOHDRS poolset option is not supported in local poolset files");
	// src/libpmempool/transform.c:390
	ERR_WO_ERRNO("there must be at least one replica left");
	// src/libpmempool/transform.c:401
	ERR_WO_ERRNO( "adding and removing replicas at the same time is not allowed");
	// src/libpmempool/transform.c:415
	ERR_WO_ERRNO("both poolsets are equal");
	// src/libpmempool/transform.c:423
	ERR_WO_ERRNO( "cannot add/remove replicas and change the SINGLEHDR option at the same time");
	// src/libpmempool/transform.c:613
	ERR_WO_ERRNO("cannot generate part UUID");
	// src/libpmempool/transform.c:872
	ERR_WO_ERRNO("source poolset health check failed");
	// src/libpmempool/transform.c:877
	ERR_WO_ERRNO("source poolset is broken");
	// src/libpmempool/transform.c:888
	ERR_WO_ERRNO("creating poolset health status failed");
	// src/libpmempool/transform.c:897
	ERR_WO_ERRNO("comparing poolsets failed");
	// src/libpmempool/transform.c:916
	ERR_WO_ERRNO( "removing headers failed; falling back to the input poolset");
	// src/libpmempool/transform.c:934
	ERR_WO_ERRNO( "adding headers failed; falling back to the input poolset");
	// src/libpmempool/transform.c:954
	ERR_WO_ERRNO("some parts being added already exist");
	// src/common/set.c:257
	ERR_WO_ERRNO("unable to map at requested address %p", addr);
	// src/common/set.c:476
	ERR_WO_ERRNO( "size autodetection is supported only for device dax");
	// src/common/set.c:732
	ERR_WO_ERRNO("cannot mix directories and files in a set");
	// src/common/set.c:758
	ERR_WO_ERRNO( "cannot mix directories and files in a set");
	// src/common/set.c:768
	ERR_WO_ERRNO("cannot resolve realpath of new directory");
	// src/common/set.c:780
	ERR_WO_ERRNO( "cannot use the same directory twice");
	// src/common/set.c:877
	ERR_WO_ERRNO( "replica #%u part %u %smapped with MAP_SYNC", repidx, p, "not");
	// src/common/set.c:887
	ERR_WO_ERRNO( "replica #%u part %u header %smapped with MAP_SYNC", repidx, p, "not");
	// src/common/set.c:916
	ERR_WO_ERRNO( "either all the parts must be Device DAX or none");
	// src/common/set.c:926
	ERR_WO_ERRNO( "Multiple DAX devices with alignment other than 4KB. Use the SINGLEHDR poolset option.");
	// src/common/set.c:945
	ERR_WO_ERRNO( "both SINGLEHDR and NOHDR poolset options used at the same time");
	// src/common/set.c:1066
	ERR_WO_ERRNO("unable to load part %s", path);
	// src/common/set.c:1105
	ERR_WO_ERRNO( "failed to load parts from directory %s", path);
	// src/common/set.c:1302
	ERR_WO_ERRNO( "Remote replicas are no longer supported. This functionality is deprecated.");
	// src/common/set.c:1339
	ERR_WO_ERRNO("%s [%s:%d]", path, parser_errstr, nlines);
	// src/common/set.c:1357
	ERR_WO_ERRNO("cannot load part files from directories");
	// src/common/set.c:1511
	ERR_WO_ERRNO( "file size does not match config: %s, %zu != %zu", path, size, size);
	// src/common/set.c:1609
	ERR_WO_ERRNO("size must be zero for device dax");
	// src/common/set.c:1643
	ERR_WO_ERRNO( "file is not a poolset file and its size (%zu) is smaller than %zu", size, size);
	// src/common/set.c:1680
	ERR_WO_ERRNO( "poolset file options (%u) do not match incompat feature flags (%#x)", options, incompat);
	// src/common/set.c:1708
	ERR_WO_ERRNO("Non-empty file detected");
	// src/common/set.c:1816
	ERR_WO_ERRNO("invalid major version (0)");
	// src/common/set.c:1823
	ERR_WO_ERRNO("wrong pool type: \"%.8s\"", signature);
	// src/common/set.c:1830
	ERR_WO_ERRNO("pool version %d (library expects %d)", major, major);
	// src/common/set.c:1833
	ERR_WO_ERRNO( "Please run the pmdk-convert utility to upgrade the pool.");
	// src/common/set.c:1858
	ERR_WO_ERRNO("invalid checksum of pool header");
	// src/common/set.c:1866
	ERR_WO_ERRNO("wrong architecture flags");
	// src/common/set.c:1874
	ERR_WO_ERRNO("wrong pool set UUID");
	// src/common/set.c:1884
	ERR_WO_ERRNO("wrong part UUID");
	// src/common/set.c:1891
	ERR_WO_ERRNO("incompatible pool format");
	// src/common/set.c:1900
	ERR_WO_ERRNO("incompatible feature flags");
	// src/common/set.c:2253
	ERR_WO_ERRNO("cannot extend pool by 0 bytes");
	// src/common/set.c:2258
	ERR_WO_ERRNO( "extending the pool by appending parts with headers is not supported!");
	// src/common/set.c:2266
	ERR_WO_ERRNO("exceeded reservation size");
	// src/common/set.c:2275
	ERR_WO_ERRNO("unable to append a new part to the pool");
	// src/common/set.c:2290
	ERR_WO_ERRNO("cannot open the new part");
	// src/common/set.c:2300
	ERR_WO_ERRNO("cannot map the new part");
	// src/common/set.c:2310
	ERR_WO_ERRNO( "new part cannot be mapped with MAP_SYNC");
	// src/common/set.c:2313
	ERR_WO_ERRNO("new part mapped with MAP_SYNC");
	// src/common/set.c:2356
	ERR_WO_ERRNO("file contains bad blocks -- '%s'", path);
	// src/common/set.c:2390
	ERR_WO_ERRNO("file %s already exists", path);
	// src/common/set.c:2407
	ERR_WO_ERRNO( "the NOHDRS poolset option is not supported for local poolsets");
	// src/common/set.c:2414
	ERR_WO_ERRNO( "pool attributes are not supported for poolsets without headers (with the NOHDRS option)");
	// src/common/set.c:2421
	ERR_WO_ERRNO( "directory based pools are not supported for poolsets with headers (without SINGLEHDR option)");
	// src/common/set.c:2428
	ERR_WO_ERRNO("reservation pool size %zu smaller than %zu", size, size);
	// src/common/set.c:2436
	ERR_WO_ERRNO( "cannot create a new part in provided directories");
	// src/common/set.c:2455
	ERR_WO_ERRNO( "pool set contains bad blocks and cannot be created, run 'pmempool create --clear-bad-blocks' utility to clear bad blocks and create a pool");
	// src/common/set.c:2463
	ERR_WO_ERRNO("net pool size %zu smaller than %zu", size, size);
	// src/common/set.c:2470
	ERR_WO_ERRNO("replication not supported");
	// src/common/set.c:2633
	ERR_WO_ERRNO( "pool mapping failed - address space reservation too small");
	// src/common/set.c:2806
	ERR_WO_ERRNO("wrong replica UUID");
	// src/common/set.c:2862
	ERR_WO_ERRNO("device dax cannot be mapped privately");
	// src/common/set.c:2877
	ERR_WO_ERRNO( "error: a bad block recovery file exists, run 'pmempool sync --bad-blocks' utility to try to recover the pool");
	// src/common/set.c:2900
	ERR_WO_ERRNO( "pool set contains bad blocks and cannot be opened, run 'pmempool sync --bad-blocks' utility to try to recover the pool");
	// src/common/set.c:3018
	ERR_WO_ERRNO("device dax cannot be mapped privately");
	// src/common/set.c:3038
	ERR_WO_ERRNO( "error: a bad block recovery file exists, run 'pmempool sync --bad-blocks' utility to try to recover the pool");
	// src/common/set.c:3064
	ERR_WO_ERRNO( "pool set contains bad blocks and cannot be opened, run 'pmempool sync --bad-blocks' utility to try to recover the pool -- '%s'", path);
	// src/common/set.c:3215
	ERR_WO_ERRNO("util_poolset_parse failed -- '%s'", path);
	// src/common/set_badblocks.c:46
	ERR_WO_ERRNO( "checking the pool file for bad blocks failed -- '%s'", path);
	// src/common/set_badblocks.c:53
	ERR_WO_ERRNO("part file contains bad blocks -- '%s'", path);
	// src/common/set_badblocks.c:120
	ERR_WO_ERRNO( "clearing bad blocks in the pool file failed -- '%s'", path);
	// src/common/shutdown_state.c:77
	ERR_WO_ERRNO( "Cannot read unsafe shutdown count. For more information please check https://github.com/pmem/pmdk/issues/4207");
	// src/common/shutdown_state.c:87
	ERR_WO_ERRNO("cannot read uuid of %d", fd);
	// src/common/shutdown_state.c:101
	ERR_WO_ERRNO("cannot read uuid of %d", fd);
	// src/common/shutdown_state.c:232
	ERR_WO_ERRNO( "an ADR failure was detected, the pool might be corrupted");
	// src/common/file.c:111
	ERR_WO_ERRNO("invalid (NULL) path");
	// src/common/file.c:182
	ERR_WO_ERRNO( "file size (%ld) too big to be represented in 64-bit signed integer", size);
	// src/common/file.c:409
	ERR_WO_ERRNO("size %zu smaller than %zu", size, size);
	// src/common/file.c:415
	ERR_WO_ERRNO("invalid size (%zu) for os_off_t", size);
	// src/common/file.c:485
	ERR_WO_ERRNO("stat \"%s\": negative size", path);
	// src/common/file.c:491
	ERR_WO_ERRNO("size %zu smaller than %zu", (size_t)size, size);
	// src/common/mmap.c:287
	ERR_WO_ERRNO( "duplicated persistent memory range; presumably unmapped with munmap() instead of pmem_unmap(): addr %p len %zu", addr, len);
	// src/common/mmap.c:308
	ERR_WO_ERRNO("Cannot find DAX device region id");
	// src/common/mmap.c:336
	ERR_WO_ERRNO( "invalid munmap length, must be non-zero and page aligned");
	// src/common/ctl.c:215
	ERR_WO_ERRNO("read queries require non-NULL argument");
	// src/common/ctl.c:231
	ERR_WO_ERRNO("write queries require non-NULL argument");
	// src/common/ctl.c:278
	ERR_WO_ERRNO("invalid query");
	// src/common/ctl.c:302
	ERR_WO_ERRNO("invalid query entry point %s", name);
	// src/common/ctl.c:374
	ERR_WO_ERRNO("failed to parse query %s", qbuf);
	// src/common/ctl.c:436
	ERR_WO_ERRNO("Config file too large");
	// src/common/ctl.c:562
	ERR_WO_ERRNO("invalid destination size %zu", size);
	// src/common/pool_hdr.c:116
	ERR_WO_ERRNO("invalid reserved values");
	// src/common/pool_hdr.c:121
	ERR_WO_ERRNO("invalid machine value");
	// src/common/pool_hdr.c:126
	ERR_WO_ERRNO("invalid data value");
	// src/common/pool_hdr.c:131
	ERR_WO_ERRNO("invalid machine_class value");
	// src/common/pool_hdr.c:136
	ERR_WO_ERRNO("invalid alignment_desc value");
	// src/common/pool_hdr.c:173
	ERR_WO_ERRNO( "unsafe to continue due to unknown incompat features: %#x", incompat);
	// src/common/pool_hdr.c:182
	ERR_WO_ERRNO( "switching to read-only mode due to unknown ro_compat features: %#x", ro_compat);
	// src/common/mmap_posix.c:90
	ERR_WO_ERRNO("end of address space reached");

}

void
call_all_CORE_LOG_ERROR_W_ERRNO_LAST(int errnum)
{

}

void
call_all_ERR_W_ERRNO(int errnum)
{
	// src/test/pmem2_perror/pmem2_perror.c:62
	errno = errnum;
	ERR_W_ERRNO("open");
	// src/test/pmem2_perror/pmem2_perror.c:79
	errno = errnum;
	ERR_W_ERRNO("open");
	// src/test/out_err/out_err.c:35
	errno = errnum;
	ERR_W_ERRNO("ERR #%d", 2);
	// src/test/out_err/out_err.c:39
	errno = errnum;
	ERR_W_ERRNO("ERR #%d", 3);
	// src/libpmem/pmem.c:280
	errno = errnum;
	ERR_W_ERRNO("msync");
	// src/libpmem/pmem.c:487
	errno = errnum;
	ERR_W_ERRNO("open %s", path);
	// src/libpmem/pmem.c:500
	errno = errnum;
	ERR_W_ERRNO("ftruncate");
	// src/libpmem/pmem.c:506
	errno = errnum;
	ERR_W_ERRNO("posix_fallocate");
	// src/libpmem2/persist_posix.c:40
	errno = errnum;
	ERR_W_ERRNO("msync");
	// src/libpmem2/deep_flush_linux.c:37
	errno = errnum;
	ERR_W_ERRNO("snprintf");
	// src/libpmem2/badblocks.c:23
	errno = errnum;
	ERR_W_ERRNO("Zalloc");
	// src/libpmem2/map_posix.c:132
	errno = errnum;
	ERR_W_ERRNO("mmap MAP_FIXED_NOREPLACE");
	// src/libpmem2/map_posix.c:135
	errno = errnum;
	ERR_W_ERRNO("mmap MAP_ANONYMOUS");
	// src/libpmem2/map_posix.c:173
	errno = errnum;
	ERR_W_ERRNO("munmap");
	// src/libpmem2/map_posix.c:183
	errno = errnum;
	ERR_W_ERRNO("munmap");
	// src/libpmem2/map_posix.c:215
	errno = errnum;
	ERR_W_ERRNO("mmap");
	// src/libpmem2/map_posix.c:243
	errno = errnum;
	ERR_W_ERRNO("mmap");
	// src/libpmem2/map_posix.c:255
	errno = errnum;
	ERR_W_ERRNO("munmap");
	// src/libpmem2/map_posix.c:281
	errno = errnum;
	ERR_W_ERRNO("mmap MAP_ANONYMOUS");
	// src/libpmem2/pmem2_utils_linux.c:54
	errno = errnum;
	ERR_W_ERRNO("snprintf");
	// src/libpmem2/pmem2_utils_linux.c:64
	errno = errnum;
	ERR_W_ERRNO("realpath \"%s\"", spath);
	// src/libpmem2/pmem2_utils_ndctl.c:27
	errno = errnum;
	ERR_W_ERRNO("ndctl_new");
	// src/libpmem2/pmem2_utils_ndctl.c:66
	errno = errnum;
	ERR_W_ERRNO("ndctl_new");
	// src/libpmem2/region_namespace_ndctl.c:42
	errno = errnum;
	ERR_W_ERRNO("snprintf");
	// src/libpmem2/region_namespace_ndctl.c:47
	errno = errnum;
	ERR_W_ERRNO("stat %s", path);
	// src/libpmem2/region_namespace_ndctl.c:80
	errno = errnum;
	ERR_W_ERRNO("snprintf");
	// src/libpmem2/region_namespace_ndctl.c:86
	errno = errnum;
	ERR_W_ERRNO("snprintf");
	// src/libpmem2/region_namespace_ndctl.c:92
	errno = errnum;
	ERR_W_ERRNO("open \"%s\"", path);
	// src/libpmem2/region_namespace_ndctl.c:99
	errno = errnum;
	ERR_W_ERRNO("read");
	// src/libpmem2/region_namespace_ndctl.c:173
	errno = errnum;
	ERR_W_ERRNO("cannot find dax region");
	// src/libpmem2/region_namespace_ndctl.c:242
	errno = errnum;
	ERR_W_ERRNO("ndctl_new");
	// src/libpmem2/pmem2_utils.c:25
	errno = errnum;
	ERR_W_ERRNO("malloc(%zu)", size);
	// src/libpmem2/pmem2_utils.c:42
	errno = errnum;
	ERR_W_ERRNO("malloc(%zu)", size);
	// src/libpmem2/pmem2_utils.c:59
	errno = errnum;
	ERR_W_ERRNO("realloc(%zu)", size);
	// src/libpmem2/source_posix.c:31
	errno = errnum;
	ERR_W_ERRNO("fcntl");
	// src/libpmem2/source_posix.c:53
	errno = errnum;
	ERR_W_ERRNO("fstat");
	// src/libpmem2/source_posix.c:106
	errno = errnum;
	ERR_W_ERRNO("fstat");
	// src/libpmem2/usc_ndctl.c:42
	errno = errnum;
	ERR_W_ERRNO("ndctl_new");
	// src/libpmem2/usc_ndctl.c:100
	errno = errnum;
	ERR_W_ERRNO("ndctl_new");
	// src/libpmem2/vm_reservation_posix.c:78
	errno = errnum;
	ERR_W_ERRNO("mmap MAP_FIXED_NOREPLACE");
	// src/libpmem2/vm_reservation_posix.c:81
	errno = errnum;
	ERR_W_ERRNO("mmap MAP_ANONYMOUS");
	// src/libpmem2/vm_reservation_posix.c:112
	errno = errnum;
	ERR_W_ERRNO("munmap");
	// src/libpmem2/mcsafe_ops_posix.c:54
	errno = errnum;
	ERR_W_ERRNO("pread");
	// src/libpmem2/mcsafe_ops_posix.c:80
	errno = errnum;
	ERR_W_ERRNO("pwrite");
	// src/libpmem2/mcsafe_ops_posix.c:129
	errno = errnum;
	ERR_W_ERRNO("sigaction");
	// src/libpmem2/mcsafe_ops_posix.c:152
	errno = errnum;
	ERR_W_ERRNO("sigaction");
	// src/libpmem2/badblocks_ndctl.c:168
	errno = errnum;
	ERR_W_ERRNO("cannot read offset of the region");
	// src/libpmem2/badblocks_ndctl.c:279
	errno = errnum;
	ERR_W_ERRNO("ndctl_new");
	// src/libpmem2/badblocks_ndctl.c:711
	errno = errnum;
	ERR_W_ERRNO("fallocate");
	// src/libpmem2/badblocks_ndctl.c:717
	errno = errnum;
	ERR_W_ERRNO("fallocate");
	// src/libpmem2/extent_linux.c:40
	errno = errnum;
	ERR_W_ERRNO("fstat %d", fd);
	// src/libpmem2/extent_linux.c:83
	errno = errnum;
	ERR_W_ERRNO("fiemap ioctl() for fd=%d failed", fd);
	// src/libpmem2/extent_linux.c:102
	errno = errnum;
	ERR_W_ERRNO("fiemap ioctl() for fd=%d failed", fd);
	// src/libpmem2/numa_ndctl.c:36
	errno = errnum;
	ERR_W_ERRNO("ndctl_new");
	// src/libpmem2/auto_flush_linux.c:46
	errno = errnum;
	ERR_W_ERRNO("read(%d, %p, %d)", domain_fd, domain_value, DOMAIN_VALUE_LEN);
	// src/libpmem2/auto_flush_linux.c:57
	errno = errnum;
	ERR_W_ERRNO("read(%d, %p, %d) invalid format", domain_fd, domain_value, DOMAIN_VALUE_LEN);
	// src/libpmem2/auto_flush_linux.c:96
	errno = errnum;
	ERR_W_ERRNO("fs_new: \"%s\"", region_path);
	// src/libpmem2/auto_flush_linux.c:116
	errno = errnum;
	ERR_W_ERRNO("snprintf");
	// src/libpmem2/auto_flush_linux.c:157
	errno = errnum;
	ERR_W_ERRNO("fs_new: \"%s\"", device_path);
	// src/libpmemobj/lane.c:267
	errno = errnum;
	ERR_W_ERRNO("Malloc of volatile lanes");
	// src/libpmemobj/lane.c:276
	errno = errnum;
	ERR_W_ERRNO("Malloc for lane locks");
	// src/libpmemobj/lane.c:289
	errno = errnum;
	ERR_W_ERRNO("lane_init");
	// src/libpmemobj/tx.c:499
	errno = errnum;
	ERR_W_ERRNO("pmemobj_mutex_lock");
	// src/libpmemobj/tx.c:508
	errno = errnum;
	ERR_W_ERRNO("pmemobj_rwlock_wrlock");
	// src/libpmemobj/tx.c:776
	errno = errnum;
	ERR_W_ERRNO("Malloc");
	// src/libpmemobj/tx.c:945
	errno = errnum;
	ERR_W_ERRNO("explicit transaction abort");
	// src/libpmemobj/list.c:473
	errno = errnum;
	ERR_W_ERRNO("palloc_reserve");
	// src/libpmemobj/stats.c:124
	errno = errnum;
	ERR_W_ERRNO("Malloc");
	// src/libpmemobj/critnib.c:279
	errno = errnum;
	ERR_W_ERRNO("Malloc");
	// src/libpmemobj/critnib.c:316
	errno = errnum;
	ERR_W_ERRNO("Malloc");
	// src/libpmemobj/heap.c:187
	errno = errnum;
	ERR_W_ERRNO("heap: arena malloc error");
	// src/libpmemobj/memops.c:90
	errno = errnum;
	ERR_W_ERRNO("Zalloc");
	// src/libpmemobj/memops.c:116
	errno = errnum;
	ERR_W_ERRNO("Zalloc");
	// src/libpmemobj/memops.c:177
	errno = errnum;
	ERR_W_ERRNO("Zalloc");
	// src/libpmemobj/obj.c:662
	errno = errnum;
	ERR_W_ERRNO("lane_boot");
	// src/libpmemobj/obj.c:667
	errno = errnum;
	ERR_W_ERRNO("lane_recover_and_section_boot");
	// src/libpmemobj/obj.c:725
	errno = errnum;
	ERR_W_ERRNO("palloc_init");
	// src/libpmemobj/obj.c:964
	errno = errnum;
	ERR_W_ERRNO("critnib_insert to pools_ht");
	// src/libpmemobj/obj.c:969
	errno = errnum;
	ERR_W_ERRNO("critnib_insert to pools_tree");
	// src/libpmemobj/obj.c:984
	errno = errnum;
	ERR_W_ERRNO("ravl_new_sized");
	// src/libpmempool/libpmempool.c:177
	errno = errnum;
	ERR_W_ERRNO("calloc");
	// src/libpmempool/libpmempool.c:185
	errno = errnum;
	ERR_W_ERRNO("strdup");
	// src/libpmempool/libpmempool.c:193
	errno = errnum;
	ERR_W_ERRNO("strdup");
	// src/libpmempool/check_util.c:77
	errno = errnum;
	ERR_W_ERRNO("calloc");
	// src/libpmempool/check_util.c:334
	errno = errnum;
	ERR_W_ERRNO("snprintf");
	// src/libpmempool/check_util.c:608
	errno = errnum;
	ERR_W_ERRNO("snprintf");
	// src/libpmempool/pool.c:210
	errno = errnum;
	ERR_W_ERRNO("mprotect");
	// src/libpmempool/pool.c:366
	errno = errnum;
	ERR_W_ERRNO("calloc");
	// src/libpmempool/pool.c:378
	errno = errnum;
	ERR_W_ERRNO("cannot perform a dry run on dax device");
	// src/libpmempool/pool.c:558
	errno = errnum;
	ERR_W_ERRNO("util_stat");
	// src/libpmempool/replica.c:142
	errno = errnum;
	ERR_W_ERRNO("removing part %u from replica %u failed", partn, repn);
	// src/libpmempool/replica.c:168
	errno = errnum;
	ERR_W_ERRNO("Zalloc for replica health status");
	// src/libpmempool/replica.c:190
	errno = errnum;
	ERR_W_ERRNO( "removing the bad block recovery file failed -- '%s'", path);
	// src/libpmempool/replica.c:260
	errno = errnum;
	ERR_W_ERRNO("Zalloc for poolset health state");
	// src/libpmempool/replica.c:679
	errno = errnum;
	ERR_W_ERRNO( "opening bad block recovery file failed -- '%s'", path);
	// src/libpmempool/replica.c:687
	errno = errnum;
	ERR_W_ERRNO( "opening a file stream for bad block recovery file failed -- '%s'", path);
	// src/libpmempool/replica.c:702
	errno = errnum;
	ERR_W_ERRNO( "flushing bad block recovery file failed -- '%s'", path);
	// src/libpmempool/replica.c:709
	errno = errnum;
	ERR_W_ERRNO( "syncing bad block recovery file failed -- '%s'", path);
	// src/libpmempool/replica.c:719
	errno = errnum;
	ERR_W_ERRNO( "flushing bad block recovery file failed -- '%s'", path);
	// src/libpmempool/replica.c:726
	errno = errnum;
	ERR_W_ERRNO( "syncing bad block recovery file failed -- '%s'", path);
	// src/libpmempool/replica.c:761
	errno = errnum;
	ERR_W_ERRNO( "opening the recovery file for reading failed -- '%s'", path);
	// src/libpmempool/replica.c:991
	errno = errnum;
	ERR_W_ERRNO( "creating an empty bad block recovery file failed -- '%s' (part file '%s')", path, path);
	// src/libpmempool/replica.c:1001
	errno = errnum;
	ERR_W_ERRNO("Strdup");
	// src/libpmempool/replica.c:1009
	errno = errnum;
	ERR_W_ERRNO( "syncing the directory of the bad block recovery file failed -- '%s' (part file '%s')", direpname, path);
	// src/libpmempool/replica.c:1088
	errno = errnum;
	ERR_W_ERRNO( "checking the pool part for bad blocks failed -- '%s'", path);
	// src/libpmempool/transform.c:64
	errno = errnum;
	ERR_W_ERRNO("strdup");
	// src/libpmempool/transform.c:200
	errno = errnum;
	ERR_W_ERRNO("Zalloc for poolset status");
	// src/common/file_posix.c:158
	errno = errnum;
	ERR_W_ERRNO("stat \"%s\"", path);
	// src/common/set.c:195
	errno = errnum;
	ERR_W_ERRNO("mmap: %s", path);
	// src/common/set.c:252
	errno = errnum;
	ERR_W_ERRNO("mmap: %s", path);
	// src/common/set.c:283
	errno = errnum;
	ERR_W_ERRNO("munmap: %s", path);
	// src/common/set.c:369
	errno = errnum;
	ERR_W_ERRNO( "unlink %s failed (part %u, replica %u)", path, p, repn);
	// src/common/set.c:422
	errno = errnum;
	ERR_W_ERRNO("fstat %d %s", fd, path);
	// src/common/set.c:435
	errno = errnum;
	ERR_W_ERRNO("chmod %u/%u/%s", r, p, path);
	// src/common/set.c:518
	errno = errnum;
	ERR_W_ERRNO("Strdup");
	// src/common/set.c:622
	errno = errnum;
	ERR_W_ERRNO("Strdup");
	// src/common/set.c:648
	errno = errnum;
	ERR_W_ERRNO("Realloc");
	// src/common/set.c:841
	errno = errnum;
	ERR_W_ERRNO("Realloc");
	// src/common/set.c:849
	errno = errnum;
	ERR_W_ERRNO("Zalloc");
	// src/common/set.c:1027
	errno = errnum;
	ERR_W_ERRNO("fs_new: \"%s\"", directory);
	// src/common/set.c:1060
	errno = errnum;
	ERR_W_ERRNO("Strdup");
	// src/common/set.c:1139
	errno = errnum;
	ERR_W_ERRNO("no directories in replica");
	// src/common/set.c:1156
	errno = errnum;
	ERR_W_ERRNO("Malloc");
	// src/common/set.c:1196
	errno = errnum;
	ERR_W_ERRNO("lseek %d", fd);
	// src/common/set.c:1202
	errno = errnum;
	ERR_W_ERRNO("dup");
	// src/common/set.c:1208
	errno = errnum;
	ERR_W_ERRNO("fdopen %d", fd);
	// src/common/set.c:1219
	errno = errnum;
	ERR_W_ERRNO("Reading poolset file");
	// src/common/set.c:1226
	errno = errnum;
	ERR_W_ERRNO("Malloc for pool set");
	// src/common/set.c:1232
	errno = errnum;
	ERR_W_ERRNO("Strdup");
	// src/common/set.c:1404
	errno = errnum;
	ERR_W_ERRNO("Malloc for pool set");
	// src/common/set.c:1410
	errno = errnum;
	ERR_W_ERRNO("Strdup");
	// src/common/set.c:1419
	errno = errnum;
	ERR_W_ERRNO("Malloc for pool set replica");
	// src/common/set.c:1503
	errno = errnum;
	ERR_W_ERRNO("posix_fallocate \"%s\", %zu", path, size);
	// src/common/set.c:1573
	errno = errnum;
	ERR_W_ERRNO("open: path \"%s\"", path);
	// src/common/set.c:1632
	errno = errnum;
	ERR_W_ERRNO("read %d", fd);
	// src/common/set.c:1756
	errno = errnum;
	ERR_W_ERRNO("fstat");
	// src/common/set.c:2212
	errno = errnum;
	ERR_W_ERRNO("Malloc");
	// src/common/set.c:3013
	errno = errnum;
	ERR_W_ERRNO("no parts in replicas");
	// src/common/set.c:3144
	errno = errnum;
	ERR_W_ERRNO("read");
	// src/common/set.c:3208
	errno = errnum;
	ERR_W_ERRNO("open: path \"%s\"", path);
	// src/common/set_badblocks.c:171
	errno = errnum;
	ERR_W_ERRNO("Malloc");
	// src/common/shutdown_state.c:95
	errno = errnum;
	ERR_W_ERRNO("Zalloc");
	// src/common/vecq.h:68
	errno = errnum;
	ERR_W_ERRNO("Realloc");
	// src/common/file.c:40
	errno = errnum;
	ERR_W_ERRNO("os_access \"%s\"", path);
	// src/common/file.c:94
	errno = errnum;
	ERR_W_ERRNO("fstat");
	// src/common/file.c:126
	errno = errnum;
	ERR_W_ERRNO("stat");
	// src/common/file.c:143
	errno = errnum;
	ERR_W_ERRNO("open");
	// src/common/file.c:206
	errno = errnum;
	ERR_W_ERRNO("open \"%s\"", path);
	// src/common/file.c:244
	errno = errnum;
	ERR_W_ERRNO("open \"%s\"", path);
	// src/common/file.c:430
	errno = errnum;
	ERR_W_ERRNO("open \"%s\"", path);
	// src/common/file.c:435
	errno = errnum;
	ERR_W_ERRNO("posix_fallocate \"%s\", %zu", path, size);
	// src/common/file.c:440
	errno = errnum;
	ERR_W_ERRNO("flock \"%s\"", path);
	// src/common/file.c:469
	errno = errnum;
	ERR_W_ERRNO("open \"%s\"", path);
	// src/common/file.c:474
	errno = errnum;
	ERR_W_ERRNO("flock \"%s\"", path);
	// src/common/file.c:507
	errno = errnum;
	ERR_W_ERRNO("flock unlock");
	// src/common/mmap.c:104
	errno = errnum;
	ERR_W_ERRNO("mmap %zu bytes", len);
	// src/common/mmap.c:126
	errno = errnum;
	ERR_W_ERRNO("munmap");
	// src/common/mmap.c:155
	errno = errnum;
	ERR_W_ERRNO("mprotect: PROT_READ");
	// src/common/mmap.c:184
	errno = errnum;
	ERR_W_ERRNO("mprotect: PROT_READ|PROT_WRITE");
	// src/common/mmap.c:213
	errno = errnum;
	ERR_W_ERRNO("mprotect: PROT_NONE");
	// src/common/mmap.c:297
	errno = errnum;
	ERR_W_ERRNO("Malloc");
	// src/common/mmap.c:360
	errno = errnum;
	ERR_W_ERRNO("Malloc");
	// src/common/mmap.c:375
	errno = errnum;
	ERR_W_ERRNO("Malloc");
	// src/common/ctl.c:132
	errno = errnum;
	ERR_W_ERRNO("Malloc");
	// src/common/ctl.c:142
	errno = errnum;
	ERR_W_ERRNO("strtok_r");
	// src/common/ctl.c:400
	errno = errnum;
	ERR_W_ERRNO("Strdup");
	// src/common/ctl.c:445
	errno = errnum;
	ERR_W_ERRNO("Zalloc");
	// src/common/ctl.c:479
	errno = errnum;
	ERR_W_ERRNO("Zalloc");
	// src/common/bad_blocks.c:63
	errno = errnum;
	ERR_W_ERRNO("open %s", file);
	// src/common/bad_blocks.c:142
	errno = errnum;
	ERR_W_ERRNO("open %s", file);
	// src/common/bad_blocks.c:200
	errno = errnum;
	ERR_W_ERRNO("open %s", file);
	// src/common/mmap_posix.c:43
	errno = errnum;
	ERR_W_ERRNO("%s", Mmap_mapfile);
	// src/common/mmap_posix.c:141
	errno = errnum;
	ERR_W_ERRNO("mmap MAP_ANONYMOUS");
	// src/common/vec.h:62
	errno = errnum;
	ERR_W_ERRNO("Realloc");
	// src/core/out.c:74
	errno = errnum;
	ERR_W_ERRNO("snprintf");
	// src/core/sys_util.h:181
	errno = errnum;
	ERR_W_ERRNO("os_spin_init");
	// src/core/ravl.c:51
	errno = errnum;
	ERR_W_ERRNO("Malloc");
	// src/core/ravl.c:167
	errno = errnum;
	ERR_W_ERRNO("Malloc");
	// src/core/util_posix.c:49
	errno = errnum;
	ERR_W_ERRNO("stat failed for %s", path1);
	// src/core/util_posix.c:59
	errno = errnum;
	ERR_W_ERRNO("stat failed for %s", path2);
	// src/core/util_posix.c:99
	errno = errnum;
	ERR_W_ERRNO("mkstemp");
	// src/core/util_posix.c:138
	errno = errnum;
	ERR_W_ERRNO("open");

}

