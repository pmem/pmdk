<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Mon May  9 10:52:59 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>libpmemobj</title>

</head>
<body>

<h1 align="center">libpmemobj</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#MOST COMMONLY USED FUNCTIONS">MOST COMMONLY USED FUNCTIONS</a><br>
<a href="#LOW-LEVEL MEMORY MANIPULATION">LOW-LEVEL MEMORY MANIPULATION</a><br>
<a href="#POOL SETS AND REPLICAS">POOL SETS AND REPLICAS</a><br>
<a href="#LOCKING">LOCKING</a><br>
<a href="#PERSISTENT OBJECTS">PERSISTENT OBJECTS</a><br>
<a href="#TYPE-SAFETY">TYPE-SAFETY</a><br>
<a href="#LAYOUT DECLARATION">LAYOUT DECLARATION</a><br>
<a href="#OBJECT CONTAINERS">OBJECT CONTAINERS</a><br>
<a href="#ROOT OBJECT MANAGEMENT">ROOT OBJECT MANAGEMENT</a><br>
<a href="#NON-TRANSACTIONAL ATOMIC ALLOCATIONS">NON-TRANSACTIONAL ATOMIC ALLOCATIONS</a><br>
<a href="#NON-TRANSACTIONAL PERSISTENT ATOMIC LISTS">NON-TRANSACTIONAL PERSISTENT ATOMIC LISTS</a><br>
<a href="#TYPE-SAFE NON-TRANSACTIONAL PERSISTENT ATOMIC LISTS">TYPE-SAFE NON-TRANSACTIONAL PERSISTENT ATOMIC LISTS</a><br>
<a href="#TRANSACTIONAL OBJECT MANIPULATION">TRANSACTIONAL OBJECT MANIPULATION</a><br>
<a href="#CAVEATS">CAVEATS</a><br>
<a href="#LIBRARY API VERSIONING">LIBRARY API VERSIONING</a><br>
<a href="#MANAGING LIBRARY BEHAVIOR">MANAGING LIBRARY BEHAVIOR</a><br>
<a href="#DEBUGGING AND ERROR HANDLING">DEBUGGING AND ERROR HANDLING</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">libpmemobj
&minus; persistent memory transactional object store</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;libpmemobj.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>cc
-std=gnu99 ... -lpmemobj -lpmem</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Most
commonly used functions:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>PMEMobjpool
*pmemobj_open(const char *</b><i>path</i><b>, const char
*</b><i>layout</i><b>); <br>
PMEMobjpool *pmemobj_create(const char *</b><i>path</i><b>,
const char *</b><i>layout</i><b>, <br>
size_t</b> <i>poolsize</i><b>, mode_t</b> <i>mode</i><b>);
<br>
void pmemobj_close(PMEMobjpool *</b><i>pop</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Low-level
memory manipulation:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
*pmemobj_memcpy_persist(PMEMobjpool *</b><i>pop</i><b>, void
*</b><i>dest</i><b>, <br>
const void *</b><i>src</i><b>, size_t</b> <i>len</i><b>);
<br>
void *pmemobj_memset_persist(PMEMobjpool *</b><i>pop</i><b>,
void *</b><i>dest</i><b>, <br>
int</b> <i>c</i><b>, size_t</b> <i>len</i><b>); <br>
void pmemobj_persist(PMEMobjpool *</b><i>pop</i><b>, const
void *</b><i>addr</i><b>, size_t</b> <i>len</i><b>); <br>
void pmemobj_flush(PMEMobjpool *</b><i>pop</i><b>, const
void *</b><i>addr</i><b>, size_t</b> <i>len</i><b>); <br>
void pmemobj_drain(PMEMobjpool *</b><i>pop</i><b>);</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Locking:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pmemobj_mutex_zero(PMEMobjpool *</b><i>pop</i><b>, PMEMmutex
*</b><i>mutexp</i><b>); <br>
int pmemobj_mutex_lock(PMEMobjpool *</b><i>pop</i><b>,
PMEMmutex *</b><i>mutexp</i><b>); <br>
int pmemobj_mutex_timedlock(PMEMobjpool *</b><i>pop</i><b>,
<br>
PMEMmutex *restrict</b> <i>mutexp</i><b>, <br>
const struct timespec *restrict</b> <i>abs_timeout</i><b>);
<br>
int pmemobj_mutex_trylock(PMEMobjpool *</b><i>pop</i><b>,
PMEMmutex *</b><i>mutexp</i><b>); <br>
int pmemobj_mutex_unlock(PMEMobjpool *</b><i>pop</i><b>,
PMEMmutex *</b><i>mutexp</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pmemobj_rwlock_zero(PMEMobjpool *</b><i>pop</i><b>,
PMEMrwlock *</b><i>rwlockp</i><b>); <br>
int pmemobj_rwlock_rdlock(PMEMobjpool *</b><i>pop</i><b>,
PMEMrwlock *</b><i>rwlockp</i><b>); <br>
int pmemobj_rwlock_wrlock(PMEMobjpool *</b><i>pop</i><b>,
PMEMrwlock *</b><i>rwlockp</i><b>); <br>
int pmemobj_rwlock_timedrdlock(PMEMobjpool
*</b><i>pop</i><b>, <br>
PMEMrwlock *restrict</b> <i>rwlockp</i><b>, <br>
const struct timespec *restrict</b> <i>abs_timeout</i><b>);
<br>
int pmemobj_rwlock_timedwrlock(PMEMobjpool
*</b><i>pop</i><b>, <br>
PMEMrwlock *restrict</b> <i>rwlockp</i><b>, <br>
const struct timespec *restrict</b> <i>abs_timeout</i><b>);
<br>
int pmemobj_rwlock_tryrdlock(PMEMobjpool *</b><i>pop</i><b>,
PMEMrwlock *</b><i>rwlockp</i><b>); <br>
int pmemobj_rwlock_trywrlock(PMEMobjpool *</b><i>pop</i><b>,
PMEMrwlock *</b><i>rwlockp</i><b>); <br>
int pmemobj_rwlock_unlock(PMEMobjpool *</b><i>pop</i><b>,
PMEMrwlock *</b><i>rwlockp</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pmemobj_cond_zero(PMEMobjpool *</b><i>pop</i><b>, PMEMcond
*</b><i>condp</i><b>); <br>
int pmemobj_cond_broadcast(PMEMobjpool *</b><i>pop</i><b>,
PMEMcond *</b><i>condp</i><b>); <br>
int pmemobj_cond_signal(PMEMobjpool *</b><i>pop</i><b>,
PMEMcond *</b><i>condp</i><b>); <br>
int pmemobj_cond_timedwait(PMEMobjpool *</b><i>pop</i><b>,
PMEMcond *restrict</b> <i>condp</i><b>, <br>
PMEMmutex *restrict</b> <i>mutexp</i><b>, const struct
timespec *restrict</b> <i>abs_timeout</i><b>); <br>
int pmemobj_cond_wait(PMEMobjpool *</b><i>pop</i><b>,
PMEMcond *</b><i>condp</i><b>, <br>
PMEMmutex *restrict</b> <i>mutexp</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Persistent
object identifier:</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>OID_IS_NULL(PMEMoid</b>
<i>oid</i><b>) <br>
OID_EQUALS(PMEMoid</b> <i>lhs</i><b>, PMEMoid</b>
<i>rhs</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Type-safety:</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>TOID(</b><i>TYPE</i><b>)
<br>
TOID_DECLARE(</b><i>TYPE</i><b>, uint64_t</b>
<i>type_num</i><b>) <br>
TOID_DECLARE_ROOT(</b><i>ROOT_TYPE</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>TOID_TYPE_NUM(</b><i>TYPE</i><b>)
<br>
TOID_TYPE_NUM_OF(TOID</b> <i>oid</i><b>) <br>
TOID_VALID(TOID</b> <i>oid</i><b>) <br>
OID_INSTANCEOF(PMEMoid</b> <i>oid</i><b>,</b>
<i>TYPE</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>TOID_ASSIGN(TOID</b>
<i>oid</i><b>,</b> <i>VALUE</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>TOID_IS_NULL(TOID</b>
<i>oid</i><b>) <br>
TOID_EQUALS(TOID</b> <i>lhs</i><b>, TOID</b> <i>rhs</i><b>)
<br>
DIRECT_RW(TOID</b> <i>oid</i><b>) <br>
DIRECT_RO(TOID</b> <i>oid</i><b>) <br>
D_RW(TOID</b> <i>oid</i><b>) <br>
D_RO(TOID</b> <i>oid</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Layout
declaration:</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LAYOUT_BEGIN(</b><i>layout</i><b>)
<br>
POBJ_LAYOUT_TOID(</b><i>layout</i><b>,</b> <i>TYPE</i><b>)
<br>
POBJ_LAYOUT_ROOT(</b><i>layout</i><b>,</b>
<i>ROOT_TYPE</i><b>) <br>
POBJ_LAYOUT_END(</b><i>layout</i><b>) <br>
POBJ_LAYOUT_NAME(</b><i>layout</i><b>) <br>
POBJ_LAYOUT_TYPES_NUM(</b><i>layout</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Non-transactional
atomic allocations:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>typedef int
(*</b><i>pmemobj_constr</i><b>)(PMEMobjpool
*</b><i>pop</i><b>, <br>
void *</b><i>ptr</i><b>, void *</b><i>arg</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_alloc(PMEMobjpool *</b><i>pop</i><b>, PMEMoid
*</b><i>oidp</i><b>, size_t</b> <i>size</i><b>, <br>
uint64_t</b> <i>type_num</i><b>, pmemobj_constr</b>
<i>constructor</i><b>, void *</b><i>arg</i><b>); <br>
int pmemobj_zalloc(PMEMobjpool *</b><i>pop</i><b>, PMEMoid
*</b><i>oidp</i><b>, size_t</b> <i>size</i><b>, <br>
uint64_t</b> <i>type_num</i><b>); <br>
int pmemobj_realloc(PMEMobjpool *</b><i>pop</i><b>, PMEMoid
*</b><i>oidp</i><b>, size_t</b> <i>size</i><b>, <br>
uint64_t</b> <i>type_num</i><b>); <br>
int pmemobj_zrealloc(PMEMobjpool *</b><i>pop</i><b>, PMEMoid
*</b><i>oidp</i><b>, size_t</b> <i>size</i><b>, <br>
uint64_t</b> <i>type_num</i><b>); <br>
int pmemobj_strdup(PMEMobjpool *</b><i>pop</i><b>, PMEMoid
*</b><i>oidp</i><b>, const char *</b><i>s</i><b>, <br>
uint64_t</b> <i>type_num</i><b>); <br>
void pmemobj_free(PMEMoid *</b><i>oidp</i><b>); <br>
size_t pmemobj_alloc_usable_size(PMEMoid</b> <i>oid</i><b>);
<br>
PMEMobjpool *pmemobj_pool_by_oid(PMEMoid</b> <i>oid</i><b>);
<br>
PMEMobjpool *pmemobj_pool_by_ptr(const void
*</b><i>addr</i><b>); <br>
void *pmemobj_direct(PMEMoid</b> <i>oid</i><b>); <br>
uint64_t pmemobj_type_num(PMEMoid</b>
<i>oid</i><b>);</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_NEW(PMEMobjpool
*</b><i>pop</i><b>, TOID *</b><i>oidp</i><b>,</b>
<i>TYPE</i><b>, <br>
pmemobj_constr</b> <i>constructor</i><b>, void
*</b><i>arg</i><b>) <br>
POBJ_ALLOC(PMEMobjpool *</b><i>pop</i><b>, TOID
*</b><i>oidp</i><b>,</b> <i>TYPE</i><b>, size_t</b>
<i>size</i><b>, <br>
pmemobj_constr</b> <i>constructor</i><b>, void
*</b><i>arg</i><b>) <br>
POBJ_ZNEW(PMEMobjpool *</b><i>pop</i><b>, TOID
*</b><i>oidp</i><b>,</b> <i>TYPE</i><b>) <br>
POBJ_ZALLOC(PMEMobjpool *</b><i>pop</i><b>, TOID
*</b><i>oidp</i><b>,</b> <i>TYPE</i><b>, size_t</b>
<i>size</i><b>) <br>
POBJ_REALLOC(PMEMobjpool *</b><i>pop</i><b>, TOID
*</b><i>oidp</i><b>,</b> <i>TYPE</i><b>, size_t</b>
<i>size</i><b>) <br>
POBJ_ZREALLOC(PMEMobjpool *</b><i>pop</i><b>, TOID
*</b><i>oidp</i><b>,</b> <i>TYPE</i><b>, size_t</b>
<i>size</i><b>) <br>
POBJ_FREE(TOID *</b><i>oidp</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Root object
management:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>PMEMoid
pmemobj_root(PMEMobjpool *</b><i>pop</i><b>, size_t</b>
<i>size</i><b>); <br>
PMEMoid pmemobj_root_construct(PMEMobjpool
*</b><i>pop</i><b>, size_t</b> <i>size</i><b>, <br>
pmemobj_constr</b> <i>constructor</i><b>, void
*</b><i>arg</i><b>); <br>
size_t pmemobj_root_size(PMEMobjpool
*</b><i>pop</i><b>);</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_ROOT(PMEMobjpool
*</b><i>pop</i><b>,</b> <i>TYPE</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Object
containers:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>PMEMoid
pmemobj_first(PMEMobjpool *</b><i>pop</i><b>); <br>
PMEMoid pmemobj_next(PMEMoid</b> <i>oid</i><b>);</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_FIRST_TYPE_NUM(PMEMobjpool
*</b><i>pop</i><b>, uint64_t</b> <i>type_num</i><b>) <br>
POBJ_FIRST(PMEMobjpool *</b><i>pop</i><b>,</b>
<i>TYPE</i><b>) <br>
POBJ_NEXT_TYPE_NUM(PMEMoid</b> <i>oid</i><b>) <br>
POBJ_NEXT(TOID</b> <i>oid</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_FOREACH(PMEMobjpool
*</b><i>pop</i><b>, PMEMoid</b> <i>varoid</i><b>) <br>
POBJ_FOREACH_SAFE(PMEMobjpool *</b><i>pop</i><b>,
PMEMoid</b> <i>varoid</i><b>, PMEMoid</b> <i>nvaroid</i><b>)
<br>
POBJ_FOREACH_TYPE(PMEMobjpool *</b><i>pop</i><b>, TOID</b>
<i>var</i><b>) <br>
POBJ_FOREACH_SAFE_TYPE(PMEMobjpool *</b><i>pop</i><b>,
TOID</b> <i>var</i><b>, TOID</b> <i>nvar</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Non-transactional
persistent atomic circular doubly-linked list:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_list_insert(PMEMobjpool *</b><i>pop</i><b>,
size_t</b> <i>pe_offset</i><b>, void *</b><i>head</i><b>,
<br>
PMEMoid</b> <i>dest</i><b>, int</b> <i>before</i><b>,
PMEMoid</b> <i>oid</i><b>); <br>
PMEMoid pmemobj_list_insert_new(PMEMobjpool
*</b><i>pop</i><b>, size_t</b> <i>pe_offset</i><b>, void
*</b><i>head</i><b>, <br>
PMEMoid</b> <i>dest</i><b>, int</b> <i>before</i><b>,
size_t</b> <i>size</i><b>, uint64_t</b> <i>type_num</i><b>,
<br>
pmemobj_constr</b> <i>constructor</i><b>, void
*</b><i>arg</i><b>); <br>
int pmemobj_list_remove(PMEMobjpool *</b><i>pop</i><b>,
size_t</b> <i>pe_offset</i><b>, void *</b><i>head</i><b>,
<br>
PMEMoid</b> <i>oid</i><b>, int</b> <i>free</i><b>); <br>
int pmemobj_list_move(PMEMobjpool *</b><i>pop</i><b>, <br>
size_t</b> <i>pe_old_offset</i><b>, void
*</b><i>head_old</i><b>, <br>
size_t</b> <i>pe_new_offset</i><b>, void
*</b><i>head_new</i><b>, <br>
PMEMoid</b> <i>dest</i><b>, int</b> <i>before</i><b>,
PMEMoid</b> <i>oid</i><b>);</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_ENTRY(</b><i>TYPE</i><b>)
<br>
POBJ_LIST_HEAD(</b><i>HEADNAME</i><b>,</b>
<i>TYPE</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_FIRST(POBJ_LIST_HEAD
*</b><i>head</i><b>) <br>
POBJ_LIST_LAST(POBJ_LIST_HEAD *</b><i>head</i><b>,
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>) <br>
POBJ_LIST_EMPTY(POBJ_LIST_HEAD *</b><i>head</i><b>) <br>
POBJ_LIST_NEXT(TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b>
<i>FIELD</i><b>) <br>
POBJ_LIST_PREV(TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b>
<i>FIELD</i><b>) <br>
POBJ_LIST_DEST_HEAD <br>
POBJ_LIST_DEST_TAIL</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_FOREACH(TOID</b>
<i>var</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>,
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>) <br>
POBJ_LIST_FOREACH_REVERSE(TOID</b> <i>var</i><b>,
POBJ_LIST_HEAD *</b><i>head</i><b>, POBJ_LIST_ENTRY</b>
<i>FIELD</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_INSERT_HEAD(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)
<br>
POBJ_LIST_INSERT_TAIL(PMEMobjpool *</b><i>pop</i><b>,
POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)
<br>
POBJ_LIST_INSERT_AFTER(PMEMobjpool *</b><i>pop</i><b>,
POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
TOID</b> <i>listelm</i><b>, TOID</b> <i>elm</i><b>,
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>) <br>
POBJ_LIST_INSERT_BEFORE(PMEMobjpool *</b><i>pop</i><b>,
POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
TOID</b> <i>listelm</i><b>, TOID</b> <i>elm</i><b>,
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>) <br>
POBJ_LIST_INSERT_NEW_HEAD(PMEMobjpool *</b><i>pop</i><b>,
POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, size_t</b>
<i>size</i><b>, <br>
pmemobj_constr</b> <i>constructor</i><b>, void
*</b><i>arg</i><b>) <br>
POBJ_LIST_INSERT_NEW_TAIL(PMEMobjpool *</b><i>pop</i><b>,
POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, size_t</b>
<i>size</i><b>, <br>
void (*</b><i>constructor</i><b>)(PMEMobjpool
*</b><i>pop</i><b>, void *</b><i>ptr</i><b>, void
*</b><i>arg</i><b>), <br>
void *</b><i>arg</i><b>) <br>
POBJ_LIST_INSERT_NEW_AFTER(PMEMobjpool *</b><i>pop</i><b>,
POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
TOID</b> <i>listelm</i><b>, POBJ_LIST_ENTRY</b>
<i>FIELD</i><b>, size_t</b> <i>size</i><b>, <br>
pmemobj_constr</b> <i>constructor</i><b>, void
*</b><i>arg</i><b>) <br>
POBJ_LIST_INSERT_NEW_BEFORE(PMEMobjpool *</b><i>pop</i><b>,
POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
TOID</b> <i>listelm</i><b>, POBJ_LIST_ENTRY</b>
<i>FIELD</i><b>, size_t</b> <i>size</i><b>, <br>
pmemobj_constr</b> <i>constructor</i><b>, void
*</b><i>arg</i><b>) <br>
POBJ_LIST_REMOVE(PMEMobjpool *</b><i>pop</i><b>,
POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)
<br>
POBJ_LIST_REMOVE_FREE(PMEMobjpool *</b><i>pop</i><b>,
POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)
<br>
POBJ_LIST_MOVE_ELEMENT_HEAD(PMEMobjpool *</b><i>pop</i><b>,
POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
POBJ_LIST_HEAD *</b><i>head_new</i><b>, TOID</b>
<i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, <br>
POBJ_LIST_ENTRY</b> <i>field_new</i><b>) <br>
POBJ_LIST_MOVE_ELEMENT_TAIL(PMEMobjpool *</b><i>pop</i><b>,
POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
POBJ_LIST_HEAD *</b><i>head_new</i><b>, TOID</b>
<i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, <br>
POBJ_LIST_ENTRY</b> <i>field_new</i><b>) <br>
POBJ_LIST_MOVE_ELEMENT_AFTER(PMEMobjpool *</b><i>pop</i><b>,
POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
POBJ_LIST_HEAD *</b><i>head_new</i><b>, TOID</b>
<i>listelm</i><b>, TOID</b> <i>elm</i><b>, <br>
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, POBJ_LIST_ENTRY</b>
<i>field_new</i><b>) <br>
POBJ_LIST_MOVE_ELEMENT_BEFORE(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
POBJ_LIST_HEAD *</b><i>head_new</i><b>, TOID</b>
<i>listelm</i><b>, TOID</b> <i>elm</i><b>, <br>
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, POBJ_LIST_ENTRY</b>
<i>field_new</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Transactional
object manipulation:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>enum
tx_stage pmemobj_tx_stage(void);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_tx_begin(PMEMobjpool *</b><i>pop</i><b>, jmp_buf
*</b><i>env</i><b>, enum</b> <i>tx_lock</i><b>,</b>
<i>...</i><b>); <br>
int pmemobj_tx_lock(enum tx_lock</b> <i>lock_type</i><b>,
void *</b><i>lockp</i><b>); <br>
void pmemobj_tx_abort(int</b> <i>errnum</i><b>); <br>
void pmemobj_tx_commit(void); <br>
int pmemobj_tx_end(void); <br>
int pmemobj_tx_errno(void); <br>
void pmemobj_tx_process(void);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_tx_add_range(PMEMoid</b> <i>oid</i><b>, uint64_t</b>
<i>off</i><b>, size_t</b> <i>size</i><b>); <br>
int pmemobj_tx_add_range_direct(const void
*</b><i>ptr</i><b>, size_t</b> <i>size</i><b>); <br>
PMEMoid pmemobj_tx_alloc(size_t</b> <i>size</i><b>,
uint64_t</b> <i>type_num</i><b>); <br>
PMEMoid pmemobj_tx_zalloc(size_t</b> <i>size</i><b>,
uint64_t</b> <i>type_num</i><b>); <br>
PMEMoid pmemobj_tx_realloc(PMEMoid</b> <i>oid</i><b>,
size_t</b> <i>size</i><b>, uint64_t</b> <i>type_num</i><b>);
<br>
PMEMoid pmemobj_tx_zrealloc(PMEMoid</b> <i>oid</i><b>,
size_t</b> <i>size</i><b>, uint64_t</b> <i>type_num</i><b>);
<br>
PMEMoid pmemobj_tx_strdup(const char *</b><i>s</i><b>,
uint64_t</b> <i>type_num</i><b>); <br>
int pmemobj_tx_free(PMEMoid</b> <i>oid</i><b>);</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_BEGIN_LOCK(PMEMobjpool
*</b><i>pop</i><b>,</b> <i>...</i><b>) <br>
TX_BEGIN(PMEMobjpool *</b><i>pop</i><b>) <br>
TX_ONABORT <br>
TX_ONCOMMIT <br>
TX_FINALLY <br>
TX_END</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_ADD(TOID</b>
<i>o</i><b>) <br>
TX_ADD_FIELD(TOID</b> <i>o</i><b>,</b> <i>FIELD</i><b>) <br>
TX_ADD_DIRECT(TYPE *</b><i>p</i><b>) <br>
TX_ADD_FIELD_DIRECT(TYPE *</b><i>p</i><b>,</b>
<i>FIELD</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_NEW(</b><i>TYPE</i><b>)
<br>
TX_ALLOC(</b><i>TYPE</i><b>, size_t</b> <i>size</i><b>) <br>
TX_ZNEW(</b><i>TYPE</i><b>) <br>
TX_ZALLOC(</b><i>TYPE</i><b>, size_t</b> <i>size</i><b>)
<br>
TX_REALLOC(TOID</b> <i>o</i><b>, size_t</b> <i>size</i><b>)
<br>
TX_ZREALLOC(TOID</b> <i>o</i><b>, size_t</b> <i>size</i><b>)
<br>
TX_STRDUP(const char *</b><i>s</i><b>, uint64_t</b>
<i>type_num</i><b>) <br>
TX_FREE(TOID</b> <i>o</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_SET(TOID</b>
<i>o</i><b>,</b> <i>FIELD</i><b>,</b> <i>VALUE</i><b>) <br>
TX_SET_DIRECT(TYPE *</b><i>p</i><b>,</b>
<i>FIELD</i><b>,</b> <i>VALUE</i><b>) <br>
TX_MEMCPY(void *</b><i>dest</i><b>, const void
*</b><i>src</i><b>, size_t</b> <i>num</i><b>) <br>
TX_MEMSET(void *</b><i>dest</i><b>, int</b> <i>c</i><b>,
size_t</b> <i>num</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Library API
versioning:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>const char
*pmemobj_check_version( <br>
unsigned</b> <i>major_required</i><b>, <br>
unsigned</b> <i>minor_required</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Managing
library behavior:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pmemobj_set_funcs( <br>
void *(*</b><i>malloc_func</i><b>)(size_t</b>
<i>size</i><b>), <br>
void (*</b><i>free_func</i><b>)(void *</b><i>ptr</i><b>),
<br>
void *(*</b><i>realloc_func</i><b>)(void *</b><i>ptr</i><b>,
size_t</b> <i>size</i><b>), <br>
char *(*</b><i>strdup_func</i><b>)(const char
*</b><i>s</i><b>)); <br>
int pmemobj_check(const char *</b><i>path</i><b>, const char
*</b><i>layout</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Error
handling:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>const char
*pmemobj_errormsg(void);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>libpmemobj</b>
provides a transactional object store in <i>persistent
memory</i> (pmem). This library is intended for applications
using direct access storage (DAX), which is storage that
supports load/store access without paging blocks from a
block storage device. Some types of <i>non-volatile memory
DIMMs</i> (NVDIMMs) provide this type of byte addressable
access to storage. A <i>persistent memory aware file
system</i> is typically used to expose the direct access to
applications. Memory mapping a file from this type of file
system results in the load/store, non-paged access to pmem.
<b>libpmemobj</b> builds on this type of memory mapped
file.</p>

<p style="margin-left:11%; margin-top: 1em">This library is
for applications that need a transactions and persistent
memory management. The <b>libpmemobj</b> requires a
<b>-std=gnu99</b> compilation flag to build properly. This
library builds on the low-level pmem support provided by
<b>libpmem</b>, handling the transactional updates, flushing
changes to persistence, and recovery for the
application.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libpmemobj</b>
is one of a collection of persistent memory libraries
available, the others are:</p>


<p style="margin-left:22%; margin-top: 1em"><b>libpmemblk</b>(3),
providing pmem-resident arrays of fixed-sized blocks with
atomic updates.</p>


<p style="margin-left:22%; margin-top: 1em"><b>libpmemlog</b>(3),
providing a pmem-resident log file.</p>


<p style="margin-left:22%; margin-top: 1em"><b>libpmem</b>(3),
low-level persistent memory support.</p>

<p style="margin-left:11%; margin-top: 1em">Under normal
usage, <b>libpmemobj</b> will never print messages or
intentionally cause the process to exit. The only exception
to this is the debugging information, when enabled, as
described under <b>DEBUGGING AND ERROR HANDLING</b>
below.</p>

<h2>MOST COMMONLY USED FUNCTIONS
<a name="MOST COMMONLY USED FUNCTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To use the
pmem-resident transactional object store provided by
<b>libpmemobj</b>, a <i>memory pool</i> is first created.
This is done with the <b>pmemobj_create</b>() function
described in this section. The other functions described in
this section then operate on the resulting memory pool.</p>

<p style="margin-left:11%; margin-top: 1em">Once created,
the memory pool is represented by an opaque handle, of type
<i>PMEMobjpool *</i>, which is passed to most of the other
functions in this section. Internally, <b>libpmemobj</b>
will use either <b>pmem_persist</b>() or <b>msync</b>(2)
when it needs to flush changes, depending on whether the
memory pool appears to be persistent memory or a regular
file (see the <b>pmem_is_pmem</b>() function in
<b>libpmem</b>(3) for more information). There is no need
for applications to flush changes directly when using the
obj memory API provided by <b>libpmemobj</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>PMEMobjpool
*pmemobj_open(const char *</b><i>path</i><b>, const char
*</b><i>layout</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_open</b>() function opens an existing object
store memory pool, returning a memory pool handle used with
most of the functions in this section. <i>path</i> must be
an existing file containing a pmemobj memory pool as created
by <b>pmemobj_create</b>(). If <i>layout</i> is non-NULL, it
is compared to the layout name provided to
<b>pmemobj_create</b>() when the pool was first created.
This can be used to verify the layout of the pool matches
what was expected. The application must have permission to
open the file and memory map it with read/write permissions.
If an error prevents the pool from being opened, or if the
given <i>layout</i> does not match the pool&rsquo;s layout,
<b>pmemobj_open</b>() returns NULL and sets errno
appropriately.</p>

<p style="margin-left:11%; margin-top: 1em"><b>PMEMobjpool
*pmemobj_create(const char *</b><i>path</i><b>, const char
*</b><i>layout</i><b>, <br>
size_t</b> <i>poolsize</i><b>, mode_t</b>
<i>mode</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_create</b>() function creates a transactional
object store with the given total <i>poolsize</i>.
<i>path</i> specifies the name of the memory pool file to be
created. <i>layout</i> specifies the application&rsquo;s
layout type in the form of a string. The layout name is not
interpreted by <b>libpmemobj</b>, but may be used as a check
when <b>pmemobj_open</b>() is called. The layout name,
including the null termination, cannot be longer than
<b>PMEMOBJ_MAX_LAYOUT</b> as defined in
<b>&lt;libpmemobj.h&gt;</b>. It is allowed to pass NULL as
<i>layout</i>, which is equivalent for using an empty string
as a layout name. <i>mode</i> specifies the permissions to
use when creating the file as described by <b>creat</b>(2).
The memory pool file is fully allocated to the size
<i>poolsize</i> using <b>posix_fallocate</b>(3). The caller
may choose to take responsibility for creating the memory
pool file by creating it before calling
<b>pmemobj_create</b>() and then specifying <i>poolsize</i>
as zero. In this case <b>pmemobj_create</b>() will take the
pool size from the size of the existing file and will verify
that the file appears to be empty by searching for any
non-zero data in the pool header at the beginning of the
file. The minimum file size allowed by the library for a
transactional object store is defined in
<b>&lt;libpmemobj.h&gt;</b> as <b>PMEMOBJ_MIN_POOL</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pmemobj_close(PMEMobjpool *</b><i>pop</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_close</b>() function closes the memory pool
indicated by <i>pop</i> and deletes the memory pool handle.
The object store itself lives on in the file that contains
it and may be re-opened at a later time using
<b>pmemobj_open</b>() as described above.</p>

<h2>LOW-LEVEL MEMORY MANIPULATION
<a name="LOW-LEVEL MEMORY MANIPULATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>libpmemobj</b> specific low-level memory manipulation
functions leverage the knowledge of the additional
configuration options available for <b>libpmemobj</b> pools,
such as replication. They also take advantage of the type of
storage behind the pool and use appropriate flush/drain
functions. It is advised to use these functions in
conjunction with <b>libpmemobj</b> objects, instead of using
low-level memory manipulations functions from
<b>libpmem</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pmemobj_persist(PMEMobjpool *</b><i>pop</i><b>, const void
*</b><i>addr</i><b>, size_t</b> <i>len</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">Forces any
changes in the range [<i>addr</i>, <i>addr</i>+<i>len</i>)
to be stored durably in persistent memory. Internally this
may call either <b>pmem_msync</b>() or
<b>pmem_persist</b>(). There are no alignment restrictions
on the range described by <i>addr</i> and <i>len</i>, but
<b>pmemobj_persist</b>() may expand the range as necessary
to meet platform alignment requirements.</p>

<p style="margin-left:22%; margin-top: 1em">WARNING: Like
<b>msync</b>(2), there is nothing atomic or transactional
about this call. Any unwritten stores in the given range
will be written, but some stores may have already been
written by virtue of normal cache eviction/replacement
policies. Correctly written code must not depend on stores
waiting until <b>pmemobj_persist</b>() is called to become
persistent -- they can become persistent at any time before
<b>pmemobj_persist</b>() is called.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pmemobj_flush(PMEMobjpool *</b><i>pop</i><b>, const void
*</b><i>addr</i><b>, size_t</b> <i>len</i><b>); <br>
void pmemobj_drain(PMEMobjpool *</b><i>pop</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">These functions
provide partial versions of the <b>pmemobj_persist</b>()
function described above. <b>pmemobj_persist</b>() can be
thought of as this:</p>

<p style="margin-left:22%; margin-top: 1em">void <br>
pmemobj_persist(PMEMobjpool *pop, const void *addr, size_t
len) <br>
{ <br>
/* flush the processor caches */ <br>
pmemobj_flush(pop, addr, len);</p>

<p style="margin-left:22%; margin-top: 1em">/* wait for any
pmem stores to drain from HW buffers */ <br>
pmemobj_drain(pop); <br>
}</p>

<p style="margin-left:22%; margin-top: 1em">These functions
allow advanced programs to create their own variations of
<b>pmemobj_persist</b>(). For example, a program that needs
to flush several discontiguous ranges can call
<b>pmemobj_flush</b>() for each range and then follow up by
calling <b>pmemobj_drain</b>() once. For more information on
partial flushing operations see the <b>libpmem</b>
manpage.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
*pmemobj_memcpy_persist(PMEMobjpool *</b><i>pop</i><b>, void
*</b><i>dest</i><b>, <br>
const void *</b><i>src</i><b>, size_t</b> <i>len</i><b>);
<br>
void *pmemobj_memset_persist(PMEMobjpool *</b><i>pop</i><b>,
void *</b><i>dest</i><b>, <br>
int</b> <i>c</i><b>, size_t</b> <i>len</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_memcpy_persist</b>(), and
<b>pmemobj_memset_persist</b>(), functions provide the same
memory copying as their namesakes <b>memcpy</b>(3), and
<b>memset</b>(3), and ensure that the result has been
flushed to persistence before returning. For example, the
following code is functionally equivalent to
<b>pmemobj_memcpy_persist</b>():</p>

<p style="margin-left:22%; margin-top: 1em">void * <br>
pmemobj_memcpy_persist(PMEMobjpool *pop, void *dest, <br>
const void *src, size_t len) <br>
{ <br>
void *retval = memcpy(pop, dest, src, len);</p>


<p style="margin-left:22%; margin-top: 1em">pmemobj_persist(pop,
dest, len);</p>

<p style="margin-left:22%; margin-top: 1em">return retval;
<br>
}</p>

<h2>POOL SETS AND REPLICAS
<a name="POOL SETS AND REPLICAS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Depending on
the configuration of the system, the available space of
non-volatile memory space may be divided into multiple
memory devices. In such case, the maximum size of the
transactional object store could be limited by the capacity
of a single memory device. The <b>libpmemobj</b> allows
building transactional object stores spanning multiple
memory devices by creation of persistent memory pools
consisting of multiple files, where each part of such a
<i>pool set</i> may be stored on different pmem-aware
filesystem.</p>

<p style="margin-left:11%; margin-top: 1em">To improve
reliability and eliminate the single point of failure, all
the changes of the data stored in the persistent memory pool
could be also automatically written to local pool replicas,
thereby providing a backup for a persistent memory pool by
producing a <i>mirrored pool set</i>. In practice, the pool
replicas may be considered binary copies of the
&quot;master&quot; pool set.</p>

<p style="margin-left:11%; margin-top: 1em">Creation of all
the parts of the pool set and the associated replica sets
can be done with the <b>pmemobj_create</b>() function or by
using the <b>pmempool</b>(1) utility.</p>

<p style="margin-left:11%; margin-top: 1em">When creating
the pool set consisting of multiple files, or when creating
the replicated pool set, the <i>path</i> argument passed to
<b>pmemobj_create</b>() must point to the special <i>set</i>
file that defines the pool layout and the location of all
the parts of the pool set. The <i>poolsize</i> argument must
be 0. The meaning of <i>layout</i> and <i>mode</i> arguments
doesn&rsquo;t change, except that the same <i>mode</i> is
used for creation of all the parts of the pool set and
replicas. If the error prevents any of the pool set files
from being created, <b>pmemobj_create</b>() returns NULL and
sets errno appropriately.</p>

<p style="margin-left:11%; margin-top: 1em">When opening
the pool set consisting of multiple files, or when opening
the replicated pool set, the <i>path</i> argument passed to
<b>pmemobj_open</b>() must not point to the pmemobj memory
pool file, but to the same <i>set</i> file that was used for
the pool set creation. If an error prevents any of the pool
set files from being opened, or if the actual size of any
file does not match the corresponding part size defined in
<i>set</i> file <b>pmemobj_open</b>() returns NULL and sets
errno appropriately.</p>

<p style="margin-left:11%; margin-top: 1em">The set file is
a plain text file, which must start with the line containing
a <i>PMEMPOOLSET</i> string, followed by the specification
of all the pool parts in the next lines. For each part, the
file size and the absolute path must be provided. The size
has to be compliant with the format specified in IEC
80000-13, IEEE 1541 or the Metric Interchange Format.
Standards accept SI units with obligatory B - kB, MB, GB ...
(multiplier by 1000) and IEC units with optional
&quot;iB&quot; - KiB, MiB, GiB, ..., K, M, G, ... -
(multiplier by 1024).</p>

<p style="margin-left:11%; margin-top: 1em">The minimum
file size of each part of the pool set is the same as the
minimum size allowed for a transactional object store
consisting of one file. It is defined in
<b>&lt;libpmemobj.h&gt;</b> as <b>PMEMOBJ_MIN_POOL</b>.
Sections defining the replica sets are optional. There could
be multiple replica sections and each must start with the
line containing a <i>REPLICA</i> string. Lines starting with
&quot;#&quot; character are ignored.</p>

<p style="margin-left:11%; margin-top: 1em">Here is the
example &quot;myobjpool.set&quot; file:</p>

<p style="margin-left:22%; margin-top: 1em">PMEMPOOLSET
<br>
100G /mountpoint0/myfile.part0 <br>
200G /mountpoint1/myfile.part1 <br>
400G /mountpoint2/myfile.part2 <br>
REPLICA <br>
500G /mountpoint3/mymirror.part0 <br>
200G /mountpoint4/mymirror.part1</p>

<p style="margin-left:11%; margin-top: 1em">The files in
the set may be created by running the following command:</p>

<p style="margin-left:22%; margin-top: 1em">pmempool create
--layout=&quot;mylayout&quot; obj myobjpool.set</p>

<h2>LOCKING
<a name="LOCKING"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>libpmemobj</b>
provides several types of synchronization primitives,
designed so as to use them with persistent memory. The locks
are not dynamically allocated, but embedded in pmem-resident
objects. For performance reasons, they are also padded up to
64 bytes (cache line size).</p>

<p style="margin-left:11%; margin-top: 1em">Pmem-aware
locks implementation is based on the standard POSIX Thread
Library, as described in <b>pthread_mutex</b>(3),
<b>pthread_rwlock</b>(3) and <b>pthread_cond</b>(3). They
provide semantics similar to standard <b>pthread</b> locks,
except that they are considered initialized by zeroing them.
So allocating the locks with <b>pmemobj_zalloc</b>() or
<b>pmemobj_tx_zalloc</b>() does not require another
initialization step.</p>

<p style="margin-left:11%; margin-top: 1em">The fundamental
property of pmem-aware locks is their automatic
reinitialization every time the persistent object store pool
is open. This way, all the pmem-aware locks may be
considered initialized (unlocked) right after opening the
pool, regardless of their state at the time the pool was
closed for the last time.</p>

<p style="margin-left:11%; margin-top: 1em">Pmem-aware
mutexes, read/write locks and condition variables must be
declared with one of the <i>PMEMmutex</i>,
<i>PMEMrwlock</i>, or <i>PMEMcond</i> type respectively.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pmemobj_mutex_zero(PMEMobjpool *</b><i>pop</i><b>, PMEMmutex
*</b><i>mutexp</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_mutex_zero</b>() function explicitly initializes
pmem-aware mutex pointed by <i>mutexp</i> by zeroing it.
Initialization is not necessary if the object containing the
mutex has been allocated using one of
<b>pmemobj_zalloc</b>() or <b>pmemobj_tx_zalloc</b>()
functions.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_mutex_lock(PMEMobjpool *</b><i>pop</i><b>, PMEMmutex
*</b><i>mutexp</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_mutex_lock</b>() function locks pmem-aware mutex
pointed by <i>mutexp</i>. If the mutex is already locked,
the calling thread will block until the mutex becomes
available. If this is the first use of the mutex since
opening of the pool <i>pop</i>, the mutex is automatically
reinitialized and then locked.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_mutex_timedlock(PMEMobjpool *</b><i>pop</i><b>, <br>
PMEMmutex *restrict</b> <i>mutexp</i><b>, <br>
const struct timespec *restrict</b>
<i>abs_timeout</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_mutex_timedlock</b>() performs the same action as
<b>pmemobj_mutex_lock</b>(), but will not wait beyond
<i>abs_timeout</i> to obtain the lock before returning.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_mutex_trylock(PMEMobjpool *</b><i>pop</i><b>,
PMEMmutex *</b><i>mutexp</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_mutex_trylock</b>() function locks pmem-aware
mutex pointed by <i>mutexp</i>. If the mutex is already
locked, <b>pthread_mutex_trylock</b>() will not block
waiting for the mutex, but will return an error condition.
If this is the first use of the mutex since opening of the
pool <i>pop</i> the mutex is automatically reinitialized and
then locked.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_mutex_unlock(PMEMobjpool *</b><i>pop</i><b>,
PMEMmutex *</b><i>mutexp</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_mutex_unlock</b>() function unlocks an acquired
pmem-aware mutex pointed by <i>mutexp</i>. Undefined
behavior follows if a thread tries to unlock a mutex that
has not been locked by it, or if a thread tries to release a
mutex that is already unlocked or not initialized.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pmemobj_rwlock_zero(PMEMobjpool *</b><i>pop</i><b>,
PMEMrwlock *</b><i>rwlockp</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_rwlock_zero</b>() function is used to explicitly
initialize pmem-aware read/write lock pointed by
<i>rwlockp</i> by zeroing it. Initialization is not
necessary if the object containing the lock has been
allocated using one of <b>pmemobj_zalloc</b>() or
<b>pmemobj_tx_zalloc</b>() functions.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_rwlock_rdlock(PMEMobjpool *</b><i>pop</i><b>,
PMEMrwlock *</b><i>rwlockp</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_rwlock_rdlock</b>() function acquires a read lock
on <i>rwlockp</i> provided that lock is not presently held
for writing and no writer threads are presently blocked on
the lock. If the read lock cannot be immediately acquired,
the calling thread blocks until it can acquire the lock. If
this is the first use of the lock since opening of the pool
<i>pop</i>, the lock is automatically reinitialized and then
acquired.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_rwlock_timedrdlock(PMEMobjpool *</b><i>pop</i><b>,
<br>
PMEMrwlock *restrict</b> <i>rwlockp</i><b>, <br>
const struct timespec *restrict</b>
<i>abs_timeout</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_rwlock_timedrdlock</b>() performs the same
action, but will not wait beyond <i>abs_timeout</i> to
obtain the lock before returning.</p>

<p style="margin-left:11%; margin-top: 1em">A thread may
hold multiple concurrent read locks. If so,
<b>pmemobj_rwlock_unlock</b>() must be called once for each
lock obtained.</p>

<p style="margin-left:11%; margin-top: 1em">The results of
acquiring a read lock while the calling thread holds a write
lock are undefined.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_rwlock_wrlock(PMEMobjpool *</b><i>pop</i><b>,
PMEMrwlock *</b><i>rwlockp</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_rwlock_wrlock</b>() function blocks until a write
lock can be acquired against lock pointed by <i>rwlockp</i>.
If this is the first use of the lock since opening of the
pool <i>pop</i>, the lock is automatically reinitialized and
then acquired.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_rwlock_timedwrlock(PMEMobjpool *</b><i>pop</i><b>,
<br>
PMEMrwlock *restrict</b> <i>rwlockp</i><b>, <br>
const struct timespec *restrict</b>
<i>abs_timeout</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_rwlock_timedwrlock</b>() performs the same
action, but will not wait beyond <i>abs_timeout</i> to
obtain the lock before returning.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_rwlock_tryrdlock(PMEMobjpool *</b><i>pop</i><b>,
PMEMrwlock *</b><i>rwlockp</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_rwlock_tryrdlock</b>() function performs the same
action as <b>pmemobj_rwlock_rdlock</b>(), but does not block
if the lock cannot be immediately obtained.</p>

<p style="margin-left:22%; margin-top: 1em">The results are
undefined if the calling thread already holds the lock at
the time the call is made.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_rwlock_trywrlock(PMEMobjpool *</b><i>pop</i><b>,
PMEMrwlock *</b><i>rwlockp</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_rwlock_trywrlock</b>() function performs the same
action as <b>pmemobj_rwlock_wrlock</b>(), but does not block
if the lock cannot be immediately obtained.</p>

<p style="margin-left:22%; margin-top: 1em">The results are
undefined if the calling thread already holds the lock at
the time the call is made.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_rwlock_unlock(PMEMobjpool *</b><i>pop</i><b>,
PMEMrwlock *</b><i>rwlockp</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_rwlock_unlock</b>() function is used to release
the read/write lock previously obtained by
<b>pmemobj_rwlock_rdlock</b>(),
<b>pmemobj_rwlock_wrlock</b>(),
<b>pthread_rwlock_tryrdlock</b>(), or
<b>pmemobj_rwlock_trywrlock</b>().</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pmemobj_cond_zero(PMEMobjpool *</b><i>pop</i><b>, PMEMcond
*</b><i>condp</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_cond_zero</b>() function explicitly initializes
pmem-aware condition variable by zeroing it. Initialization
is not necessary if the object containing the condition
variable has been allocated using one of
<b>pmemobj_zalloc</b>() or <b>pmemobj_tx_zalloc</b>()
functions.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_cond_broadcast(PMEMobjpool *</b><i>pop</i><b>,
PMEMcond *</b><i>condp</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_cond_signal(PMEMobjpool *</b><i>pop</i><b>, PMEMcond
*</b><i>condp</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The difference
between <b>pmemobj_cond_broadcast</b>() and
<b>pmemobj_cond_signal</b>() is that the former unblocks all
threads waiting for the condition variable, whereas the
latter blocks only one waiting thread. If no threads are
waiting on <i>cond</i>, neither function has any effect. If
more than one thread is blocked on a condition variable, the
used scheduling policy determines the order in which threads
are unblocked. The same mutex used for waiting must be held
while calling either function. Although neither function
strictly enforces this requirement, undefined behavior may
follow if the mutex is not held.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_cond_timedwait(PMEMobjpool *</b><i>pop</i><b>,
PMEMcond *restrict</b> <i>condp</i><b>, <br>
PMEMmutex *restrict</b> <i>mutexp</i><b>, <br>
const struct timespec *restrict</b>
<i>abs_timeout</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_cond_wait(PMEMobjpool *</b><i>pop</i><b>, PMEMcond
*</b><i>condp</i><b>, <br>
PMEMmutex *restrict</b> <i>mutexp</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_cond_timedwait</b>() and
<b>pmemobj_cond_wait</b>() functions shall block on a
condition variable. They shall be called with mutex locked
by the calling thread or undefined behavior results. These
functions atomically release mutex pointed by <i>mutexp</i>
and cause the calling thread to block on the condition
variable <i>cond</i>; atomically here means &quot;atomically
with respect to access by another thread to the mutex and
then the condition variable&quot;. That is, if another
thread is able to acquire the mutex after the about-to-block
thread has released it, then a subsequent call to
<b>pmemobj_cond_broadcast</b>() or
<b>pmemobj_cond_signal</b>() in that thread shall behave as
if it were issued after the about-to-block thread has
blocked. Upon successful return, the mutex shall have been
locked and shall be owned by the calling thread.</p>

<h2>PERSISTENT OBJECTS
<a name="PERSISTENT OBJECTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Each object
stored in persistent memory pool is represented by an object
handle of type <i>PMEMoid</i>. In practice, such a handle is
a unique Object IDentifier (OID) of a global scope, which
means that two objects from different pools may not have the
same OID. The special <i>OID_NULL</i> macro defines a
NULL-like handle that does not represent any object. The
size of a single object is limited by a
<i>PMEMOBJ_MAX_ALLOC_SIZE</i>. Thus an allocation with
requested size greater than this value will fail.</p>

<p style="margin-left:11%; margin-top: 1em">An OID cannot
be considered as a direct pointer to an object. Each time
the program attempts to read or write object data, it must
obtain the current memory address of the object by
converting its OID into the pointer.</p>

<p style="margin-left:11%; margin-top: 1em">In contrast to
the memory address, the OID value for given object does not
change during the life of an object (except for realloc
operation), and remains valid after closing and reopening
the pool. For this reason, if an object contains a reference
to another persistent object - necessary to build some kind
of a linked data structure - it shall never use memory
address of an object, but its OID.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
*pmemobj_direct(PMEMoid</b> <i>oid</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_direct</b>() function returns a pointer to an
object represented by <i>oid</i>. If OID_NULL is passed as
an argument, function returns NULL.</p>

<p style="margin-left:11%; margin-top: 1em"><b>uint64_t
pmemobj_type_num(PMEMoid</b> <i>oid</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_type_num</b>() function returns a type number of
the object represented by <i>oid</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>PMEMobjpool
*pmemobj_pool_by_oid(PMEMoid</b> <i>oid</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_pool_by_oid</b>() function returns a handle to
the pool which contains the object represented by
<i>oid</i>. If the pool is not open or OID_NULL is passed as
an argument, function returns NULL.</p>

<p style="margin-left:11%; margin-top: 1em"><b>PMEMobjpool
*pmemobj_pool_by_ptr(const void
*</b><i>addr</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_pool_by_ptr</b>() function returns a handle to
the pool which contains the address. If the address does not
belong to any open pool, function returns NULL.</p>

<p style="margin-left:11%; margin-top: 1em">At the time of
allocation (or reallocation), each object may be assigned a
number representing its type. Such a <i>type number</i> may
be used to arrange the persistent objects based on their
actual user-defined structure type, thus facilitating
implementation of a simple run-time type safety mechanism.
It also allows to iterate through all the objects of given
type stored in the persistent memory pool. See <b>OBJECT
CONTAINERS</b> section for more details.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>OID_IS_NULL</b> macro checks if given <i>PMEMoid</i>
represents a NULL object.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>OID_EQUALS</b> macro compares two <i>PMEMoid</i>
objects.</p>

<h2>TYPE-SAFETY
<a name="TYPE-SAFETY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Operating on
untyped object handles, as well as on direct untyped object
pointers (void *) may be confusing and error prone. To
facilitate implementation of type safety mechanism,
<b>libpmemobj</b> defines a set of macros that provide a
static type enforcement, catching potential errors at
compile time. For example, a compile-time error is generated
when an attempt is made to assign a handle to an object of
one type to the object handle variable of another type of
object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TOID_DECLARE(</b><i>TYPE</i><b>,
uint64_t</b> <i>type_num)</i></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TOID_DECLARE</b> macro declares a typed OID of
user-defined type specified by argument <i>TYPE</i>, and
with type number specified by argument <i>type_num</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TOID_DECLARE_ROOT(</b><i>ROOT_TYPE</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TOID_DECLARE_ROOT</b> macro declares a typed OID of
user-defined type specified by argument <i>ROOT_TYPE</i>,
and with type number for root object
<b>POBJ_ROOT_TYPE_NUM</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TOID(</b><i>TYPE</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The <b>TOID</b>
macro declares a handle to an object of type specified by
argument <i>TYPE</i>, where <i>TYPE</i> is the name of a
user-defined structure. The typed OID must be declared first
using the <b>TOID_DECLARE</b>, <b>TOID_DECLARE_ROOT</b>,
<b>POBJ_LAYOUT_TOID</b> or <b>POBJ_LAYOUT_ROOT</b>
macros.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TOID_TYPE_NUM(</b><i>TYPE</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TOID_TYPE_NUM</b> macro returns a type number of the type
specified by argument <i>TYPE</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TOID_TYPE_NUM_OF(TOID</b>
<i>oid</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TOID_TYPE_NUM_OF</b> macro returns a type number of the
object specified by argument <i>oid</i>. The type number is
read from the typed OID.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TOID_VALID(TOID</b>
<i>oid</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TOID_VALID</b> macro validates whether the type number
stored in object&rsquo;s metadata is equal to the type
number read from typed OID.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OID_INSTANCEOF(PMEMoid</b>
<i>oid</i><b>,</b> <i>TYPE</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>OID_INSTANCEOF</b> macro checks whether the <i>oid</i> is
of the type specified by argument <i>TYPE</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TOID_ASSIGN(TOID</b>
<i>o</i><b>,</b> <i>VALUE</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TOID_ASSIGN</b> macro assigns an object handle specified
by <i>VALUE</i> to the variable <i>o</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TOID_IS_NULL(TOID</b>
<i>o</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TOID_IS_NULL</b> macro evaluates to true if the object
handle represented by argument <i>o</i> has OID_NULL
value.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TOID_EQUALS(TOID</b>
<i>lhs</i><b>, TOID</b> <i>rhs</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TOID_EQUALS</b> macro evaluates to true if both
<i>lhs</i> and <i>rhs</i> object handles are referencing the
same persistent object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>DIRECT_RW(TOID</b>
<i>oid</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>D_RW(TOID</b>
<i>oid</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>DIRECT_RW</b>() macro and its shortened form
<b>D_RW</b>() return a typed write pointer (TYPE *) to an
object represented by <i>oid</i>. If <i>oid</i> holds
OID_NULL value, the macro evaluates to NULL.</p>


<p style="margin-left:11%; margin-top: 1em"><b>DIRECT_RO(TOID</b>
<i>oid</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>D_RO(TOID</b>
<i>oid</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>DIRECT_RO</b>() macro and its shortened form
<b>D_RO</b>() return a typed read-only (const) pointer (TYPE
*) to an object represented by <i>oid</i>. If <i>oid</i>
holds OID_NULL value, the macro evaluates to NULL.</p>

<h2>LAYOUT DECLARATION
<a name="LAYOUT DECLARATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>libpmemobj</i> defines a set of macros for convenient
declaration of pool&rsquo;s layout. The declaration of
layout consist of declaration of number of used types. The
declared types will be assigned consecutive type numbers.
Declared types may be used in conjunction with type safety
macros. Once created the layout declaration shall not be
changed unless the new types are added at the end of the
existing layout declaration. Modifying any of existing
declaration may lead to changes in type numbers of declared
types which in consequence may cause data corruption.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LAYOUT_BEGIN(</b><i>LAYOUT</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>POBJ_LAYOUT_BEGIN</b> macro indicates a begin of
declaration of layout. The <i>LAYOUT</i> argument is a name
of layout. This argument must be passed to all macros
related to the declaration of layout.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LAYOUT_TOID(</b><i>LAYOUT</i><b>,</b>
<i>TYPE</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>POBJ_LAYOUT_TOID</b> macro declares a typed OID for type
passed as <i>TYPE</i> argument inside the declaration of
layout. All types declared using this macro are assigned
with consecutive type numbers. This macro must be used
between the <b>POBJ_LAYOUT_BEGIN</b> and
<b>POBJ_LAYOUT_END</b> macros, with the same name passed as
<i>LAYOUT</i> argument.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LAYOUT_ROOT(</b><i>LAYOUT</i><b>,</b>
<i>ROOT_TYPE</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>POBJ_LAYOUT_ROOT</b> macro declares a typed OID for type
passed as <i>ROOT_TYPE</i> argument inside the declaration
of layout. The typed OID will be assigned with type number
for root object <b>POBJ_ROOT_TYPE_NUM</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LAYOUT_END(</b><i>LAYOUT</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>POBJ_LAYOUT_END</b> macro ends the declaration of
layout.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LAYOUT_NAME(</b><i>LAYOUT</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>POBJ_LAYOUT_NAME</b> macro returns the name of layout as
a NULL-terminated string.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LAYOUT_TYPES_NUM(</b><i>LAYOUT</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>POBJ_LAYOUT_TYPES_NUM</b> macro returns number of types
declared using the <b>POBJ_LAYOUT_TOID</b> macro within the
layout declaration.</p>

<p style="margin-left:11%; margin-top: 1em">This is an
example of layout declaration:</p>


<p style="margin-left:22%; margin-top: 1em">POBJ_LAYOUT_BEGIN(mylayout);
<br>
POBJ_LAYOUT_ROOT(mylayout, struct root); <br>
POBJ_LAYOUT_TOID(mylayout, struct node); <br>
POBJ_LAYOUT_TOID(mylayout, struct foo); <br>
POBJ_LAYOUT_END(mylayout);</p>

<p style="margin-left:22%; margin-top: 1em">struct root
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>TOID(struct node) node;</p></td></tr>
</table>

<p style="margin-left:22%;">};</p>

<p style="margin-left:22%; margin-top: 1em">struct node
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TOID(struct node) next;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TOID(struct foo) foo;</p></td></tr>
</table>

<p style="margin-left:22%;">};</p>

<p style="margin-left:11%; margin-top: 1em">The name of
layout and the number of declared types can be retrieved
using the following code:</p>

<p style="margin-left:22%; margin-top: 1em">const char
*layout_name = POBJ_LAYOUT_NAME(mylayout); <br>
int num_of_types = POBJ_LAYOUT_TYPES_NUM(mylayout);</p>

<h2>OBJECT CONTAINERS
<a name="OBJECT CONTAINERS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All the objects
in the persistent memory pool are assigned a <i>type
number</i> and are accessible by it.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>libpmemobj</i> provides a mechanism allowing to iterate
through the internal object collection, either looking for a
specific object, or performing a specific operation on each
object of given type. Software should not make any
assumptions about the order of the objects in the internal
object containers.</p>

<p style="margin-left:11%; margin-top: 1em"><b>PMEMoid
pmemobj_first(PMEMobjpool *</b><i>pop</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_first</b>() function returns the first object
from the pool. If the pool is empty, OID_NULL is
returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_FIRST(PMEMobjpool
*</b><i>pop</i><b>,</b> <i>TYPE</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>POBJ_FIRST</b> macro returns the first object from the
pool of the type specified by <i>TYPE</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_FIRST_TYPE_NUM(PMEMobjpool
*</b><i>pop</i><b>, uint64_t</b> <i>type_num</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>POBJ_FIRST_TYPE_NUM</b> macro returns the first object
from the pool of the type specified by <i>type_num</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>PMEMoid
pmemobj_next(PMEMoid</b> <i>oid</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_next</b>() function returns the next object from
the pool. If an object referenced by <i>oid</i> is the last
object in the collection, or if the OID_NULL is passed as an
argument, function returns OID_NULL.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_NEXT(TOID</b>
<i>oid</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>POBJ_NEXT</b> macro returns the next object of the same
type as the object referenced by <i>oid</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_NEXT_TYPE_NUM(PMEMoid</b>
<i>oid</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>POBJ_NEXT_TYPE_NUM</b> macro returns the next object of
the same type as the object referenced by <i>oid</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The following
four macros provide more convenient way to iterate through
the internal collections, performing a specific operation on
each object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_FOREACH(PMEMobjpool
*</b><i>pop</i><b>, PMEMoid</b> <i>varoid</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>POBJ_FOREACH</b>() macro allows to perform a specific
operation on each allocated object stored in the persistent
memory pool pointed by <i>pop</i>. It traverses the internal
collection of all the objects, assigning a handle to each
element in turn to <i>varoid</i> variable.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_FOREACH_TYPE(PMEMobjpool
*</b><i>pop</i><b>, TOID</b> <i>var</i><b>)</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>POBJ_FOREACH_TYPE</b>()
macro allows to perform a specific operation on each
allocated object of the same type as object passed as
<i>var</i> argument, stored in the persistent memory pool
pointed by <i>pop</i>. It traverses the internal collection
of all the objects of the specified type, assigning a handle
to each element in turn to <i>var</i> variable.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_FOREACH_SAFE(PMEMobjpool
*</b><i>pop</i><b>, PMEMoid</b> <i>varoid</i><b>, <br>
PMEMoid</b> <i>nvaroid</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_FOREACH_SAFE_TYPE(PMEMobjpool
*</b><i>pop</i><b>, TOID</b> <i>var</i><b>, TOID</b>
<i>nvar</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macros
<b>POBJ_FOREACH_SAFE</b>() and
<b>POBJ_FOREACH_SAFE_TYPE</b>() work in a similar fashion as
<b>POBJ_FOREACH</b>() and <b>POBJ_FOREACH_TYPE</b>() except
that prior to performing the operation on the object, they
preserve a handle to the next object in the collection by
assigning it to <i>nvaroid</i> or <i>nvar</i> variable. This
allows safe deletion of selected objects while iterating
through the collection.</p>

<h2>ROOT OBJECT MANAGEMENT
<a name="ROOT OBJECT MANAGEMENT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The root object
of persistent memory pool is an entry point for all other
persistent objects allocated using the <i>libpmemobj</i>
API. In other words, every single object stored in
persistent memory pool should have the root object at the
end of its reference path. It may be assumed that for each
persistent memory pool the root object always exists, and
there is exactly one root object in each pool.</p>

<p style="margin-left:11%; margin-top: 1em"><b>PMEMoid
pmemobj_root(PMEMobjpool *</b><i>pop</i><b>, size_t</b>
<i>size</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_root</b>() function returns a handle to the root
object associated with the persistent memory pool pointed by
<i>pop</i>. If this is the first call to
<b>pmemobj_root</b>() and the root object does not exists
yet, it is implicitly allocated in a thread-safe manner, so
if the function is called by more than one thread
simultaneously (with identical <i>size</i> value), the same
root object handle is returned in all the threads.</p>

<p style="margin-left:22%; margin-top: 1em">The size of the
root object is guaranteed to be not less than the requested
<i>size</i>. If the requested size is larger than the
current size, the root object is automatically resized. In
such case, the old data is preserved and the extra space is
zeroed. The <b>pmemobj_root</b>() function shall not fail,
except for the case if the requested object size is larger
than the maximum allocation size supported for given pool,
or if there is not enough free space in the pool to satisfy
the reallocation of the root object. In such case, OID_NULL
is returned.</p>

<p style="margin-left:11%; margin-top: 1em"><b>PMEMoid
pmemobj_root_construct(PMEMobjpool *</b><i>pop</i><b>,
size_t</b> <i>size</i><b>, <br>
pmemobj_constr</b> <i>constructor</i><b>, void
*</b><i>arg</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_root_construct</b>() performs the same actions as
the <b>pmemobj_root</b>() function, but instead of zeroing
the newly allocated object a <i>constructor</i> function is
called. The constructor is also called on reallocations. If
the constructor returns non-zero value the allocation is
canceled, the <b>OID_NULL</b> value is returned from the
caller and errno is set to <b>ECANCELED .</b> The
<b>pmemobj_root_size</b>() can be used in the constructor to
check whether it&rsquo;s the first call to the
constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_ROOT(PMEMobjpool
*</b><i>pop</i><b>,</b> <i>TYPE</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>POBJ_ROOT</b> macro works the same way as the
<b>pmemobj_root</b>() function except it returns a typed OID
of type <i>TYPE</i> instead of <b>PMEMoid</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>size_t
pmemobj_root_size(PMEMobjpool *</b><i>pop</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_root_size</b>() function returns the current size
of the root object associated with the persistent memory
pool pointed by <i>pop</i>. The returned size is the largest
value requested by any of the earlier <b>pmemobj_root</b>()
calls. 0 is returned if the root object has not been
allocated yet.</p>

<h2>NON-TRANSACTIONAL ATOMIC ALLOCATIONS
<a name="NON-TRANSACTIONAL ATOMIC ALLOCATIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Functions
described in this section provide the mechanism to allocate,
resize and free objects from the persistent memory pool in a
thread-safe and fail-safe manner. All the routines are
atomic with respect to other threads and any power-fail
interruptions. If any of those operations is torn by program
failure or system crash; on recovery they are guaranteed to
be entirely completed or discarded, leaving the persistent
memory heap and internal object containers in a consistent
state.</p>

<p style="margin-left:11%; margin-top: 1em">All these
functions can be used outside transactions. Note that
operations performed using non-transactional API are
considered durable after completion, even if executed within
the open transaction. Such non-transactional changes will
not be rolled-back if the transaction is aborted or
interrupted.</p>

<p style="margin-left:11%; margin-top: 1em">The allocations
are always aligned to the cache-line boundary.</p>

<p style="margin-left:11%; margin-top: 1em"><b>typedef int
(*</b><i>pmemobj_constr</i><b>)(PMEMobjpool
*</b><i>pop</i><b>, <br>
void *</b><i>ptr</i><b>, void *</b><i>arg</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_constr</b> type represents a constructor for
atomic allocation from persistent memory heap associated
with memory pool <i>pop</i>. The <i>ptr</i> is a pointer to
allocating memory area and the <i>arg</i> is an user-defined
argument passed to an appropriate function.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_alloc(PMEMobjpool *</b><i>pop</i><b>, PMEMoid
*</b><i>oidp</i><b>, size_t</b> <i>size</i><b>, <br>
uint64_t</b> <i>type_num</i><b>, pmemobj_constr</b>
<i>constructor</i> <b>, void *</b><i>arg</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_alloc</b> function allocates a new object from
the persistent memory heap associated with memory pool
<i>pop</i>. The <b>PMEMoid</b> of allocated object is stored
in <i>oidp</i>. If NULL is passed as <i>oidp</i>, then the
newly allocated object may be accessed only by iterating
objects in the object container associated with given
<i>type_num</i>, as described in <b>OBJECT CONTAINERS</b>
section. If the <i>oidp</i> points to memory location from
the <b>pmemobj</b> heap the <i>oidp</i> is modified
atomically. Before returning, it calls the
<b>constructor</b> function passing the pool handle
<i>pop</i>, the pointer to the newly allocated object in
<i>ptr</i> along with the <i>arg</i> argument. It is
guaranteed that allocated object is either properly
initialized, or if the allocation is interrupted before the
constructor completes, the memory space reserved for the
object is reclaimed. If the constructor returns non-zero
value the allocation is canceled, the -1 value is returned
from the caller and errno is set to <b>ECANCELED .</b> The
<i>size</i> can be any non-zero value, however due to
internal padding and object metadata, the actual size of the
allocation will differ from the requested one by at least 64
bytes. For this reason, making the allocations of a size
less than 64 bytes is extremely inefficient and discouraged.
If <i>size</i> equals 0, then <b>pmemobj_alloc</b>() returns
non-zero value, sets the errno and leaves the <i>oidp</i>
untouched. The allocated object is added to the internal
container associated with given <i>type_num</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_zalloc(PMEMobjpool *</b><i>pop</i><b>, PMEMoid
*</b><i>oidp</i><b>, size_t</b> <i>size</i><b>, <br>
uint64_t</b> <i>type_num</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_zalloc</b>() function allocates a new zeroed
object from the the persistent memory heap associated with
memory pool <i>pop</i>. The <b>PMEMoid</b> of allocated
object is stored in <i>oidp</i>. If NULL is passed as
<i>oidp</i>, then the newly allocated object may be accessed
only by iterating objects in the object container associated
with given <i>type_num</i>, as described in <b>OBJECT
CONTAINERS</b> section. If the <i>oidp</i> points to memory
location from the <b>pmemobj</b> heap the <i>oidp</i> is
modified atomically. The <i>size</i> can be any non-zero
value, however due to internal padding and object metadata,
the actual size of the allocation will differ from the
requested one by at least 64 bytes. For this reason, making
the allocations of a size less than 64 bytes is extremely
inefficient and discouraged. If <i>size</i> equals 0, then
<b>pmemobj_zalloc</b>() returns non-zero value, sets the
errno and leaves the <i>oidp</i> untouched. The allocated
object is added to the internal container associated with
given <i>type_num</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pmemobj_free(PMEMoid *</b><i>oidp</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_free</b>() function provides the same semantics
as <b>free</b>(3), but instead of the process heap supplied
by the system, it operates on the persistent memory heap. It
frees the memory space represented by <i>oidp</i>, which
must have been returned by a previous call to
<b>pmemobj_alloc</b>(), <b>pmemobj_zalloc</b>(),
<b>pmemobj_realloc</b>(), or <b>pmemobj_zrealloc</b>(). If
<i>oidp</i> is NULL or if it points to the root
object&rsquo;s OID, behavior of the function is undefined.
If it points to <i>OID_NULL</i>, no operation is performed.
It sets the <i>oidp</i> to <i>OID_NULL</i> value after
freeing the memory. If the <i>oidp</i> points to memory
location from the <b>pmemobj</b> heap the <i>oidp</i> is
changed atomically.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_realloc(PMEMobjpool *</b><i>pop</i><b>, PMEMoid
*</b><i>oidp</i><b>, size_t</b> <i>size</i><b>, <br>
uint64_t</b> <i>type_num</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_realloc</b>() function provide similar semantics
to <b>realloc</b>(3), but operates on the persistent memory
heap associated with memory pool <i>pop</i>. It changes the
size of the object represented by <i>oidp</i>, to
<i>size</i> bytes. The resized object is also added or moved
to the internal container associated with given
<i>type_num</i>. The contents will be unchanged in the range
from the start of the region up to the minimum of the old
and new sizes. If the new size is larger than the old size,
the added memory will <i>not</i> be initialized. If
<i>oidp</i> is NULL or if it points to the root
object&rsquo;s OID, behavior of the function is undefined.
If it points to <i>OID_NULL</i>, then the call is equivalent
to <b>pmemobj_alloc(</b><i>pop</i><b>,</b>
<i>size</i><b>,</b> <i>type_num</i><b>).</b> If <i>size</i>
is equal to zero, and <i>oidp</i> is not <i>OID_NULL</i>,
then the call is equivalent to
<b>pmemobj_free(</b><i>oid</i><b>).</b> Unless <i>oidp</i>
is <i>OID_NULL</i>, it must have been returned by an earlier
call to <b>pmemobj_alloc</b>(), <b>pmemobj_zalloc</b>(),
<b>pmemobj_realloc</b>(), or <b>pmemobj_zrealloc</b>(). Note
that the object handle value may change in result of
reallocation. If the object was moved, a memory space
represented by <i>oid</i> is reclaimed. If <i>oidp</i>
points to memory location from the <b>pmemobj</b> heap the
<i>oidp</i> is changed atomically. If
<b>pmemobj_realloc</b>() is unable to satisfy the allocation
request, a non-zero value is returned and errno is set
appropriately.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_zrealloc(PMEMobjpool *</b><i>pop</i><b>, PMEMoid
*</b><i>oidp</i><b>, size_t</b> <i>size</i><b>, <br>
uint64_t</b> <i>type_num</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_zrealloc</b>() function provide similar semantics
to <b>realloc</b>(3), but operates on the persistent memory
heap associated with memory pool <i>pop</i>. It changes the
size of the object represented by <i>oid</i>, to <i>size</i>
bytes. The resized object is also added or moved to the
internal container associated with given <i>type_num</i>.
The contents will be unchanged in the range from the start
of the region up to the minimum of the old and new sizes. If
the new size is larger than the old size, the added memory
will be zeroed. If <i>oidp</i> is NULL or if it points to
the root object&rsquo;s OID, behavior of the function is
undefined. If it points to <i>OID_NULL</i>, then the call is
equivalent to <b>pmemobj_zalloc(</b><i>pop</i><b>,</b>
<i>size</i><b>,</b> <i>type_num</i><b>).</b> If <i>size</i>
is equal to zero, and <i>oidp</i> doesn&rsquo;t point to
<i>OID_NULL</i>, then the call is equivalent to
<b>pmemobj_free(</b><i>pop</i><b>,</b> <i>oid</i><b>).</b>
Unless <i>oidp</i> points to <i>OID_NULL</i>, it must have
been returned by an earlier call to <b>pmemobj_alloc</b>(),
<b>pmemobj_zalloc</b>(), <b>pmemobj_realloc</b>(), or
<b>pmemobj_zrealloc</b>(). Note that the object handle value
may change in result of reallocation. If the object was
moved, a memory space represented by <i>oidp</i> is
reclaimed. If <i>oidp</i> points to memory location from the
<b>pmemobj</b> heap the <i>oidp</i> is changed atomically.
If <b>pmemobj_zrealloc</b>() is unable to satisfy the
allocation request, OID_NULL is returned and errno is set
appropriately.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_strdup(PMEMobjpool *</b><i>pop</i><b>, PMEMoid
*</b><i>oidp</i><b>, const char *</b><i>s</i><b>, <br>
uint64_t</b> <i>type_num</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_strdup</b>() function provides the same semantics
as <b>strdup</b>(3), but operates on the persistent memory
heap associated with memory pool <i>pop</i>. It stores a
handle to a new object in <i>oidp</i> which is a duplicate
of the string <i>s</i>. If NULL is passed as <i>oidp</i>,
then the newly allocated object may be accessed only by
iterating objects in the object container associated with
given <i>type_num</i>, as described in <b>OBJECT
CONTAINERS</b> section. If the <i>oidp</i> points to memory
location from the <b>pmemobj</b> heap the <i>oidp</i> is
changed atomically. The allocated string object is also
added to the internal container associated with given
<i>type_num</i>. Memory for the new string is obtained with
<b>pmemobj_alloc</b>(), on the given memory pool, and can be
freed with <b>pmemobj_free</b>() on the same memory pool. If
<b>pmemobj_strdup</b>() is unable to satisfy the allocation
request, OID_NULL is returned and errno is set
appropriately.</p>

<p style="margin-left:11%; margin-top: 1em"><b>size_t
pmemobj_alloc_usable_size(PMEMoid</b>
<i>oid</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_alloc_usable_size</b>() function provides the
same semantics as <b>malloc_usable_size</b>(3), but instead
of the process heap supplied by the system, it operates on
the persistent memory heap. It returns the number of usable
bytes in the object represented by <i>oid</i>, a handle to
an object allocated by <b>pmemobj_alloc</b>() or a related
function. If <i>oid</i> is OID_NULL, 0 is returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_NEW(PMEMobjpool
*</b><i>pop</i><b>, TOID *</b><i>oidp</i><b>,</b>
<i>TYPE</i><b>, <br>
pmemobj_constr</b> <i>constructor</i> <b>, void
*</b><i>arg</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>POBJ_NEW</b> macro is a wrapper around the
<b>pmemobj_alloc</b>() function which takes the type name
<b>TYPE</b> and passes the size and type number to the
<b>pmemobj_alloc</b>() function from the typed OID. Instead
of taking a pointer to <b>PMEMoid</b> it takes a pointer to
typed OID of <b>TYPE</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_ALLOC(PMEMobjpool
*</b><i>pop</i><b>, TOID *</b><i>oidp</i><b>,</b>
<i>TYPE</i><b>, size_t</b> <i>size</i><b>, <br>
pmemobj_constr</b> <i>constructor</i> <b>, void
*</b><i>arg</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>POBJ_ALLOC</b> macro is a wrapper around the
<b>pmemobj_alloc</b>() function which takes the type name
<b>TYPE</b>, the size of allocation <i>size</i> and passes
the type number to the <b>pmemobj_alloc</b>() function from
the typed OID. Instead of taking a pointer to <b>PMEMoid</b>
it takes a pointer to typed OID of <b>TYPE</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_ZNEW(PMEMobjpool
*</b><i>pop</i><b>, TOID *</b><i>oidp</i><b>,</b>
<i>TYPE</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>POBJ_ZNEW</b> macro is a wrapper around the
<b>pmemobj_zalloc</b>() function which takes the type name
<b>TYPE</b> and passes the size and type number to the
<b>pmemobj_zalloc</b>() function from the typed OID. Instead
of taking a pointer to <b>PMEMoid</b> it takes a pointer to
typed OID of <b>TYPE</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_ZALLOC(PMEMobjpool
*</b><i>pop</i><b>, TOID *</b><i>oidp</i><b>,</b>
<i>TYPE</i><b>, size_t</b> <i>size</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>POBJ_ZALLOC</b> macro is a wrapper around the
<b>pmemobj_zalloc</b>() function which takes the type name
<b>TYPE</b>, the size of allocation <i>size</i> and passes
the type number to the <b>pmemobj_zalloc</b>() function from
the typed OID. Instead of taking a pointer to <b>PMEMoid</b>
it takes a pointer to typed OID of <b>TYPE</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_REALLOC(PMEMobjpool
*</b><i>pop</i><b>, TOID *</b><i>oidp</i><b>,</b>
<i>TYPE</i><b>, size_t</b> <i>size</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>POBJ_REALLOC</b> macro is a wrapper around the
<b>pmemobj_realloc</b>() function which takes the type name
<b>TYPE</b> and passes the type number to the
<b>pmemobj_realloc</b>() function from the typed OID.
Instead of taking a pointer to <b>PMEMoid</b> it takes a
pointer to typed OID of <b>TYPE</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_ZREALLOC(PMEMobjpool
*</b><i>pop</i><b>, TOID *</b><i>oidp</i><b>,</b>
<i>TYPE</i><b>, size_t</b> <i>size</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>POBJ_ZREALLOC</b> macro is a wrapper around the
<b>pmemobj_zrealloc</b>() function which takes the type name
<b>TYPE</b> and passes the type number to the
<b>pmemobj_zrealloc</b>() function from the typed OID.
Instead of taking a pointer to <b>PMEMoid</b> it takes a
pointer to typed OID of <b>TYPE</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_FREE(TOID
*</b><i>oidp</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>POBJ_FREE</b> macro is a wrapper around the
<b>pmemobj_free</b>() function which takes pointer to typed
OID <i>oidp</i> as an argument instead of
<b>PMEMoid</b>.</p>

<h2>NON-TRANSACTIONAL PERSISTENT ATOMIC LISTS
<a name="NON-TRANSACTIONAL PERSISTENT ATOMIC LISTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Besides the
internal objects collections described in section <b>OBJECT
CONTAINERS</b> the <b>libpmemobj</b> provides a mechanism to
organize persistent objects in the user-defined persistent
atomic circular doubly linked lists. All the routines and
macros operating on the persistent lists provide atomicity
with respect to any power-fail interruptions. If any of
those operations is torn by program failure or system crash;
on recovery they are guaranteed to be entirely completed or
discarded, leaving the lists, persistent memory heap and
internal object containers in a consistent state.</p>

<p style="margin-left:11%; margin-top: 1em">The persistent
atomic circular doubly linked lists support the following
functionality:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="5%"></td>
<td width="83%">


<p>Insertion of an object at the head of the list, or at
the end of the list.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="5%"></td>
<td width="83%">


<p>Insertion of an object before or after any element in
the list.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="5%"></td>
<td width="83%">


<p>Atomic allocation and insertion of a new object at the
head of the list, or at the end of the list.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="5%"></td>
<td width="83%">


<p>Atomic allocation and insertion of a new object before
or after any element in the list.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="5%"></td>
<td width="83%">


<p>Atomic moving of an element from one list to the
specific location on another list.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="5%"></td>
<td width="83%">


<p>Removal of any object in the list.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="5%"></td>
<td width="83%">


<p>Atomic removal and freeing of any object in the
list.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="5%"></td>
<td width="83%">


<p>Forward or backward traversal through the list.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">A list is
headed by a <i>list_head</i> structure containing a single
object handle of the first element on the list. The elements
are doubly linked so that an arbitrary element can be
removed without a need to traverse the list. New elements
can be added to the list before or after an existing
element, at the head of the list, or at the end of the list.
A list may be traversed in either direction.</p>

<p style="margin-left:11%; margin-top: 1em">The
user-defined structure of each element must contain a field
of type <b>list_entry</b> holding the object handles to the
previous and next element on the list. Both the
<b>list_head</b> and the <b>list_entry</b> structures are
declared in <b>&lt;libpmemobj.h&gt;</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The functions
below are intended to be used outside transactions -
transactional variants are described in section
<b>TRANSACTIONAL OBJECT MANIPULATION</b>. Note that
operations performed using this non-transactional API are
independent from their transactional counterparts. If any
non-transactional allocations or list manipulations are
performed within an open transaction, the changes will not
be rolled-back if such a transaction is aborted or
interrupted.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_list_insert(PMEMobjpool *</b><i>pop</i><b>,
size_t</b> <i>pe_offset</i><b>, <br>
void *</b><i>head</i><b>, PMEMoid</b> <i>dest</i><b>,
int</b> <i>before</i><b>, PMEMoid</b>
<i>oid</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_list_insert</b> function inserts an element
represented by object handle <i>oid</i> into the list
referenced by <i>head</i>. Depending on the value of flag
<i>before</i>, the object is added before or after the
element <i>dest</i>. If <i>dest</i> value is OID_NULL, the
object is inserted at the head or at the end of the list,
depending on the <i>before</i> flag value. If value is 1 the
object is inserted at the head, if value is 0 the object is
inserted at the end of the list. The relevant values are
available through <b>POBJ_LIST_DEST_HEAD</b> and
<b>POBJ_LIST_DEST_TAIL</b> defines respectively. The
argument <i>pe_offset</i> declares an offset of the
structure that connects the elements in the list. All the
handles <i>head</i>, <i>dest</i> and <i>oid</i> must point
to the objects allocated from the same memory pool
<i>pop</i>. The <i>head</i> and <i>oid</i> cannot be
OID_NULL. On success, zero is returned. On error, -1 is
returned and errno is set.</p>

<p style="margin-left:11%; margin-top: 1em"><b>PMEMoid
pmemobj_list_insert_new(PMEMobjpool *</b><i>pop</i><b>,
size_t</b> <i>pe_offset</i><b>, <br>
void *</b><i>head</i><b>, PMEMoid</b> <i>dest</i><b>,
int</b> <i>before</i><b>, size_t</b> <i>size</i><b>, <br>
uint64_t</b> <i>type_num</i><b>, pmemobj_constr</b>
<i>constructor</i><b>, void *</b><i>arg</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_list_insert_new</b> function atomically allocates
a new object of given <i>size</i> and type <i>type_num</i>
and inserts it into the list referenced by <i>head</i>.
Depending on the value of <i>before</i> flag, the newly
allocated object is added before or after the element
<i>dest</i>. If <i>dest</i> value is OID_NULL, the object is
inserted at the head or at the end of the list, depending on
the <i>before</i> flag value. If value is 1 the object is
inserted at the head, if value is 0 the object is inserted
at the end of the list. The relevant values are available
through <b>POBJ_LIST_DEST_HEAD</b> and
<b>POBJ_LIST_DEST_TAIL</b> defines respectively. The
argument <i>pe_offset</i> declares an offset of the
structure that connects the elements in the list. All the
handles <i>head</i>, <i>dest</i> must point to the objects
allocated from the same memory pool <i>pop</i>. Before
returning, it calls the <b>constructor</b> function passing
the pool handle <i>pop</i>, the pointer to the newly
allocated object in <i>ptr</i> along with the <i>arg</i>
argument. It is guaranteed that allocated object is either
properly initialized or, if the allocation is interrupted
before the constructor completes, the memory space reserved
for the object is reclaimed. If the constructor returns
non-zero value the allocation is canceled, the -1 value is
returned from the caller and errno is set to <b>ECANCELED
.</b> The <i>head</i> cannot be OID_NULL. The allocated
object is also added to the internal container associated
with given <i>type_num</i>. as described in section
<b>OBJECT CONTAINERS</b>. On success, it returns a handle to
the newly allocated object. On error, OID_NULL is returned
and errno is set.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_list_remove(PMEMobjpool *</b><i>pop</i><b>,
size_t</b> <i>pe_offset</i><b>, <br>
void *</b><i>head</i><b>, PMEMoid</b> <i>oid</i><b>, int</b>
<i>free</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_list_remove</b> function removes the object
referenced by <i>oid</i> from the list pointed by
<i>head</i>. If <i>free</i> flag is set, it also removes the
object from the internal object container and frees the
associated memory space. The argument <i>pe_offset</i>
declares an offset of the structure that connects the
elements in the list. Both <i>head</i> and <i>oid</i> must
point to the objects allocated from the same memory pool
<i>pop</i> and cannot be OID_NULL. On success, zero is
returned. On error, -1 is returned and errno is set.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_list_move(PMEMobjpool *</b><i>pop</i><b>, <br>
size_t</b> <i>pe_old_offset</i><b>, void
*</b><i>head_old</i><b>, <br>
size_t</b> <i>pe_new_offset</i><b>, void
*</b><i>head_new</i><b>, <br>
PMEMoid</b> <i>dest</i><b>, int</b> <i>before</i><b>,
PMEMoid</b> <i>oid</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_list_move</b> function moves the object
represented by <i>oid</i> from the list pointed by
<i>head_old</i> to the list pointed by <i>head_new</i>.
Depending on the value of flag <i>before</i>, the newly
allocated object is added before or after the element
<i>dest</i>. If <i>dest</i> value is OID_NULL, the object is
inserted at the head or at the end of the second list,
depending on the <i>before</i> flag value. If value is 1 the
object is inserted at the head, if value is 0 the object is
inserted at the end of the list. The relevant values are
available through <b>POBJ_LIST_DEST_HEAD</b> and
<b>POBJ_LIST_DEST_TAIL</b> defines respectively. The
arguments <i>pe_old_offset</i> and <i>pe_new_offset</i>
declare the offsets of the structures that connects the
elements in the old and new lists respectively. All the
handles <i>head_old</i>, <i>head_new</i>, <i>dest</i> and
<i>oid</i> must point to the objects allocated from the same
memory pool <i>pop</i>. <i>head_old</i>, <i>head_new</i> and
<i>oid</i> cannot be OID_NULL. On success, zero is returned.
On error, -1 is returned and errno is set.</p>

<h2>TYPE-SAFE NON-TRANSACTIONAL PERSISTENT ATOMIC LISTS
<a name="TYPE-SAFE NON-TRANSACTIONAL PERSISTENT ATOMIC LISTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
macros define and operate on a type-safe persistent atomic
circular doubly linked list data structure that consist of a
set of persistent objects of a well-known type. Unlike the
functions described in the previous section, these macros
provide type enforcement by requiring declaration of type of
the objects stored in given list, and not allowing mixing
objects of different types in a single list.</p>

<p style="margin-left:11%; margin-top: 1em">The
functionality and semantics of those macros is similar to
circular queues defined in <b>queue</b>(3).</p>

<p style="margin-left:11%; margin-top: 1em">The majority of
the macros must specify the handle to the memory pool
<i>pop</i> and the name of the <i>field</i> in the
user-defined structure, which must be of type
<i>POBJ_LIST_ENTRY</i> and is used to connect the elements
in the list.</p>

<p style="margin-left:11%; margin-top: 1em">A list is
headed by a structure defined by the <i>POBJ_LIST_HEAD</i>
macro. This structure contains an object handle of the first
element on the list. The elements are doubly linked so that
an arbitrary element can be removed without a need to
traverse the list. New elements can be added to the list
before or after an existing element, at the head of the
list, or at the end of the list. A list may be traversed in
either direction. A <b>POBJ_LIST_HEAD</b> structure is
declared as follows:</p>

<p style="margin-left:22%; margin-top: 1em">#define
POBJ_LIST_HEAD(HEADNAME, TYPE) <br>
struct HEADNAME { <br>
TOID(TYPE) pe_first; <br>
PMEMmutex lock; <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">In the macro
definitions, <i>TYPE</i> is the name of a user-defined
structure, that must contain a field of type
<i>POBJ_LIST_ENTRY</i>. The argument <i>HEADNAME</i> is the
name of a user-defined structure that must be declared using
the macro <i>POBJ_LIST_HEAD</i>. See the examples below for
further explanation of how these macros are used.</p>

<p style="margin-left:11%; margin-top: 1em">The macro
<b>POBJ_LIST_ENTRY</b> declares a structure that connects
the elements in the list.</p>

<p style="margin-left:22%; margin-top: 1em">#define
POBJ_LIST_ENTRY(TYPE) <br>
struct { <br>
TOID(TYPE) pe_next; <br>
TOID(TYPE) pe_prev; <br>
};</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_FIRST(POBJ_LIST_HEAD
*</b><i>head</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macro
<b>POBJ_LIST_FIRST</b> returns the first element on the list
referenced by <i>head</i>. If the list is empty OID_NULL is
returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_LAST(POBJ_LIST_HEAD
*</b><i>head</i><b>, POBJ_LIST_ENTRY</b>
<i>FIELD</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macro
<b>POBJ_LIST_LAST</b> returns the last element on the list
referenced by <i>head</i>. If the list is empty OID_NULL is
returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_EMPTY(POBJ_LIST_HEAD
*</b><i>head</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macro
<b>POBJ_LIST_EMPTY</b> evaluates to 1 if the list referenced
by <i>head</i> is empty. Otherwise, 0 is returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_NEXT(TOID</b>
<i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macro
<b>POBJ_LIST_NEXT</b> returns the element next to the
element <i>elm</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_PREV(TOID</b>
<i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macro
<b>POBJ_LIST_PREV</b> returns the element preceding the
element <i>elm</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_FOREACH(TOID</b>
<i>var</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macro
<b>POBJ_LIST_FOREACH</b> traverses the list referenced by
<i>head</i> assigning a handle to each element in turn to
<i>var</i> variable.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_FOREACH_REVERSE(TOID</b>
<i>var</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macro
<b>POBJ_LIST_FOREACH_REVERSE</b> traverses the list
referenced by <i>head</i> in reverse order, assigning a
handle to each element in turn to <i>var</i> variable. The
<i>field</i> argument is the name of the field of type
<i>POBJ_LIST_ENTRY</i> in the element structure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_INSERT_HEAD(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b>
<i>FIELD</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macro
<b>POBJ_LIST_INSERT_HEAD</b> inserts the element <i>elm</i>
at the head of the list referenced by <i>head</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_INSERT_TAIL(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b>
<i>FIELD</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macro
<b>POBJ_LIST_INSERT_TAIL</b> inserts the element <i>elm</i>
at the end of the list referenced by <i>head</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_INSERT_AFTER(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
TOID</b> <i>listelm</i><b>, TOID</b> <i>elm</i><b>,
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macro
<b>POBJ_LIST_INSERT_AFTER</b> inserts the element <i>elm</i>
into the list referenced by <i>head</i> after the element
<i>listelm</i>. If <i>listelm</i> value is TOID_NULL, the
object is inserted at the end of the list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_INSERT_BEFORE(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
TOID</b> <i>listelm</i><b>, TOID</b> <i>elm</i><b>,
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macro
<b>POBJ_LIST_INSERT_BEFORE</b> inserts the element
<i>elm</i> into the list referenced by <i>head</i> before
the element <i>listelm</i>. If <i>listelm</i> value is
TOID_NULL, the object is inserted at the head of the
list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_INSERT_NEW_HEAD(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, size_t</b>
<i>size</i><b>, <br>
pmemobj_constr</b> <i>constructor</i> <b>, void
*</b><i>arg</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macro
<b>POBJ_LIST_INSERT_NEW_HEAD</b> atomically allocates a new
object of size <i>size</i> and inserts it at the head of the
list referenced by <i>head</i>. The newly allocated object
is also added to the internal object container associated
with a type number which is retrieved from the typed OID of
the first element on list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_INSERT_NEW_TAIL(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, size_t</b>
<i>size</i><b>, <br>
pmemobj_constr</b> <i>constructor</i> <b>, void
*</b><i>arg</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macro
<b>POBJ_LIST_INSERT_NEW_TAIL</b> atomically allocates a new
object of size <i>size</i> and inserts it at the tail of the
list referenced by <i>head</i>. The newly allocated object
is also added to the internal object container associated
with with a type number which is retrieved from the typed
OID of the first element on list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_INSERT_NEW_AFTER(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
TOID</b> <i>listelm</i><b>, POBJ_LIST_ENTRY</b>
<i>FIELD</i><b>, size_t</b> <i>size</i><b>, <br>
pmemobj_constr</b> <i>constructor</i> <b>, void
*</b><i>arg</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macro
<b>POBJ_LIST_INSERT_NEW_AFTER</b> atomically allocates a new
object of size <i>size</i> and inserts it into the list
referenced by <i>head</i> after the element <i>listelm</i>.
If <i>listelm</i> value is TOID_NULL, the object is inserted
at the end of the list. The newly allocated object is also
added to the internal object container associated with with
a type number which is retrieved from the typed OID of the
first element on list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_INSERT_NEW_BEFORE(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
TOID</b> <i>listelm</i><b>, POBJ_LIST_ENTRY</b>
<i>FIELD</i><b>, size_t</b> <i>size</i><b>, <br>
pmemobj_constr</b> <i>constructor</i> <b>, void
*</b><i>arg</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macro
<b>POBJ_LIST_INSERT_NEW_BEFORE</b> atomically allocates a
new object of size <i>size</i> and inserts it into the list
referenced by <i>head</i> before the element <i>listelm</i>.
If <i>listelm</i> value is TOID_NULL, the object is inserted
at the head of the list. The newly allocated object is also
added to the internal object container associated with with
a type number which is retrieved from the typed OID of the
first element on list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_REMOVE(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b>
<i>FIELD</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macro
<b>POBJ_LIST_REMOVE</b> removes the element <i>elm</i> from
the list referenced by <i>head</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_REMOVE_FREE(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
TOID</b> <i>elm</i><b>, POBJ_LIST_ENTRY</b>
<i>FIELD</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macro
<b>POBJ_LIST_REMOVE_FREE</b> removes the element <i>elm</i>
from the list referenced by <i>head</i> and frees the memory
space represented by this element.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_MOVE_ELEMENT_HEAD(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
POBJ_LIST_HEAD *</b><i>head_new</i><b>, TOID</b>
<i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, <br>
POBJ_LIST_ENTRY</b> <i>field_new</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macro
<b>POBJ_LIST_MOVE_ELEMENT_HEAD</b> moves the element
<i>elm</i> from the list referenced by <i>head</i> to the
head of the list <i>head_new</i>. The <i>field</i> and
<i>field_new</i> arguments are the names of the fields of
type <i>POBJ_LIST_ENTRY</i> in the element structure that
are used to connect the elements in both lists.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_MOVE_ELEMENT_TAIL(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
POBJ_LIST_HEAD *</b><i>head_new</i><b>, TOID</b>
<i>elm</i><b>, POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, <br>
POBJ_LIST_ENTRY</b> <i>field_new</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macro
<b>POBJ_LIST_MOVE_ELEMENT_TAIL</b> moves the element
<i>elm</i> from the list referenced by <i>head</i> to the
end of the list <i>head_new</i>. The <i>field</i> and
<i>field_new</i> arguments are the names of the fields of
type <i>POBJ_LIST_ENTRY</i> in the element structure that
are used to connect the elements in both lists.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_MOVE_ELEMENT_AFTER(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
POBJ_LIST_HEAD *</b><i>head_new</i><b>, TOID</b>
<i>listelm</i><b>, TOID</b> <i>elm</i><b>, <br>
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, POBJ_LIST_ENTRY</b>
<i>field_new</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macro
<b>POBJ_LIST_MOVE_ELEMENT_AFTER</b> atomically removes the
element <i>elm</i> from the list referenced by <i>head</i>
and inserts it into the list referenced by <i>head_new</i>
after the element <i>listelm</i>. If <i>listelm</i> value is
TOID_NULL, the object is inserted at the end of the list.
The <i>field</i> and <i>field_new</i> arguments are the
names of the fields of type <i>POBJ_LIST_ENTRY</i> in the
element structure that are used to connect the elements in
both lists.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POBJ_LIST_MOVE_ELEMENT_BEFORE(PMEMobjpool
*</b><i>pop</i><b>, POBJ_LIST_HEAD *</b><i>head</i><b>, <br>
POBJ_LIST_HEAD *</b><i>head_new</i><b>, TOID</b>
<i>listelm</i><b>, TOID</b> <i>elm</i><b>, <br>
POBJ_LIST_ENTRY</b> <i>FIELD</i><b>, POBJ_LIST_ENTRY</b>
<i>field_new</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The macro
<b>POBJ_LIST_MOVE_ELEMENT_BEFORE</b> atomically removes the
element <i>elm</i> from the list referenced by <i>head</i>
and inserts it into the list referenced by <i>head_new</i>
before the element <i>listelm</i>. If <i>listelm</i> value
is TOID_NULL, the object is inserted at the head of the
list. The <i>field</i> and <i>field_new</i> arguments are
the names of the fields of type <i>POBJ_LIST_ENTRY</i> in
the element structure that are used to connect the elements
in both lists.</p>

<h2>TRANSACTIONAL OBJECT MANIPULATION
<a name="TRANSACTIONAL OBJECT MANIPULATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The functions
described in sections <b>NON-TRANSACTIONAL ATOMIC
ALLOCATIONS</b> and <b>NON-TRANSACTIONAL PERSISTENT ATOMIC
LISTS</b> only guarantee the atomicity in scope of a single
operation on an object. In case of more complex changes,
involving multiple operations on an object, or allocation
and modification of multiple objects; data consistency and
fail-safety may be provided only by using <i>atomic
transactions</i>.</p>

<p style="margin-left:11%; margin-top: 1em">A transaction
is defined as series of operations on persistent memory
objects that either all occur, or nothing occurs. In
particular, if the execution of a transaction is interrupted
by a power failure or a system crash, it is guaranteed that
after system restart, all the changes made as a part of the
uncompleted transaction will be rolled-back, restoring the
consistent state of the memory pool from the moment when the
transaction was started.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
transactions do not provide the atomicity with respect to
other threads. All the modifications performed within the
transactions are immediately visible to other threads, and
this is the responsibility of the program to implement a
proper thread synchronization mechanism.</p>

<p style="margin-left:11%; margin-top: 1em">Each
transaction is visible only for the thread that started it.
No other threads can add operations, commit or abort the
transaction initiated by another thread. There may be
multiple open transactions on given memory pool at the same
time, but only one transaction per thread.</p>

<p style="margin-left:11%; margin-top: 1em">Nested
transactions are supported but flattened. Committing the
nested transaction does not commit the outer transaction,
however errors in the nested transaction are propagated up
to the outer-most level, resulting in the interruption of
the entire transaction.</p>

<p style="margin-left:11%; margin-top: 1em">Please see the
<b>CAVEATS</b> section for known limitations of the
transactional API.</p>

<p style="margin-left:11%; margin-top: 1em"><b>enum
tx_stage pmemobj_tx_stage(void);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_tx_stage</b>() function returns the stage of the
current transaction stage for a thread. Stages are changed
only by the <i>pmemobj_tx_*</i> functions. The transaction
stages are defined as follows:</p>


<p style="margin-left:22%; margin-top: 1em"><b>TX_STAGE_NONE</b>
- no open transaction in this thread</p>


<p style="margin-left:22%; margin-top: 1em"><b>TX_STAGE_WORK</b>
- transaction in progress</p>


<p style="margin-left:22%; margin-top: 1em"><b>TX_STAGE_ONCOMMIT</b>
- successfully committed</p>


<p style="margin-left:22%; margin-top: 1em"><b>TX_STAGE_ONABORT</b>
- starting the transaction failed or transaction aborted</p>


<p style="margin-left:22%; margin-top: 1em"><b>TX_STAGE_FINALLY</b>
- ready for clean up</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_tx_begin(PMEMobjpool *</b><i>pop</i><b>, jmp_buf
*</b><i>env</i><b>,</b> <i>...</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_tx_begin</b>() function starts a new transaction
in the current thread. If called within an open transaction,
it starts a nested transaction. The caller may use
<i>env</i> argument to provide a pointer to the information
of a calling environment to be restored in case of
transaction abort. This information must be filled by a
caller, using <b>setjmp</b>(3) macro.</p>

<p style="margin-left:22%; margin-top: 1em">Optionally, a
list of pmem-resident locks may be provided as the last
arguments. Each lock is specified by a pair of lock type (
<i>TX_LOCK_MUTEX</i> or <i>TX_LOCK_RWLOCK</i>) and the
pointer to the lock of type <i>PMEMmutex</i> or
<i>PMEMrwlock</i> respectively. The list must be terminated
with <i>TX_LOCK_NONE</i>. In case of rwlocks, a write lock
is acquired. It is guaranteed that <b>pmemobj_tx_begin</b>()
will grab all the locks prior to successful completion and
they will be held by the current thread until the
transaction is finished. Locks are taken in the order from
left to right. To avoid deadlocks, user must take care about
the proper order of locks.</p>

<p style="margin-left:22%; margin-top: 1em">New transaction
may be started only if the current stage is
<i>TX_STAGE_NONE</i> or <i>TX_STAGE_WORK</i>. If successful,
transaction stage changes to <i>TX_STAGE_WORK</i> and
function returns zero. Otherwise, stage changes to
<i>TX_STAGE_ONABORT</i> and an error number is returned.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_tx_lock(enum tx_lock</b> <i>lock_type</i><b>, void
*</b><i>lockp</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_tx_lock</b>() function grabs a lock pointed by
<i>lockp</i> and adds it to the current transaction. The
lock type is specified by <i>lock_type</i> (
<i>TX_LOCK_MUTEX</i> or <i>TX_LOCK_RWLOCK</i> ) and the
pointer to the <i>lockp</i> of <i>PMEMmutex</i> or
<i>PMEMrwlock</i> type. If successful, <i>lockp</i> is added
to transaction, locked and function returns zero. Otherwise,
stage changes to <i>TX_STAGE_ONABORT</i> and an error number
is returned. In case of <i>PMEMrwlock lock_type</i> function
acquires a write lock. This function must be called during
<i>TX_STAGE_WORK</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pmemobj_tx_abort(int</b> <i>errnum</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_tx_abort</b>() aborts the current transaction and
causes transition to <i>TX_STAGE_ONABORT</i>. This function
must be called during <i>TX_STAGE_WORK</i>. If the passed
<i>errnum</i> is equal to zero, it shall be set to
<i>ECANCELED</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pmemobj_tx_commit(void);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_tx_commit</b>() function commits the current open
transaction and causes transition to
<i>TX_STAGE_ONCOMMIT</i> stage. If called in context of the
outer-most transaction, all the changes may be considered as
durably written upon successful completion. This function
must be called during <i>TX_STAGE_WORK</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_tx_end(void);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_tx_end</b>() function performs a clean up of a
current transaction. If called in context of the outer-most
transaction, it releases all the locks acquired by
<b>pmemobj_tx_begin</b>() for outer and nested transactions.
Then it causes the transition to <i>TX_STAGE_NONE</i>. In
case of the nested transaction, it returns to the context of
the outer transaction with <i>TX_STAGE_WORK</i> stage
without releasing any locks. Must always be called for each
<b>pmemobj_tx_begin</b>(), even if starting the transaction
failed. This function must <i>not</i> be called during
<i>TX_STAGE_WORK</i>. If transaction was successful, returns
0. Otherwise returns error code set by
<b>pmemobj_tx_abort</b>(). Note that
<b>pmemobj_tx_abort</b>() can be called internally by the
library.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_tx_errno(void);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_tx_errno</b>() function returns the error code of
the last transaction.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pmemobj_tx_process(void);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_tx_process</b>() function performs the actions
associated with current stage of the transaction, and makes
the transition to the next stage. It must be called in
transaction. Current stage must always be obtained by a call
to <b>pmemobj_tx_stage</b>().</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_tx_add_range(PMEMoid</b> <i>oid</i><b>, uint64_t</b>
<i>off</i><b>, size_t</b> <i>size</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_tx_add_range</b>() takes a &quot;snapshot&quot;
of the memory block of given <i>size</i>, located at given
offset <i>off</i> in the object specified by <i>oid</i> and
saves it to the undo log. The application is then free to
directly modify the object in that memory range. In case of
a failure or abort, all the changes within this range will
be rolled-back. The supplied block of memory has to be
within the pool registered in the transaction. If
successful, returns zero. Otherwise, state changes to
<i>TX_STAGE_ONABORT</i> and an error number is returned.
This function must be called during
<i>TX_STAGE_WORK</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_tx_add_range_direct(const void *</b><i>ptr</i><b>,
size_t</b> <i>size</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_tx_add_range_direct</b>() behaves the same as
<b>pmemobj_tx_add_range</b>() with the exception that it
operates on virtual memory addresses and not persistent
memory objects. It takes a &quot;snapshot&quot; of a
persistent memory block of given <i>size</i>, located at the
given address <i>ptr</i> in the virtual memory space and
saves it to the undo log. The application is then free to
directly modify the object in that memory range. In case of
a failure or abort, all the changes within this range will
be rolled-back. The supplied block of memory has to be
within the pool registered in the transaction. If
successful, returns zero. Otherwise, state changes to
<i>TX_STAGE_ONABORT</i> and an error number is returned.
This function must be called during
<i>TX_STAGE_WORK</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>PMEMoid
pmemobj_tx_alloc(size_t</b> <i>size</i><b>, uint64_t</b>
<i>type_num</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_tx_alloc</b>() transactionally allocates a new
object of given <i>size</i> and <i>type_num</i>. In contrast
to the non-transactional allocations, the objects are added
to the internal object containers of given <i>type_num</i>
only after the transaction is committed, making the objects
visible to the <b>POBJ_FOREACH_*</b> macros. If successful,
returns a handle to the newly allocated object. Otherwise,
stage changes to <i>TX_STAGE_ONABORT</i>, OID_NULL is
returned, and errno is set appropriately. If <i>size</i>
equals 0, OID_NULL is returned and errno is set
appropriately. This function must be called during
<i>TX_STAGE_WORK</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>PMEMoid
pmemobj_tx_zalloc(size_t</b> <i>size</i><b>, uint64_t</b>
<i>type_num</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
pmemobj_tx_zalloc () function transactionally allocates new
zeroed object of given <i>size</i> and <i>type_num</i>. If
successful, returns a handle to the newly allocated object.
Otherwise, stage changes to <i>TX_STAGE_ONABORT</i>,
OID_NULL is returned, and errno is set appropriately. If
<i>size</i> equals 0, OID_NULL is returned and errno is set
appropriately. This function must be called during
<i>TX_STAGE_WORK</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>PMEMoid
pmemobj_tx_realloc(PMEMoid</b> <i>oid</i><b>, size_t</b>
<i>size</i><b>, <br>
uint64_t</b> <i>type_num</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_tx_realloc</b>() function transactionally resizes
an existing object to the given <i>size</i> and changes its
type to <i>type_num</i>. If <i>oid</i> is OID_NULL, then the
call is equivalent to
<b>pmemobj_tx_alloc(</b><i>pop</i><b>,</b>
<i>size</i><b>,</b> <i>type_num</i><b>).</b> If <i>size</i>
is equal to zero and <i>oid</i> is not OID_NULL, then the
call is equivalent to
<b>pmemobj_tx_free(</b><i>oid</i><b>).</b> If the new size
is larger than the old size, the added memory will
<i>not</i> be initialized. If successful, returns returns a
handle to the resized object. Otherwise, stage changes to
<i>TX_STAGE_ONABORT</i>, OID_NULL is returned, and errno is
set appropriately. Note that the object handle value may
change in result of reallocation. This function must be
called during <i>TX_STAGE_WORK</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>PMEMoid
pmemobj_tx_zrealloc(PMEMoid</b> <i>oid</i><b>, size_t</b>
<i>size</i><b>, <br>
uint64_t</b> <i>type_num</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_tx_zrealloc</b>() function transactionally
resizes an existing object to the given <i>size</i> and
changes its type to <i>type_num</i>. If the new size is
larger than the old size, the extended new space is zeroed.
If successful, returns returns a handle to the resized
object. Otherwise, stage changes to <i>TX_STAGE_ONABORT</i>,
OID_NULL is returned, and errno is set appropriately. Note
that the object handle value may change in result of
reallocation. This function must be called during
<i>TX_STAGE_WORK</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>PMEMoid
pmemobj_tx_strdup(const char *</b><i>s</i><b>, uint64_t</b>
<i>type_num</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_tx_strdup</b>() function transactionally
allocates a new object containing a duplicate of the string
<i>s</i> and assigns it a type <i>type_num</i>. If
successful, returns a handle to the newly allocated object.
Otherwise, stage changes to <i>TX_STAGE_ONABORT</i>,
OID_NULL is returned, and errno is set appropriately. This
function must be called during <i>TX_STAGE_WORK</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_tx_free(PMEMoid</b> <i>oid</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_tx_free</b>() function transactionally frees an
existing object referenced by <i>oid</i>. If successful,
returns zero. Otherwise, stage changes to
<i>TX_STAGE_ONABORT</i> and an error number is returned.
This function must be called during
<i>TX_STAGE_WORK</i>.</p>

<p style="margin-left:11%; margin-top: 1em">In addition to
the above API, the <b>libpmemobj</b> offers a more intuitive
method of building transactions using a set of macros
described below. When using macros, the complete transaction
flow looks like this:</p>

<p style="margin-left:22%; margin-top: 1em">TX_BEGIN(Pop)
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>/* the actual transaction code goes here... */</p></td></tr>
</table>

<p style="margin-left:22%;">} TX_ONCOMMIT {</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>/*</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>* optional - executed only if the above block</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>* successfully completes</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>*/</p></td></tr>
</table>

<p style="margin-left:22%;">} TX_ONABORT {</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>/*</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>* optional - executed only if starting the transaction
fails,</p> </td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>* or if transaction is aborted by an error or a call
to</p> </td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>* pmemobj_tx_abort()</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>*/</p></td></tr>
</table>

<p style="margin-left:22%;">} TX_FINALLY {</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>/*</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>* optional - if exists, it is executed after</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>* TX_ONCOMMIT or TX_ONABORT block</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>*/</p></td></tr>
</table>

<p style="margin-left:22%;">} TX_END /* mandatory */</p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_BEGIN_LOCK(PMEMobjpool
*</b><i>pop</i><b>,</b> <i>...</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_BEGIN(PMEMobjpool
*</b><i>pop</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TX_BEGIN_LOCK</b>() and <b>TX_BEGIN</b>() macros start a
new transaction in the same way as
<b>pmemobj_tx_begin</b>(), except that instead of the
environment buffer provided by a caller, they set up the
local <i>jmp_buf</i> buffer and use it to catch the
transaction abort. The <b>TX_BEGIN</b>() macro may be used
in case when there is no need to grab any locks prior to
starting a transaction (like for a single-threaded program).
Each of those macros shall be followed by a block of code
with all the operations that are to be performed
atomically.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_ONABORT</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TX_ONABORT</b> macro starts a block of code that will be
executed only if starting the transaction fails due to an
error in <b>pmemobj_tx_begin</b>(), or if the transaction is
aborted. This block is optional, but in practice it should
not be omitted. If it&rsquo;s desirable to crash the
application when transaction aborts and there&rsquo;s no
<b>TX_ONABORT</b> section, application can define
<b>POBJ_TX_CRASH_ON_NO_ONABORT</b> macro before inclusion of
<b>&lt;libpmemobj.h&gt;</b>. It provides default
<b>TX_ONABORT</b> section which just calls
<b>abort</b>(3).</p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_ONCOMMIT</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TX_ONCOMMIT</b> macro starts a block of code that will be
executed only if the transaction is successfully committed,
which means that the execution of code in <b>TX_BEGIN</b>
block has not been interrupted by an error or by a call to
<b>pmemobj_tx_abort</b>(). This block is optional.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_FINALLY</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TX_FINALLY</b> macro starts a block of code that will be
executed regardless of whether the transaction is committed
or aborted. This block is optional.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_END</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TX_END</b> macro cleans up and closes the transaction
started by <b>TX_BEGIN</b>() or <b>TX_BEGIN_LOCK</b>()
macro. It is mandatory to terminate each transaction with
this macro. If the transaction was aborted, errno is set
appropriately.</p>

<p style="margin-left:11%; margin-top: 1em">Similarly to
the macros controlling the transaction flow, the
<b>libpmemobj</b> defines a set of macros that simplify the
transactional operations on persistent objects. Note that
those macros operate on typed object handles, thus
eliminating the need to specify the size of the object, or
the size and offset of the field in the user-defined
structure that is to be modified.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_ADD_FIELD(TOID</b>
<i>o</i><b>,</b> <i>FIELD</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TX_ADD_FIELD</b>() macro saves in the undo log the
current value of given <i>FIELD</i> of the object referenced
by a handle <i>o</i>. The application is then free to
directly modify the specified <i>FIELD</i>. In case of a
failure or abort, the saved value will be restored.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_ADD(TOID</b>
<i>o</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TX_ADD</b>() macro takes a &quot;snapshot&quot; of the
entire object referenced by object handle <i>o</i> and saves
it in the undo log. The object size is determined from its
<i>TYPE</i>. The application is then free to directly modify
the object. In case of a failure or abort, all the changes
within the object will be rolled-back.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_ADD_FIELD_DIRECT(TYPE
*</b><i>p</i><b>,</b> <i>FIELD</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TX_ADD_FIELD_DIRECT</b>() macro saves in the undo log the
current value of given <i>FIELD</i> of the object referenced
by (direct) pointer <i>p</i>. The application is then free
to directly modify the specified <i>FIELD</i>. In case of a
failure or abort, the saved value will be restored.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_ADD_DIRECT(TYPE
*</b><i>p</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TX_ADD_DIRECT</b>() macro takes a &quot;snapshot&quot; of
the entire object referenced by (direct) pointer <i>p</i>
and saves it in the undo log. The object size is determined
from its <i>TYPE</i>. The application is then free to
directly modify the object. In case of a failure or abort,
all the changes within the object will be rolled-back.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_SET(TOID</b>
<i>o</i><b>,</b> <i>FIELD</i><b>,</b>
<i>VALUE</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TX_SET</b> macro saves in the undo log the current value
of given <i>FIELD</i> of the object referenced by a handle
<i>o</i>, and then set its new <i>VALUE</i>. In case of a
failure or abort, the saved value will be restored.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_SET_DIRECT(TYPE
*</b><i>p</i><b>,</b> <i>FIELD</i><b>,</b>
<i>VALUE</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TX_SET_DIRECT</b> macro saves in the undo log the current
value of given <i>FIELD</i> of the object referenced by
(direct) pointer <i>p</i>, and then set its new
<i>VALUE</i>. In case of a failure or abort, the saved value
will be restored.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_MEMCPY(void
*</b><i>dest</i><b>, const void *</b><i>src</i><b>,
size_t</b> <i>num</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TX_MEMCPY</b> macro saves in the undo log the current
content of <i>dest</i> buffer and then overwrites the first
<i>num</i> bytes of its memory area with the data copied
from the buffer pointed by <i>src</i>. In case of a failure
or abort, the saved value will be restored.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_MEMSET(void
*</b><i>dest</i><b>, int</b> <i>c</i><b>, size_t</b>
<i>num</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TX_MEMSET</b> macro saves in the undo log the current
content of <i>dest</i> buffer and then fills the first
<i>num</i> bytes of its memory area with the constant byte
<i>c</i>. In case of a failure or abort, the saved value
will be restored.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_NEW(</b><i>TYPE</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TX_NEW</b>() macro transactionally allocates a new object
of given <i>TYPE</i> and assigns it a type number read from
the typed OID. The allocation size is determined from the
size of the user-defined structure <i>TYPE</i>. If
successful and called during <i>TX_STAGE_WORK</i> it returns
a handle to the newly allocated object. Otherwise, stage
changes to <i>TX_STAGE_ONABORT</i>, OID_NULL is returned,
and errno is set appropriately.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_ALLOC(</b><i>TYPE</i><b>,
size_t</b> <i>size</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TX_ALLOC</b>() macro transactionally allocates a new
object of given <i>TYPE</i> and assigns it a type number
read from the typed OID. The allocation size is passed by
<i>size</i> parameter. If successful and called during
<i>TX_STAGE_WORK</i> it returns a handle to the newly
allocated object. Otherwise, stage changes to
<i>TX_STAGE_ONABORT</i>, OID_NULL is returned, and errno is
set appropriately.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_ZNEW(</b><i>TYPE</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TX_ZNEW</b>() macro transactionally allocates a new
zeroed object of given <i>TYPE</i> and assigns it a type
number read from the typed OID. The allocation size is
determined from the size of the user-defined structure
<i>TYPE</i>. If successful and called during
<i>TX_STAGE_WORK</i> it returns a handle to the newly
allocated object. Otherwise, stage changes to
<i>TX_STAGE_ONABORT</i>, OID_NULL is returned, and errno is
set appropriately.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_ZALLOC(</b><i>TYPE</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TX_ZALLOC</b>() macro transactionally allocates a new
zeroed object of given <i>TYPE</i> and assigns it a type
number read from the typed OID. The allocation size is
passed by <i>size</i> argument. If successful and called
during <i>TX_STAGE_WORK</i> it returns a handle to the newly
allocated object. Otherwise, stage changes to
<i>TX_STAGE_ONABORT</i>, OID_NULL is returned, and errno is
set appropriately.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_REALLOC(TOID</b>
<i>o</i><b>, size_t</b> <i>size</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TX_REALLOC</b>() macro transactionally resizes an
existing object referenced by a handle <i>o</i> to the given
<i>size</i>. If successful and called during
<i>TX_STAGE_WORK</i> it returns a handle to the reallocated
object. Otherwise, stage changes to <i>TX_STAGE_ONABORT</i>,
OID_NULL is returned, and errno is set appropriately.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_ZREALLOC(TOID</b>
<i>o</i><b>, size_t</b> <i>size</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TX_ZREALLOC</b>() macro transactionally resizes an
existing object referenced by a handle <i>o</i> to the given
<i>size</i>. If the new size is larger than the old size,
the extended new space is zeroed. If successful and called
during <i>TX_STAGE_WORK</i> it returns a handle to the
reallocated object. Otherwise, stage changes to
<i>TX_STAGE_ONABORT</i>, OID_NULL is returned, and errno is
set appropriately.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_STRDUP(const
char *</b><i>s</i><b>, uint64_t</b>
<i>type_num</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TX_STRDUP</b>() macro transactionally allocates a new
object containing a duplicate of the string <i>s</i> and
assigns it a type <i>type_num</i>. If successful and called
during <i>TX_STAGE_WORK</i> it returns a handle to the newly
allocated object. Otherwise, stage changes to
<i>TX_STAGE_ONABORT</i>, OID_NULL is returned, and errno is
set appropriately.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TX_FREE(TOID</b>
<i>o</i><b>)</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>TX_FREE</b>() transactionally frees the memory space
represented by an object handle <i>o</i>. If <i>o</i> is
OID_NULL, no operation is performed. If successful and
called during <i>TX_STAGE_WORK</i> it returns zero.
Otherwise, stage changes to <i>TX_STAGE_ONABORT</i> and an
error number is returned.</p>

<h2>CAVEATS
<a name="CAVEATS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The transaction
flow control is governed by the
<b>setjmp</b>(3)/<b>longjmp</b>(3) macros and they are used
in both the macro and function flavors of the API. The
transaction will longjmp on transaction abort. This has one
major drawback which is described in the ISO C standard
subsection 7.13.2.1. It says that <b>the values of objects
of automatic storage duration that are local to the function
containing the setjmp invocation that do not have
volatile-qualified type and have been changed between the
setjmp invocation and longjmp call are
indeterminate.</b></p>

<p style="margin-left:11%; margin-top: 1em">The following
example illustrates the issue described above.</p>

<p style="margin-left:22%; margin-top: 1em">int
*bad_example_1 = NULL; <br>
int *bad_example_2 = NULL; <br>
int *bad_example_3 = NULL; <br>
volatile int *good_example = NULL;</p>

<p style="margin-left:22%; margin-top: 1em">TX_BEGIN(Pop) {
<br>
bad_example_1 = malloc(...); <br>
bad_example_2 = malloc(...); <br>
bad_example_3 = malloc(...); <br>
good_example = malloc(...); <br>
... <br>
pmemobj_tx_abort(EINVAL); /* manual or library abort called
here */ <br>
} TX_ONCOMMIT { <br>
/* <br>
* This section is longjmp-safe <br>
*/ <br>
} TX_ONABORT { <br>
/* <br>
* This section is not longjmp-safe <br>
*/</p>


<p style="margin-left:22%; margin-top: 1em">free(bad_example_1);
/* undefined behavior */ <br>
free(good_example); /* OK */ <br>
} TX_FINALLY { <br>
/* <br>
* This section is not longjmp-safe on transaction abort only
<br>
*/</p>


<p style="margin-left:22%; margin-top: 1em">free(bad_example_2);
/* undefined behavior */ <br>
} TX_END</p>


<p style="margin-left:22%; margin-top: 1em">free(bad_example_3);
/* undefined behavior */</p>

<p style="margin-left:11%; margin-top: 1em">Objects which
are not volatile-qualified, are of automatic storage
duration and have been changed between the invocations of
<b>setjmp</b>(3) and <b>longjmp</b>(3) (that also means
within the work section of the transaction after TX_BEGIN)
should not be used after a transaction abort or should be
used with utmost care. This also includes code after the
<b>TX_END</b> macro.</p>

<h2>LIBRARY API VERSIONING
<a name="LIBRARY API VERSIONING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section
describes how the library API is versioned, allowing
applications to work with an evolving API.</p>

<p style="margin-left:11%; margin-top: 1em"><b>const char
*pmemobj_check_version( <br>
unsigned</b> <i>major_required</i><b>, <br>
unsigned</b> <i>minor_required</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_check_version</b>() function is used to see if
the installed <b>libpmemobj</b> supports the version of the
library API required by an application. The easiest way to
do this is for the application to supply the compile-time
version information, supplied by defines in
<b>&lt;libpmemobj.h&gt;</b>, like this:</p>

<p style="margin-left:22%; margin-top: 1em">reason =
pmemobj_check_version(PMEMOBJ_MAJOR_VERSION, <br>
PMEMOBJ_MINOR_VERSION); <br>
if (reason != NULL) { <br>
/* version check failed, reason string tells you why */ <br>
}</p>

<p style="margin-left:22%; margin-top: 1em">Any mismatch in
the major version number is considered a failure, but a
library with a newer minor version number will pass this
check since increasing minor versions imply backwards
compatibility.</p>

<p style="margin-left:22%; margin-top: 1em">An application
can also check specifically for the existence of an
interface by checking for the version where that interface
was introduced. These versions are documented in this man
page as follows: unless otherwise specified, all interfaces
described here are available in version 1.0 of the library.
Interfaces added after version 1.0 will contain the text
<i>introduced in version x.y</i> in the section of this
manual describing the feature.</p>

<p style="margin-left:22%; margin-top: 1em">When the
version check performed by <b>pmemobj_check_version</b>() is
successful, the return value is NULL. Otherwise the return
value is a static string describing the reason for failing
the version check. The string returned by
<b>pmemobj_check_version</b>() must not be modified or
freed.</p>

<h2>MANAGING LIBRARY BEHAVIOR
<a name="MANAGING LIBRARY BEHAVIOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The library
entry points described in this section are less commonly
used than the previous sections.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pmemobj_set_funcs( <br>
void *(*</b><i>malloc_func</i><b>)(size_t</b>
<i>size</i><b>), <br>
void (*</b><i>free_func</i><b>)(void *</b><i>ptr</i><b>),
<br>
void *(*</b><i>realloc_func</i><b>)(void *</b><i>ptr</i><b>,
size_t</b> <i>size</i><b>), <br>
char *(*</b><i>strdup_func</i><b>)(const char
*</b><i>s</i><b>));</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_set_funcs</b>() function allows an application to
override memory allocation calls used internally by
<b>libpmemobj</b>. Passing in NULL for any of the handlers
will cause the <b>libpmemobj</b> default function to be
used. The library does not make heavy use of the system
malloc functions, but it does allocate approximately 4-8
kilobytes for each memory pool in use.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pmemobj_check(const char *</b><i>path</i><b>, const char
*</b><i>layout</i><b>);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_check</b>() function performs a consistency check
of the file indicated by <i>path</i> and returns 1 if the
memory pool is found to be consistent. Any inconsistencies
found will cause <b>pmemobj_check</b>() to return 0, in
which case the use of the file with <b>libpmemobj</b> will
result in undefined behavior. The debug version of
<b>libpmemobj</b> will provide additional details on
inconsistencies when <b>PMEMOBJ_LOG_LEVEL</b> is at least 1,
as described in the <b>DEBUGGING AND ERROR HANDLING</b>
section below. <b>pmemobj_check</b>() will return -1 and set
errno if it cannot perform the consistency check due to
other errors. <b>pmemobj_check</b>() opens the given
<i>path</i> read-only so it never makes any changes to the
file.</p>

<h2>DEBUGGING AND ERROR HANDLING
<a name="DEBUGGING AND ERROR HANDLING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Two versions of
<b>libpmemobj</b> are typically available on a development
system. The normal version, accessed when a program is
linked using the <b>-lpmemobj</b> option, is optimized for
performance. That version skips checks that impact
performance and never logs any trace information or performs
any run-time assertions. If an error is detected during the
call to <b>libpmemobj</b> function, an application may
retrieve an error message describing the reason of failure
using the following function:</p>

<p style="margin-left:11%; margin-top: 1em"><b>const char
*pmemobj_errormsg(void);</b></p>

<p style="margin-left:22%; margin-top: 1em">The
<b>pmemobj_errormsg</b>() function returns a pointer to a
static buffer containing the last error message logged for
current thread. The error message may include description of
the corresponding error code (if errno was set), as returned
by <b>strerror</b>(3). The error message buffer is
thread-local; errors encountered in one thread do not affect
its value in other threads. The buffer is never cleared by
any library function; its content is significant only when
the return value of the immediately preceding call to
<b>libpmemobj</b> function indicated an error, or if errno
was set. The application must not modify or free the error
message string, but it may be modified by subsequent calls
to other library functions.</p>

<p style="margin-left:11%; margin-top: 1em">A second
version of <b>libpmemobj</b>, accessed when a program uses
the libraries under <b>/usr/lib/nvml_debug</b>, contains
run-time assertions and trace points. The typical way to
access the debug version is to set the environment variable
<b>LD_LIBRARY_PATH</b> to <b>/usr/lib/nvml_debug</b> or
<b>/usr/lib64/nvml_debug</b> depending on where the debug
libraries are installed on the system. The trace points in
the debug version of the library are enabled using the
environment variable <b>PMEMOBJ_LOG_LEVEL</b>, which can be
set to the following values:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">0</p></td>
<td width="10%"></td>
<td width="78%">


<p style="margin-top: 1em">This is the default level when
<b>PMEMOBJ_LOG_LEVEL</b> is not set. No log messages are
emitted at this level.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>1</p></td>
<td width="10%"></td>
<td width="78%">


<p>Additional details on any errors detected are logged (in
addition to returning the errno-based errors as usual). The
same information may be retrieved using
<b>pmemobj_errormsg</b>().</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>2</p></td>
<td width="10%"></td>
<td width="78%">


<p>A trace of basic operations is logged.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>3</p></td>
<td width="10%"></td>
<td width="78%">


<p>This level enables a very verbose amount of function
call tracing in the library.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>4</p></td>
<td width="10%"></td>
<td width="78%">


<p>This level enables voluminous and fairly obscure tracing
information that is likely only useful to the
<b>libpmemobj</b> developers.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The environment
variable <b>PMEMOBJ_LOG_FILE</b> specifies a file name where
all logging information should be written. If the last
character in the name is &quot;-&quot;, the PID of the
current process will be appended to the file name when the
log file is created. If <b>PMEMOBJ_LOG_FILE</b> is not set,
the logging output goes to stderr.</p>

<p style="margin-left:11%; margin-top: 1em">Setting the
environment variable <b>PMEMOBJ_LOG_LEVEL</b> has no effect
on the non-debug version of <b>libpmemobj</b>.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See
http://pmem.io/nvml/libpmemobj for examples using the
<b>libpmemobj</b> API.</p>

<h2>ACKNOWLEDGEMENTS
<a name="ACKNOWLEDGEMENTS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>libpmemobj</b>
builds on the persistent memory programming model
recommended by the SNIA NVM Programming Technical Work
Group:</p>


<p style="margin-left:22%; margin-top: 1em">http://snia.org/nvmp</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>mmap</b>(2),
<b>munmap</b>(2), <b>msync</b>(2), <b>pthread_mutex</b>(3),
<b>pthread_rwlock</b>(3), <b>pthread_cond</b>(3),
<b>strerror</b>(3), <b>libpmemblk</b>(3),
<b>libpmemlog</b>(3), <b>libpmem</b>(3), <b>libvmem</b>(3)
and <b>http://pmem.io</b>.</p>
<hr>
</body>
</html>
