<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>NVML C++ bindings: nvml::obj::condition_variable Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<b>nvml</b>::<b>obj</b>::<a class="el" href="classnvml_1_1obj_1_1condition__variable.html">condition_variable</a></div>
<h1>nvml::obj::condition_variable Class Reference</h1><!-- doxytag: class="nvml::obj::condition_variable" -->Persistent memory resident condition variable.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="condition__variable_8hpp-source.html">libpmemobj++/condition_variable.hpp</a>&gt;</code>
<p>
<a href="classnvml_1_1obj_1_1condition__variable-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="eb183f9e516523ad5b005fc8daf8ebc6"></a><!-- doxytag: member="nvml::obj::condition_variable::native_handle_type" ref="eb183f9e516523ad5b005fc8daf8ebc6" args="" -->
typedef PMEMcond *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#eb183f9e516523ad5b005fc8daf8ebc6">native_handle_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The handle typedef to the underlying basic type. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2b91e82e9994f61a51c3116efd3dd297"></a><!-- doxytag: member="nvml::obj::condition_variable::condition_variable" ref="2b91e82e9994f61a51c3116efd3dd297" args="() noexcept" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#2b91e82e9994f61a51c3116efd3dd297">condition_variable</a> () noexcept</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defaulted constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="67930da2ec120d39b0f52eb48d772908"></a><!-- doxytag: member="nvml::obj::condition_variable::~condition_variable" ref="67930da2ec120d39b0f52eb48d772908" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#67930da2ec120d39b0f52eb48d772908">~condition_variable</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defaulted destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#ee8fa41f0baa2b5f3e62ae49adf38775">notify_one</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify and unblock one thread waiting on `*this` condition.  <a href="#ee8fa41f0baa2b5f3e62ae49adf38775"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#43c77e5293d76e841ad3714653f507d2">notify_all</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify and unblock all threads waiting on `*this` condition.  <a href="#43c77e5293d76e841ad3714653f507d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#b92729e5a91b915ed2bba89bfa52a627">wait</a> (<a class="el" href="classnvml_1_1obj_1_1mutex.html">mutex</a> &amp;lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified or it is woken up by some other measure.  <a href="#b92729e5a91b915ed2bba89bfa52a627"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Lock&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#8f0ddc994c9340c5701d54bc9cfbe0b0">wait</a> (Lock &amp;lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified or it is woken up by some other measure.  <a href="#8f0ddc994c9340c5701d54bc9cfbe0b0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#5e265138461e836d94a478fe1de4397a">wait</a> (<a class="el" href="classnvml_1_1obj_1_1mutex.html">mutex</a> &amp;lock, Predicate pred)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified.  <a href="#5e265138461e836d94a478fe1de4397a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Lock, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#08449a375796d5d4f199d22dbf3173bb">wait</a> (Lock &amp;lock, Predicate pred)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified.  <a href="#08449a375796d5d4f199d22dbf3173bb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Clock, typename Duration&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::cv_status&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#5bb2bf7e13b36464629f9256353c3254">wait_until</a> (<a class="el" href="classnvml_1_1obj_1_1mutex.html">mutex</a> &amp;lock, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified, a specific time is reached or it is woken up by some other measure.  <a href="#5bb2bf7e13b36464629f9256353c3254"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Lock, typename Clock, typename Duration&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::cv_status&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#be26a697dc8f0fed83005a053c370567">wait_until</a> (Lock &amp;lock, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified, a specific time is reached or it is woken up by some other measure.  <a href="#be26a697dc8f0fed83005a053c370567"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Clock, typename Duration, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#d724125fc10ffaaf227c7a5e90b953de">wait_until</a> (<a class="el" href="classnvml_1_1obj_1_1mutex.html">mutex</a> &amp;lock, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout, Predicate pred)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified or a specific time is reached.  <a href="#d724125fc10ffaaf227c7a5e90b953de"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Lock, typename Clock, typename Duration, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#5377eb0f3638266ce12f771d8d4d6b33">wait_until</a> (Lock &amp;lock, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout, Predicate pred)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified or a specific time is reached.  <a href="#5377eb0f3638266ce12f771d8d4d6b33"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Lock, typename Rep, typename Period&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::cv_status&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#90a78392d6ed3cc282c1f181d0953016">wait_for</a> (Lock &amp;lock, const std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified, the specified amount of time passes or it is woken up by some other measure.  <a href="#90a78392d6ed3cc282c1f181d0953016"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Lock, typename Rep, typename Period, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#163a8f85b971641ce125f22afd2272c5">wait_for</a> (Lock &amp;lock, const std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time, Predicate pred)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified or the specified amount of time passes.  <a href="#163a8f85b971641ce125f22afd2272c5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Rep, typename Period&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::cv_status&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#c5b94ac09b607e962b5a198d37aefa77">wait_for</a> (<a class="el" href="classnvml_1_1obj_1_1mutex.html">mutex</a> &amp;lock, const std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified, the specified amount of time passes or it is woken up by some other measure.  <a href="#c5b94ac09b607e962b5a198d37aefa77"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Rep, typename Period, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#c2cc6231f767aa070f66d650426e5359">wait_for</a> (<a class="el" href="classnvml_1_1obj_1_1mutex.html">mutex</a> &amp;lock, const std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time, Predicate pred)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified or the specified amount of time passes.  <a href="#c2cc6231f767aa070f66d650426e5359"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#eb183f9e516523ad5b005fc8daf8ebc6">native_handle_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#f0919ebbbc649722df21f4e65f16c41a">native_handle</a> () noexcept</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access a native handle to this condition variable.  <a href="#f0919ebbbc649722df21f4e65f16c41a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aca283134206d2feeda21914ac415e9b"></a><!-- doxytag: member="nvml::obj::condition_variable::operator=" ref="aca283134206d2feeda21914ac415e9b" args="(const condition_variable &amp;)" -->
<a class="el" href="classnvml_1_1obj_1_1condition__variable.html">condition_variable</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#aca283134206d2feeda21914ac415e9b">operator=</a> (const <a class="el" href="classnvml_1_1obj_1_1condition__variable.html">condition_variable</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deleted assignment operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="357b2ebaa50e85fcd7437c1a3c7c1642"></a><!-- doxytag: member="nvml::obj::condition_variable::condition_variable" ref="357b2ebaa50e85fcd7437c1a3c7c1642" args="(const condition_variable &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#357b2ebaa50e85fcd7437c1a3c7c1642">condition_variable</a> (const <a class="el" href="classnvml_1_1obj_1_1condition__variable.html">condition_variable</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deleted copy constructor. <br></td></tr>
<tr><td colspan="2"><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1bdb3f4d75c5e3ba7ab1ea8f7db80f51"></a><!-- doxytag: member="nvml::obj::condition_variable::wait_impl" ref="1bdb3f4d75c5e3ba7ab1ea8f7db80f51" args="(mutex &amp;lock)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#1bdb3f4d75c5e3ba7ab1ea8f7db80f51">wait_impl</a> (<a class="el" href="classnvml_1_1obj_1_1mutex.html">mutex</a> &amp;lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal implementation of the wait call. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="eb7c3a325499fa60492d1012d96b358d"></a><!-- doxytag: member="nvml::obj::condition_variable::wait_impl" ref="eb7c3a325499fa60492d1012d96b358d" args="(mutex &amp;lock, Predicate pred)" -->
template&lt;typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#eb7c3a325499fa60492d1012d96b358d">wait_impl</a> (<a class="el" href="classnvml_1_1obj_1_1mutex.html">mutex</a> &amp;lock, Predicate pred)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal implementation of the wait call. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="9f6b1eb4236829d6e3c9716434b521d4"></a><!-- doxytag: member="nvml::obj::condition_variable::wait_until_impl" ref="9f6b1eb4236829d6e3c9716434b521d4" args="(mutex &amp;lock, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;abs_timeout)" -->
template&lt;typename Clock, typename Duration&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::cv_status&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#9f6b1eb4236829d6e3c9716434b521d4">wait_until_impl</a> (<a class="el" href="classnvml_1_1obj_1_1mutex.html">mutex</a> &amp;lock, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;abs_timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal implementation of the wait_until call. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="167f220a9fcea7fd97e2d9a4768f53c0"></a><!-- doxytag: member="nvml::obj::condition_variable::wait_until_impl" ref="167f220a9fcea7fd97e2d9a4768f53c0" args="(mutex &amp;lock, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;abs_timeout, Predicate pred)" -->
template&lt;typename Clock, typename Duration, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#167f220a9fcea7fd97e2d9a4768f53c0">wait_until_impl</a> (<a class="el" href="classnvml_1_1obj_1_1mutex.html">mutex</a> &amp;lock, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;abs_timeout, Predicate pred)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal implementation of the wait_until call. <br></td></tr>
<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f8d73c2378bdb3a8c9e6ad71d1c7258b"></a><!-- doxytag: member="nvml::obj::condition_variable::pcond" ref="f8d73c2378bdb3a8c9e6ad71d1c7258b" args="" -->
PMEMcond&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#f8d73c2378bdb3a8c9e6ad71d1c7258b">pcond</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A POSIX style PMEM-resident condition variable. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Persistent memory resident condition variable. 
<p>
This class is an implementation of a PMEM-resident condition variable which mimics in behavior the C++11 std::condition_variable. The typical usage example would be:  doc_snippets/mutex.cpp cond_var_example 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="f0919ebbbc649722df21f4e65f16c41a"></a><!-- doxytag: member="nvml::obj::condition_variable::native_handle" ref="f0919ebbbc649722df21f4e65f16c41a" args="() noexcept" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classnvml_1_1obj_1_1condition__variable.html#eb183f9e516523ad5b005fc8daf8ebc6">native_handle_type</a> nvml::obj::condition_variable::native_handle           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Access a native handle to this condition variable. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to PMEMcond. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="43c77e5293d76e841ad3714653f507d2"></a><!-- doxytag: member="nvml::obj::condition_variable::notify_all" ref="43c77e5293d76e841ad3714653f507d2" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void nvml::obj::condition_variable::notify_all           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Notify and unblock all threads waiting on `*this` condition. 
<p>
Does nothing when no threads are waiting.     </td>
  </tr>
</table>
<a class="anchor" name="ee8fa41f0baa2b5f3e62ae49adf38775"></a><!-- doxytag: member="nvml::obj::condition_variable::notify_one" ref="ee8fa41f0baa2b5f3e62ae49adf38775" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void nvml::obj::condition_variable::notify_one           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Notify and unblock one thread waiting on `*this` condition. 
<p>
Does nothing when no threads are waiting. It is unspecified which thread is selected for unblocking.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classnvml_1_1lock__error.html">lock_error</a></em>&nbsp;</td><td>when the signal fails on the <a class="el" href="classnvml_1_1obj_1_1condition__variable.html#f8d73c2378bdb3a8c9e6ad71d1c7258b">pcond</a>. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="08449a375796d5d4f199d22dbf3173bb"></a><!-- doxytag: member="nvml::obj::condition_variable::wait" ref="08449a375796d5d4f199d22dbf3173bb" args="(Lock &amp;lock, Predicate pred)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Lock, typename Predicate&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void nvml::obj::condition_variable::wait           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Lock &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Predicate&nbsp;</td>
          <td class="mdname" nowrap> <em>pred</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Makes the current thread block until the condition variable is notified. 
<p>
This releases the lock, blocks the current thread and adds it to the list of threads waiting on `*this` condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait. This version is immune to spurious wake ups due to the provided predicate.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>a Lock object which meets the BasicLockableConcept. Needs to be based on a PMEM-resident <a class="el" href="classnvml_1_1obj_1_1mutex.html">obj::mutex</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pred</em>&nbsp;</td><td>predicate which returns `false` if waiting is to be continued.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classnvml_1_1lock__error.html">lock_error</a></em>&nbsp;</td><td>when unlocking the lock or waiting on <a class="el" href="classnvml_1_1obj_1_1condition__variable.html#f8d73c2378bdb3a8c9e6ad71d1c7258b">pcond</a> fails. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5e265138461e836d94a478fe1de4397a"></a><!-- doxytag: member="nvml::obj::condition_variable::wait" ref="5e265138461e836d94a478fe1de4397a" args="(mutex &amp;lock, Predicate pred)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Predicate&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void nvml::obj::condition_variable::wait           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classnvml_1_1obj_1_1mutex.html">mutex</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Predicate&nbsp;</td>
          <td class="mdname" nowrap> <em>pred</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Makes the current thread block until the condition variable is notified. 
<p>
This releases the lock, blocks the current thread and adds it to the list of threads waiting on `*this` condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait. This version is immune to spurious wake ups due to the provided predicate.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>a PMEM-resident <a class="el" href="classnvml_1_1obj_1_1mutex.html">obj::mutex</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pred</em>&nbsp;</td><td>predicate which returns `false` if waiting is to be continued.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classnvml_1_1lock__error.html">lock_error</a></em>&nbsp;</td><td>when unlocking the lock or waiting on <a class="el" href="classnvml_1_1obj_1_1condition__variable.html#f8d73c2378bdb3a8c9e6ad71d1c7258b">pcond</a> fails. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="8f0ddc994c9340c5701d54bc9cfbe0b0"></a><!-- doxytag: member="nvml::obj::condition_variable::wait" ref="8f0ddc994c9340c5701d54bc9cfbe0b0" args="(Lock &amp;lock)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Lock&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void nvml::obj::condition_variable::wait           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Lock &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>lock</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Makes the current thread block until the condition variable is notified or it is woken up by some other measure. 
<p>
This releases the lock, blocks the current thread and adds it to the list of threads waiting on `*this` condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>a Lock object which meets the BasicLockableConcept. Needs to be based on a PMEM-resident <a class="el" href="classnvml_1_1obj_1_1mutex.html">obj::mutex</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classnvml_1_1lock__error.html">lock_error</a></em>&nbsp;</td><td>when unlocking the lock or waiting on <a class="el" href="classnvml_1_1obj_1_1condition__variable.html#f8d73c2378bdb3a8c9e6ad71d1c7258b">pcond</a> fails. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b92729e5a91b915ed2bba89bfa52a627"></a><!-- doxytag: member="nvml::obj::condition_variable::wait" ref="b92729e5a91b915ed2bba89bfa52a627" args="(mutex &amp;lock)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void nvml::obj::condition_variable::wait           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classnvml_1_1obj_1_1mutex.html">mutex</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>lock</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Makes the current thread block until the condition variable is notified or it is woken up by some other measure. 
<p>
This releases the lock, blocks the current thread and adds it to the list of threads waiting on `*this` condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>a PMEM-resident <a class="el" href="classnvml_1_1obj_1_1mutex.html">obj::mutex</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classnvml_1_1lock__error.html">lock_error</a></em>&nbsp;</td><td>when unlocking the lock or waiting on <a class="el" href="classnvml_1_1obj_1_1condition__variable.html#f8d73c2378bdb3a8c9e6ad71d1c7258b">pcond</a> fails. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c2cc6231f767aa070f66d650426e5359"></a><!-- doxytag: member="nvml::obj::condition_variable::wait_for" ref="c2cc6231f767aa070f66d650426e5359" args="(mutex &amp;lock, const std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time, Predicate pred)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Rep, typename Period, typename Predicate&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">bool nvml::obj::condition_variable::wait_for           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classnvml_1_1obj_1_1mutex.html">mutex</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const std::chrono::duration&lt; Rep, Period &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>rel_time</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Predicate&nbsp;</td>
          <td class="mdname" nowrap> <em>pred</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Makes the current thread block until the condition variable is notified or the specified amount of time passes. 
<p>
This releases the lock, blocks the current thread and adds it to the list of threads waiting on `*this` condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>a PMEM-resident <a class="el" href="classnvml_1_1obj_1_1mutex.html">obj::mutex</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rel_time</em>&nbsp;</td><td>a specific duration, which when expired unblocks the thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pred</em>&nbsp;</td><td>predicate which returns `false` if waiting is to be continued.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>`false` if pred evaluates to `false` after timeout expired, otherwise `true`.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classnvml_1_1lock__error.html">lock_error</a></em>&nbsp;</td><td>when unlocking the lock or waiting on <a class="el" href="classnvml_1_1obj_1_1condition__variable.html#f8d73c2378bdb3a8c9e6ad71d1c7258b">pcond</a> fails. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c5b94ac09b607e962b5a198d37aefa77"></a><!-- doxytag: member="nvml::obj::condition_variable::wait_for" ref="c5b94ac09b607e962b5a198d37aefa77" args="(mutex &amp;lock, const std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Rep, typename Period&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::cv_status nvml::obj::condition_variable::wait_for           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classnvml_1_1obj_1_1mutex.html">mutex</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const std::chrono::duration&lt; Rep, Period &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>rel_time</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Makes the current thread block until the condition variable is notified, the specified amount of time passes or it is woken up by some other measure. 
<p>
This releases the lock, blocks the current thread and adds it to the list of threads waiting on `*this` condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>a PMEM-resident <a class="el" href="classnvml_1_1obj_1_1mutex.html">obj::mutex</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rel_time</em>&nbsp;</td><td>a specific duration, which when expired unblocks the thread.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>std::cv_status::timeout on timeout, std::cv_status::no_timeout otherwise.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classnvml_1_1lock__error.html">lock_error</a></em>&nbsp;</td><td>when unlocking the lock or waiting on <a class="el" href="classnvml_1_1obj_1_1condition__variable.html#f8d73c2378bdb3a8c9e6ad71d1c7258b">pcond</a> fails. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="163a8f85b971641ce125f22afd2272c5"></a><!-- doxytag: member="nvml::obj::condition_variable::wait_for" ref="163a8f85b971641ce125f22afd2272c5" args="(Lock &amp;lock, const std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time, Predicate pred)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Lock, typename Rep, typename Period, typename Predicate&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">bool nvml::obj::condition_variable::wait_for           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Lock &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const std::chrono::duration&lt; Rep, Period &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>rel_time</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Predicate&nbsp;</td>
          <td class="mdname" nowrap> <em>pred</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Makes the current thread block until the condition variable is notified or the specified amount of time passes. 
<p>
This releases the lock, blocks the current thread and adds it to the list of threads waiting on `*this` condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>a Lock object which meets the BasicLockableConcept. Needs to be based on a PMEM-resident <a class="el" href="classnvml_1_1obj_1_1mutex.html">obj::mutex</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rel_time</em>&nbsp;</td><td>a specific duration, which when expired unblocks the thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pred</em>&nbsp;</td><td>predicate which returns `false` if waiting is to be continued.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>`false` if pred evaluates to `false` after timeout expired, otherwise `true`.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classnvml_1_1lock__error.html">lock_error</a></em>&nbsp;</td><td>when unlocking the lock or waiting on <a class="el" href="classnvml_1_1obj_1_1condition__variable.html#f8d73c2378bdb3a8c9e6ad71d1c7258b">pcond</a> fails. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="90a78392d6ed3cc282c1f181d0953016"></a><!-- doxytag: member="nvml::obj::condition_variable::wait_for" ref="90a78392d6ed3cc282c1f181d0953016" args="(Lock &amp;lock, const std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Lock, typename Rep, typename Period&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::cv_status nvml::obj::condition_variable::wait_for           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Lock &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const std::chrono::duration&lt; Rep, Period &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>rel_time</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Makes the current thread block until the condition variable is notified, the specified amount of time passes or it is woken up by some other measure. 
<p>
This releases the lock, blocks the current thread and adds it to the list of threads waiting on `*this` condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>a Lock object which meets the BasicLockableConcept. Needs to be based on a PMEM-resident <a class="el" href="classnvml_1_1obj_1_1mutex.html">obj::mutex</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rel_time</em>&nbsp;</td><td>a specific duration, which when expired unblocks the thread.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>std::cv_status::timeout on timeout, std::cv_status::no_timeout otherwise.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classnvml_1_1lock__error.html">lock_error</a></em>&nbsp;</td><td>when unlocking the lock or waiting on <a class="el" href="classnvml_1_1obj_1_1condition__variable.html#f8d73c2378bdb3a8c9e6ad71d1c7258b">pcond</a> fails. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5377eb0f3638266ce12f771d8d4d6b33"></a><!-- doxytag: member="nvml::obj::condition_variable::wait_until" ref="5377eb0f3638266ce12f771d8d4d6b33" args="(Lock &amp;lock, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout, Predicate pred)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Lock, typename Clock, typename Duration, typename Predicate&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">bool nvml::obj::condition_variable::wait_until           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Lock &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Predicate&nbsp;</td>
          <td class="mdname" nowrap> <em>pred</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Makes the current thread block until the condition variable is notified or a specific time is reached. 
<p>
This releases the lock, blocks the current thread and adds it to the list of threads waiting on `*this` condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>a Lock object which meets the BasicLockableConcept. Needs to be based on a PMEM-resident <a class="el" href="classnvml_1_1obj_1_1mutex.html">obj::mutex</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>a specific point in time, which when reached unblocks the thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pred</em>&nbsp;</td><td>predicate which returns `false` if waiting is to be continued.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>`false` if pred evaluates to `false` after timeout expired, otherwise `true`.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classnvml_1_1lock__error.html">lock_error</a></em>&nbsp;</td><td>when unlocking the lock or waiting on <a class="el" href="classnvml_1_1obj_1_1condition__variable.html#f8d73c2378bdb3a8c9e6ad71d1c7258b">pcond</a> fails. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d724125fc10ffaaf227c7a5e90b953de"></a><!-- doxytag: member="nvml::obj::condition_variable::wait_until" ref="d724125fc10ffaaf227c7a5e90b953de" args="(mutex &amp;lock, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout, Predicate pred)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Clock, typename Duration, typename Predicate&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">bool nvml::obj::condition_variable::wait_until           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classnvml_1_1obj_1_1mutex.html">mutex</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Predicate&nbsp;</td>
          <td class="mdname" nowrap> <em>pred</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Makes the current thread block until the condition variable is notified or a specific time is reached. 
<p>
This releases the lock, blocks the current thread and adds it to the list of threads waiting on `*this` condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>a PMEM-resident <a class="el" href="classnvml_1_1obj_1_1mutex.html">obj::mutex</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>a specific point in time, which when reached unblocks the thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pred</em>&nbsp;</td><td>predicate which returns `false` if waiting is to be continued.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>`false` if pred evaluates to `false` after timeout expired, otherwise `true`.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classnvml_1_1lock__error.html">lock_error</a></em>&nbsp;</td><td>when unlocking the lock or waiting on <a class="el" href="classnvml_1_1obj_1_1condition__variable.html#f8d73c2378bdb3a8c9e6ad71d1c7258b">pcond</a> fails. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="be26a697dc8f0fed83005a053c370567"></a><!-- doxytag: member="nvml::obj::condition_variable::wait_until" ref="be26a697dc8f0fed83005a053c370567" args="(Lock &amp;lock, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Lock, typename Clock, typename Duration&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::cv_status nvml::obj::condition_variable::wait_until           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Lock &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>timeout</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Makes the current thread block until the condition variable is notified, a specific time is reached or it is woken up by some other measure. 
<p>
This releases the lock, blocks the current thread and adds it to the list of threads waiting on `*this` condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>a Lock object which meets the BasicLockableConcept. Needs to be based on a PMEM-resident <a class="el" href="classnvml_1_1obj_1_1mutex.html">obj::mutex</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>a specific point in time, which when reached unblocks the thread.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>std::cv_status::timeout on timeout, std::cv_status::no_timeout otherwise.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classnvml_1_1lock__error.html">lock_error</a></em>&nbsp;</td><td>when unlocking the lock or waiting on <a class="el" href="classnvml_1_1obj_1_1condition__variable.html#f8d73c2378bdb3a8c9e6ad71d1c7258b">pcond</a> fails. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5bb2bf7e13b36464629f9256353c3254"></a><!-- doxytag: member="nvml::obj::condition_variable::wait_until" ref="5bb2bf7e13b36464629f9256353c3254" args="(mutex &amp;lock, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Clock, typename Duration&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::cv_status nvml::obj::condition_variable::wait_until           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classnvml_1_1obj_1_1mutex.html">mutex</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>timeout</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Makes the current thread block until the condition variable is notified, a specific time is reached or it is woken up by some other measure. 
<p>
This releases the lock, blocks the current thread and adds it to the list of threads waiting on `*this` condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>a PMEM-resident <a class="el" href="classnvml_1_1obj_1_1mutex.html">obj::mutex</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>a specific point in time, which when reached unblocks the thread.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>std::cv_status::timeout on timeout, std::cv_status::no_timeout otherwise.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classnvml_1_1lock__error.html">lock_error</a></em>&nbsp;</td><td>when unlocking the lock or waiting on <a class="el" href="classnvml_1_1obj_1_1condition__variable.html#f8d73c2378bdb3a8c9e6ad71d1c7258b">pcond</a> fails. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li>nvml/src/include/libpmemobj++/<a class="el" href="condition__variable_8hpp-source.html">condition_variable.hpp</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Tue Sep 6 08:21:33 2016 for NVML C++ bindings by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
